# Framework Treeshaking Plan

## Goal

Generate a tailored `lib/rails.js` at build time that only includes code paths the application actually uses. This reduces bundle size for apps that don't need all framework features.

## Current State

The browser target's `rails.js` includes all features unconditionally:
- React rendering (~140KB when bundled)
- Turbo Streams WebSocket broadcasting
- Stimulus controller loading
- Flash message handling
- Turbo Drive navigation
- Form helpers / CSRF
- Layout wrapping

Apps pay for features they don't use. A simple ERB-only blog bundles React even though it never renders React elements.

## Proposed Architecture

### Detection Phase

The builder already inspects the app structure. Extend this to detect feature usage:

| Feature | Detection Method |
|---------|------------------|
| **React rendering** | `.rbx`, `.jsx`, `.tsx` files in `app/views/` or `app/components/` |
| **Turbo Streams** | `turbo_stream_from` in ERB, `broadcast_*_to` in models |
| **Stimulus** | `app/javascript/controllers/` directory exists |
| **Flash messages** | `flash[:notice]` or `flash[:alert]` in controllers |
| **Turbo Drive** | Default on, opt-out via config |
| **Form helpers** | `form_with` or `form_for` in ERB views |
| **Layout wrapper** | `app/views/layouts/application.html.erb` exists |

### Generation Phase

Instead of copying a static `rails.js`, generate it from modular pieces:

```
packages/ruby2js-rails/
├── core/
│   ├── application.js      # Base Application class (always included)
│   ├── router.js           # Router (always included)
│   ├── context.js          # Request context (always included)
│   ├── react-renderer.js   # React element rendering (conditional)
│   ├── turbo-broadcast.js  # WebSocket Turbo Streams (conditional)
│   ├── stimulus-loader.js  # Stimulus setup (conditional)
│   ├── flash.js            # Flash message handling (conditional)
│   └── layout.js           # Layout wrapper (conditional)
```

Builder generates `dist/lib/rails.js`:

```javascript
// Generated by Juntos - tailored for this application
export { Application } from 'ruby2js-rails/core/application.js';
export { Router } from 'ruby2js-rails/core/router.js';
export { Context } from 'ruby2js-rails/core/context.js';

// Included: app has .rbx files
export { ReactRenderer } from 'ruby2js-rails/core/react-renderer.js';

// Excluded: no broadcast_*_to usage detected
// export { TurboBroadcast } from 'ruby2js-rails/core/turbo-broadcast.js';

// Included: app/javascript/controllers/ exists
export { StimulusLoader } from 'ruby2js-rails/core/stimulus-loader.js';
```

### Application.renderContent Refactor

The key change is making `renderContent` pluggable:

```javascript
// core/application.js
class Application {
  static renderers = [];

  static registerRenderer(renderer) {
    this.renderers.push(renderer);
  }

  static renderContent(context, content) {
    for (const renderer of this.renderers) {
      if (renderer.canRender(content)) {
        return renderer.render(context, content);
      }
    }
    // Default: innerHTML for strings
    document.getElementById('content').innerHTML = content;
  }
}

// core/react-renderer.js
export const ReactRenderer = {
  canRender(content) {
    return content && typeof content === 'object' && content.$$typeof;
  },
  render(context, content) {
    import('react-dom/client').then(({ createRoot }) => {
      // ... React rendering logic
    });
  }
};

// In generated rails.js (only if React detected):
import { ReactRenderer } from 'ruby2js-rails/core/react-renderer.js';
Application.registerRenderer(ReactRenderer);
```

## Implementation Steps

### Phase 1: Feature Detection

Add detection methods to `SelfhostBuilder`:

```ruby
def detect_features
  {
    react: has_react_views?,
    turbo_streams: has_turbo_broadcasts?,
    stimulus: has_stimulus_controllers?,
    flash: has_flash_usage?,
    layouts: has_layout?
  }
end

def has_react_views?
  Dir.glob('app/{views,components}/**/*.{rbx,jsx,tsx}').any?
end

def has_turbo_broadcasts?
  # Check models for broadcast_*_to
  # Check views for turbo_stream_from
end
```

### Phase 2: Modularize rails.js

Split `targets/browser/rails.js` into separate modules:
- Extract React rendering to `core/react-renderer.js`
- Extract Turbo broadcast to `core/turbo-broadcast.js`
- Keep core Application/Router in `core/application.js`

### Phase 3: Generate Tailored rails.js

Update builder to generate `dist/lib/rails.js` based on detected features:

```ruby
def generate_rails_js(features)
  imports = ["import { Application, Router } from 'ruby2js-rails/core.js';"]

  if features[:react]
    imports << "import { ReactRenderer } from 'ruby2js-rails/core/react-renderer.js';"
    imports << "Application.registerRenderer(ReactRenderer);"
  end

  if features[:turbo_streams]
    imports << "import { TurboBroadcast } from 'ruby2js-rails/core/turbo-broadcast.js';"
  end

  # ... etc

  File.write('dist/lib/rails.js', imports.join("\n"))
end
```

### Phase 4: Conditional Dependencies

Update `generate_package_json` to only include deps for detected features:

```ruby
def generate_package_json(features)
  deps = { 'ruby2js-rails' => '...' }

  if features[:react]
    deps['react'] = '^18.2.0'
    deps['react-dom'] = '^18.2.0'
  end

  # ... etc
end
```

## Expected Bundle Size Impact

| App Type | Current | After Treeshaking |
|----------|---------|-------------------|
| ERB-only blog | ~290KB | ~150KB |
| Stimulus app | ~300KB | ~160KB |
| React app (workflow) | ~580KB | ~580KB (no change) |
| Full-featured app | ~600KB | ~600KB (no change) |

Main savings come from apps that don't use React (~140KB) or Turbo Streams broadcasting (~20KB).

## Risks and Mitigations

| Risk | Mitigation |
|------|------------|
| False negative detection | Conservative defaults (include if uncertain) |
| Dynamic feature usage | Config option to force-include features |
| Breaking existing apps | Feature flag to opt-in during transition |

## Configuration Override

Allow explicit feature configuration in `ruby2js.yml`:

```yaml
features:
  react: false        # Exclude even if .rbx files exist
  turbo_streams: true # Include even if not detected
  stimulus: auto      # Auto-detect (default)
```

## Future Enhancements

1. **Per-route code splitting**: Load React renderer only for routes that need it
2. **Lazy feature loading**: Dynamic import features on first use
3. **Dead code elimination**: Tree-shake unused Rails helpers
4. **CDN externals**: Option to load React from CDN instead of bundling
