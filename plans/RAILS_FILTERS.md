# Rails Filters: Idiomatic Rails to JavaScript

## Status: Phase 3 Complete

### Progress
- [x] **Phase 1: rails/controller** - Complete (2024-12)
- [x] **Phase 2: rails/model** - Complete (2024-12)
- [x] **Phase 3: rails/routes** - Complete (2024-12)
- [ ] Phase 4: rails/schema

## Overview

Transform idiomatic Rails code into JavaScript using AST filters. Rails developers write familiar Rails patterns; filters transform them into the proven micro-framework AST that runs in browser/Node.js.

### The Insight

We have two validated pieces:
1. **Target**: A micro-framework (modules with class methods, explicit view calls) that runs in browser
2. **Source**: Idiomatic Rails (classes with instance methods, implicit rendering, conventions)

Filters bridge the gap at the AST level. No runtime Rails - just compile-time transformation.

```
Idiomatic Rails    →    Rails Filters    →    Micro-framework AST    →    JavaScript
(familiar DX)           (compile-time)        (proven working)            (runtime)
```

### Why Filters?

1. **Proven pattern** - Ruby2JS already does this (Functions filter maps `select` → `filter`)
2. **Testable** - Each transformation is isolated and verifiable
3. **Incremental** - Build one filter at a time
4. **Composable** - Filters combine in pipeline
5. **Pitfall absorption** - Filters emit safe patterns, avoiding documented issues

## Architecture

### Filter Pipeline Order

```
Source Ruby (Rails idioms)
        ↓
[rails/controller]  ← Runs early, emits safe patterns
[rails/model]
[rails/routes]
[rails/schema]
        ↓
[functions]         ← Standard Ruby2JS filters
[esm]
[return]
        ↓
Converter           ← AST to JavaScript
        ↓
JavaScript Output
```

Rails filters run **early** in the pipeline, before Functions filter. This allows them to emit patterns that avoid known pitfalls.

### Pitfall Absorption Strategy

Rails filters transform idioms AND avoid documented transpilation issues:

| TRANSPILATION_NOTES Issue | Filter Strategy | Status |
|---------------------------|-----------------|--------|
| `index` → `indexOf` collision | Emit `index!` - converter drops bang, Functions ignores | ✅ Implemented |
| `new` reserved word | Emit `new!` - converter's `jsvar` produces `$new` | ✅ Implemented |
| `<<` operator not supported | Emit `push()` directly | Pending |
| `valid?` gets `.bind(this)` | Emit `is_valid` internally | Pending |
| `@attribute` shadowing | Emit `self.attribute` for parent access | Pending |
| Hash iteration `each` | Emit `Object.keys().each` pattern | Pending |
| `empty?` issues | Emit `.length == 0` | Pending |
| `class << self` not supported | Emit `def self.method` pattern | N/A (filters generate this) |
| `chomp` no JS equivalent | Emit `gsub(/x$/, '')` | Pending |

Filters become an **abstraction layer** - Rails developers write natural Ruby, filters handle the translation to safe intermediate AST.

### Lessons Learned (Phase 1)

1. **Converter fix required**: Reserved words in function names weren't escaped. Fixed `lib/ruby2js/converter/def.rb` to use `jsvar()` for function names. Test added to `spec/transliteration_spec.rb`.

2. **Process generated nodes**: AST nodes generated by filters must be wrapped in `process()` for downstream filters to transform them. Without this, ESM filter won't convert import statements.

3. **Strong params transformation**: The `params.require(:x).permit(:a, :b)` chain can be detected and simplified to just `params` since client-side code doesn't need server-side parameter filtering.

4. **Filter generates imports**: Unlike runtime Rails autoloading, compiled output needs explicit imports. Filter auto-generates based on model references found in code.

5. **Action-specific parameters**: Different actions need different parameters:
   - `show`, `edit`, `destroy` → `(id)`
   - `update` → `(id, params)`
   - `create` → `(params)`
   - `index`, `new` → `()`

6. **Rails-compatible inflector**: Added `lib/ruby2js/inflector.rb` (~70 lines) with Rails-compatible singularize rules. Handles irregular plurals (People→Person, Children→Child) correctly.

### Lessons Learned (Phase 2)

7. **Recursion prevention**: When a filter transforms a node and calls `process()` on the result, the same filter's handler may be called again if the transformed node matches the handler's pattern. Use a flag (e.g., `@rails_model_processing`) to prevent infinite recursion.

8. **Pluralize needed for table names**: Added `pluralize` to inflector for generating table names from model class names. Uses same pattern-matching approach as `singularize` with Rails-compatible rules.

9. **Scope lambda extraction**: Rails scopes use `-> { query }` lambda syntax. The lambda body needs to be extracted and transformed, with implicit `self` calls converted to explicit `this.method()` calls.

10. **Private method preservation**: Private methods referenced by callbacks need to be preserved in the output class. Track which methods are used and only include those.

### Lessons Learned (Phase 3)

11. **Block handling for routes**: The `on_block` handler is needed for DSL constructs like `Rails.application.routes.draw do`. The call node, args, and body are separate children of the block node.

12. **Nesting state tracking**: Nested resources require tracking the current nesting stack to build correct paths (`:article_id`) and pass correct params to path helpers.

13. **Path helper generation**: Path helpers need to handle both static paths (`articles_path`) and dynamic paths with interpolations (`article_path(article)`). Use `s(:dstr, ...)` for template literals.

14. **Extract_id helper**: Path helpers accept either an object (calls `.id()`) or a raw ID. The `extract_id` helper normalizes this: `obj?.id() || obj`.

## Filter Specifications

---

### rails/controller

**Purpose:** Transform Rails controller classes into micro-framework modules.

#### Input (Idiomatic Rails)

```ruby
class ArticlesController < ApplicationController
  before_action :set_article, only: [:show, :edit, :update, :destroy]

  def index
    @articles = Article.all
  end

  def show
  end

  def new
    @article = Article.new
  end

  def create
    @article = Article.new(article_params)
    if @article.save
      redirect_to @article
    else
      render :new
    end
  end

  def update
    if @article.update(article_params)
      redirect_to @article
    else
      render :edit
    end
  end

  def destroy
    @article.destroy
    redirect_to articles_path
  end

  private

  def set_article
    @article = Article.find(params[:id])
  end

  def article_params
    params.require(:article).permit(:title, :body)
  end
end
```

#### Output (Micro-framework AST equivalent)

```ruby
export module ArticlesController
  def self.index!
    articles = Article.all
    ArticleViews.index!({ articles: articles })
  end

  def self.show(id)
    article = Article.find(id)
    ArticleViews.show({ article: article })
  end

  def self.new_form
    article = { errors: [] }
    ArticleViews.new_article({ article: article })
  end

  def self.create(params)
    article = Article.create(params)
    if article.id
      { redirect: "/articles/#{article.id}" }
    else
      { html: ArticleViews.new_article({ article: article }) }
    end
  end

  def self.update(id, params)
    article = Article.find(id)
    Object.keys(params).each { |k| article[k] = params[k] }
    if article.save
      { redirect: "/articles/#{id}" }
    else
      { html: ArticleViews.edit({ article: article }) }
    end
  end

  def self.destroy(id)
    article = Article.find(id)
    article.destroy
    { redirect: "/articles" }
  end
end
```

#### Transformations (Implemented)

| Rails Pattern | JavaScript Output | Notes |
|---------------|-------------------|-------|
| `class XController < ApplicationController` | `export const XController = (() => {...})()` | IIFE module pattern |
| `def action` (instance method) | `function action()` | Exported in return object |
| `def index` | `function index()` via `index!` | Bang avoids Functions filter |
| `def new` | `function $new()` via `new!` | Reserved word escaped |
| `@articles = ...` | `let articles = ...` | Collected for view params |
| Implicit render | `return XViews.action({ivars})` | Auto-generated |
| `render :action` | `{render: "action"}` | Hash for router |
| `redirect_to @article` | `{redirect: \`/articles/${article.id()}\`}` | Template literal |
| `redirect_to articles_path` | `{redirect: "/articles"}` | Static path |
| `params[:id]` | `id` parameter | Added to function signature |
| `article_params` call | `params` | Inlined + chain simplified |
| `params.require(:x).permit(:a, :b)` | `params` | Permit list becomes documentation |
| `before_action :method, only: [...]` | Inlined code | Compile-time, no runtime overhead |
| Private methods | Removed (inlined where used) | Not exported |
| Model references | `import { X } from "../models/x.js"` | Auto-generated |
| View module | `import { XViews } from "../views/xs.js"` | Auto-generated |

#### Current Limitations

1. **Import paths**: Hardcoded convention `../models/` and `../views/`. Not configurable.
2. **Only standard RESTful actions**: Custom actions work but don't get special parameter handling.
3. **View module must exist**: Filter assumes `{Resource}Views` module exists with matching methods.

#### Detection

Filter activates when it sees:
- Class inheriting from `ApplicationController` or `*Controller < *`
- Class name ending in `Controller`

---

### rails/model

**Purpose:** Transform ActiveRecord model DSL into micro-framework patterns.

#### Input (Idiomatic Rails)

```ruby
class Article < ApplicationRecord
  has_many :comments, dependent: :destroy
  belongs_to :author, optional: true

  validates :title, presence: true
  validates :body, presence: true, length: { minimum: 10 }

  before_save :normalize_title
  after_create :notify_subscribers

  scope :published, -> { where(status: 'published') }
  scope :recent, -> { order(created_at: :desc).limit(10) }

  private

  def normalize_title
    self.title = title.strip.titleize
  end
end
```

#### Output (Micro-framework AST equivalent)

```ruby
export class Article < ApplicationRecord
  def self.table_name
    'articles'
  end

  # has_many :comments, dependent: :destroy
  def comments
    Comment.where({ article_id: self.id })
  end

  def destroy
    self.comments.each { |c| c.destroy }
    super.destroy
  end

  # belongs_to :author
  def author
    Author.find(self.author_id) rescue nil
  end

  # validates
  def validate
    validates_presence_of('title')
    validates_presence_of('body')
    validates_length_of('body', { minimum: 10 })
  end

  # before_save callback
  def before_save
    normalize_title
  end

  # after_create callback
  def after_create
    notify_subscribers
  end

  # scope :published
  def self.published
    self.where({ status: 'published' })
  end

  # scope :recent
  def self.recent
    self.order({ created_at: 'desc' }).limit(10)
  end

  def normalize_title
    self.title = self.title.strip
  end

  # Attribute accessors
  def title
    self.attributes['title']
  end

  def title=(value)
    self.attributes['title'] = value
  end

  # ... other attributes
end
```

#### Transformations (Implemented)

| Rails Pattern | JavaScript Output | Notes |
|---------------|-------------------|-------|
| `class X < ApplicationRecord` | `export class X extends ApplicationRecord` | Auto-generates `table_name()` |
| `has_many :comments` | `comments() { return Comment.where({article_id: this.id()}) }` | Infers class from association name |
| `has_many :x, class_name: 'Y'` | Uses specified class `Y` | Custom class name |
| `has_many :x, foreign_key: 'y_id'` | Uses specified foreign key | Custom foreign key |
| `has_many :x, dependent: :destroy` | Generates `destroy()` that cascades | Calls destroy on each associated record |
| `has_one :profile` | `profile() { return Profile.find_by({user_id: this.id()}) }` | Uses `find_by` instead of `where` |
| `belongs_to :author` | `author() { return Author.find(this.author_id()) }` | Infers foreign key |
| `belongs_to :x, optional: true` | Adds nil check before `find` | Returns null if foreign key is nil |
| `validates :x, presence: true` | `validate() { validates_presence_of("x") }` | Generates `validate` method |
| `validates :x, length: {min: 5}` | `validates_length_of("x", {minimum: 5})` | Supports length options |
| `validates :x, :y, presence: true` | Validates both attributes | Multiple attributes supported |
| `before_save :method` | `before_save() { method() }` | Generates hook method |
| `after_create :method` | `after_create() { method() }` | Any callback type supported |
| `before_save :a, :b` | `before_save() { a(); b() }` | Multiple callbacks chained |
| `scope :published, -> { where(...) }` | `static published() { return this.where(...) }` | Class method with query |
| Private methods used in callbacks | Preserved in class | Only used methods kept |

#### Current Limitations

1. **No automatic imports**: Unlike controller, model doesn't auto-generate imports for associated classes
2. **Callback timing**: Hooks generate methods but runtime must call them at correct times
3. **Validation methods**: Runtime must provide `validates_presence_of`, `validates_length_of`, etc.
4. **No has_and_belongs_to_many**: Only `has_many`, `has_one`, `belongs_to` supported

#### Detection

Filter activates when it sees:
- Class inheriting from `ApplicationRecord` or `ActiveRecord::Base`

---

### rails/routes

**Purpose:** Transform Rails route DSL into route definitions.

#### Input (Idiomatic Rails)

```ruby
Rails.application.routes.draw do
  root "articles#index"

  resources :articles do
    resources :comments, only: [:create, :destroy]
  end

  get 'about', to: 'pages#about'
  post 'contact', to: 'pages#contact'
end
```

#### Output (Micro-framework AST equivalent)

```ruby
export module Routes
  def self.routes
    [
      { path: '/', controller: 'ArticlesController', action: 'index!' },
      { path: '/articles', controller: 'ArticlesController', action: 'index!', method: 'GET' },
      { path: '/articles/new', controller: 'ArticlesController', action: 'new_form', method: 'GET' },
      { path: '/articles/:id', controller: 'ArticlesController', action: 'show', method: 'GET' },
      { path: '/articles/:id/edit', controller: 'ArticlesController', action: 'edit', method: 'GET' },
      { path: '/articles', controller: 'ArticlesController', action: 'create', method: 'POST' },
      { path: '/articles/:id', controller: 'ArticlesController', action: 'update', method: 'PATCH' },
      { path: '/articles/:id', controller: 'ArticlesController', action: 'destroy', method: 'DELETE' },
      { path: '/articles/:article_id/comments', controller: 'CommentsController', action: 'create', method: 'POST' },
      { path: '/articles/:article_id/comments/:id', controller: 'CommentsController', action: 'destroy', method: 'DELETE' },
      { path: '/about', controller: 'PagesController', action: 'about', method: 'GET' },
      { path: '/contact', controller: 'PagesController', action: 'contact', method: 'POST' }
    ]
  end

  # Path helpers
  def self.root_path
    '/'
  end

  def self.articles_path
    '/articles'
  end

  def self.article_path(article)
    "/articles/#{extract_id(article)}"
  end

  def self.new_article_path
    '/articles/new'
  end

  def self.edit_article_path(article)
    "/articles/#{extract_id(article)}/edit"
  end

  def self.article_comments_path(article)
    "/articles/#{extract_id(article)}/comments"
  end

  def self.extract_id(obj)
    (obj && obj.id) || obj
  end
end
```

#### Transformations (Implemented)

| Rails Pattern | JavaScript Output | Notes |
|---------------|-------------------|-------|
| `Rails.application.routes.draw do` | `export const Routes = (() => {...})()` | IIFE module pattern |
| `root "articles#index"` | `{path: "/", controller: "ArticlesController", action: "index!"}` | Plus `root_path()` helper |
| `resources :articles` | 7 route entries + path helpers | All RESTful routes |
| `resources :x, only: [...]` | Subset of routes | Filters to specified actions |
| `resources :x, except: [...]` | Routes without excluded | Excludes specified actions |
| Nested `resources` | `/articles/:article_id/comments` | Parent param in path |
| `get 'path', to: 'c#a'` | `{path: "/path", method: "GET", ...}` | Custom route |
| `post`, `patch`, `put`, `delete` | Route with HTTP method | All verbs supported |
| Path helpers | `articles_path()`, `article_path(article)` | Generated for all routes |
| `extract_id(obj)` | `obj?.id() \|\| obj` | Helper for path params |

#### Action Name Mapping

| Rails Action | JavaScript Action | Reason |
|--------------|-------------------|--------|
| `index` | `index!` | Avoids Functions filter collision |
| `new` | `$new` | Reserved word escaping |
| Others | Same name | No transformation needed |

#### Current Limitations

1. **No namespace/scope support**: `namespace :admin do` not implemented
2. **No member/collection routes**: `member do` blocks not supported
3. **No constraints**: Route constraints not implemented
4. **No concerns**: Routing concerns not supported

#### Detection

Filter activates when it sees:
- `Rails.application.routes.draw` block

---

### rails/schema

**Purpose:** Transform ActiveRecord schema DSL into SQL.

#### Input (Idiomatic Rails)

```ruby
ActiveRecord::Schema.define do
  create_table "articles" do |t|
    t.string "title", null: false
    t.text "body"
    t.integer "author_id"
    t.string "status", default: "draft"
    t.timestamps
  end

  create_table "comments" do |t|
    t.references "article", foreign_key: true
    t.string "commenter"
    t.text "body"
    t.timestamps
  end

  add_index "articles", ["author_id"]
  add_index "articles", ["status", "created_at"]
end
```

#### Output (Micro-framework AST equivalent)

```ruby
export module Schema
  def self.create_tables(db)
    db.run(%{
      CREATE TABLE IF NOT EXISTS articles (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        title TEXT NOT NULL,
        body TEXT,
        author_id INTEGER,
        status TEXT DEFAULT 'draft',
        created_at TEXT,
        updated_at TEXT
      )
    })

    db.run(%{
      CREATE TABLE IF NOT EXISTS comments (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        article_id INTEGER NOT NULL,
        commenter TEXT,
        body TEXT,
        created_at TEXT,
        updated_at TEXT,
        FOREIGN KEY (article_id) REFERENCES articles(id)
      )
    })

    db.run(%{ CREATE INDEX IF NOT EXISTS idx_articles_author_id ON articles(author_id) })
    db.run(%{ CREATE INDEX IF NOT EXISTS idx_articles_status_created ON articles(status, created_at) })
  end
end
```

#### Transformations

| Rails Pattern | SQL Output |
|---------------|------------|
| `create_table "x"` | `CREATE TABLE IF NOT EXISTS x` |
| `t.string "col"` | `col TEXT` |
| `t.text "col"` | `col TEXT` |
| `t.integer "col"` | `col INTEGER` |
| `t.boolean "col"` | `col INTEGER` (0/1) |
| `t.datetime "col"` | `col TEXT` (ISO format) |
| `t.timestamps` | `created_at TEXT, updated_at TEXT` |
| `null: false` | `NOT NULL` |
| `default: value` | `DEFAULT 'value'` |
| `t.references "x"` | `x_id INTEGER, FOREIGN KEY` |
| `add_index "t", ["cols"]` | `CREATE INDEX` |

#### Detection

Filter activates when it sees:
- `ActiveRecord::Schema.define` block
- Or file named `schema.rb` in db/ or config/

---

### rails/erb (existing)

The ERB filter already exists and handles template transpilation. It transforms ERB buffer patterns into render functions.

**Enhancement needed:** Accept instance variables and generate proper destructured parameters matching controller output.

### View Strategy: ERB (and Phlex) Only

The current demo supports two view approaches:
1. **Ruby Module views** - Explicit modules with methods returning HTML strings
2. **ERB templates** - Standard `.html.erb` files transpiled to render functions

With Rails filters in place, **Ruby Module views become an implementation detail**:

| Layer | Developer Writes | Filter Produces |
|-------|------------------|-----------------|
| Controllers | Rails classes | Module with class methods |
| Views | ERB templates | Render functions |
| Models | ActiveRecord DSL | ApplicationRecord subclass |

The Ruby Module approach was valuable for:
- Proving the micro-framework works
- Documenting the compilation target
- Understanding generated AST

Going forward:
- **ERB** is the primary view format (familiar to Rails developers)
- **Phlex** will be added as an alternative (Stage 4)
- **Ruby Module views** are removed from the demo UI - they're what gets generated, not written

The demo toggle changes from "Ruby Module / ERB" to "ERB / Phlex" (once Phlex is implemented).

---

## Compile-Time Optimizations

A key advantage of filters: shift complexity from runtime to compile-time. The micro-framework runtime becomes thinner.

### Opportunities

| Currently Runtime | Compile-Time Alternative | Benefit |
|-------------------|-------------------------|---------|
| `get table_name()` method | Inline `"articles"` literal | Eliminate method call |
| Manual attribute accessors | Auto-generate from schema | Less boilerplate, fewer errors |
| `before_action` callback mechanism | Inline code at action start | No callback registration/invocation |
| Path helpers as methods | Inline static paths as literals | Eliminate method calls |
| Association method bodies | Generate with inlined class refs | Direct references, no lookup |
| Validation definitions | Generate validation code directly | No DSL interpretation at runtime |

### before_action Inlining

Instead of runtime callback registration:

```ruby
# Input
class ArticlesController < ApplicationController
  before_action :set_article, only: [:show, :edit, :update, :destroy]

  def show; end

  private
  def set_article
    @article = Article.find(params[:id])
  end
end
```

Filter inlines directly:

```ruby
# Output (before further transformation)
export module ArticlesController
  def self.show(id)
    article = Article.find(id)  # inlined from set_article
    ArticleViews.show({ article: article })
  end
end
```

No callback array, no action filtering, no runtime overhead.

### Schema-Driven Code Generation

If `rails/schema` filter shares column metadata with `rails/model` filter:

```ruby
# Schema input
create_table "articles" do |t|
  t.string "title", null: false
  t.text "body"
  t.integer "view_count", default: 0
  t.timestamps
end
```

Model filter auto-generates:

```ruby
# Generated (no manual accessors needed)
export class Article < ApplicationRecord
  # Columns known at compile time
  COLUMNS = ['id', 'title', 'body', 'view_count', 'created_at', 'updated_at']

  # Auto-generated accessors with type awareness
  def title
    self.attributes['title']
  end

  def title=(value)
    self.attributes['title'] = String(value)
  end

  def view_count
    self.attributes['view_count']
  end

  def view_count=(value)
    self.attributes['view_count'] = Number(value) || 0
  end

  # ... etc
end
```

Benefits:
- No manual accessor definitions in model files
- Type coercion based on column type
- Column list available without runtime introspection
- INSERT/UPDATE statements use known columns

### Path Helper Inlining

Static paths become literals:

```ruby
# Input
redirect_to articles_path

# Output (static path)
{ redirect: "/articles" }
```

Dynamic paths use minimal interpolation:

```ruby
# Input
redirect_to article_path(@article)

# Output (no method call)
{ redirect: "/articles/#{article.id}" }
```

### What Stays Runtime

Some things must remain runtime:
- SQL execution (operates on runtime data)
- Query building with dynamic conditions (`where(status: params[:status])`)
- ApplicationRecord base CRUD operations
- View rendering (template execution)

But ApplicationRecord becomes a **thin runtime library** rather than a framework - most configuration is compiled away.

### Filter Communication

For schema-driven generation, filters need to share metadata:

```ruby
# Option 1: Shared context during transpilation
Ruby2JS.convert(source, filters: [...], schema: parsed_schema)

# Option 2: Filter pipeline passes metadata forward
# rails/schema populates context, rails/model reads it

# Option 3: Convention-based file loading
# rails/model filter reads db/schema.rb automatically
```

Design decision: TBD based on implementation experience.

---

## Filter Interaction

### Naming Conventions

Filters need to agree on naming:

| Concept | Convention |
|---------|------------|
| Controller module | `{Resource}Controller` |
| View module | `{Resource}Views` |
| Model class | `{Resource}` (singular) |
| Table name | `{resources}` (plural) |
| Path helpers | `{resource}_path`, `{resources}_path` |

### View Discovery

Controller filter needs to know view naming:
1. Controller `ArticlesController` → Views `ArticleViews`
2. Action `index` → View method `index!` (with bang to avoid collision)
3. Action `new` → View method `new_article` (convention for `new` reserved word)

### Parameter Passing

Controllers collect instance variables and pass to views:
```ruby
# Controller emits:
ArticleViews.show({ article: article, comments: comments })

# View expects (ERB filter generates):
function render({ article, comments }) { ... }
```

---

## Testing Strategy

### Unit Tests (per filter)

Each filter has isolated tests:

```ruby
describe Ruby2JS::Filter::Rails::Controller do
  def to_js(source)
    Ruby2JS.convert(source, filters: [Ruby2JS::Filter::Rails::Controller])
  end

  it "converts instance methods to class methods" do
    source = <<~RUBY
      class ArticlesController < ApplicationController
        def index
          @articles = Article.all
        end
      end
    RUBY

    result = to_js(source)
    expect(result).to include('def self.index!')
    expect(result).to include('ArticleViews.index!')
  end

  it "transforms redirect_to" do
    # ...
  end
end
```

### Integration Tests

Full pipeline tests with all Rails filters:

```ruby
describe "Rails filter pipeline" do
  def to_js(source)
    Ruby2JS.convert(source, filters: [
      Ruby2JS::Filter::Rails::Controller,
      Ruby2JS::Filter::Rails::Model,
      Ruby2JS::Filter::Functions,
      Ruby2JS::Filter::ESM,
      Ruby2JS::Filter::Return
    ])
  end

  it "produces working controller JavaScript" do
    # Full controller → JS → eval → works
  end
end
```

### Demo Tests

The Rails-in-JS demo serves as an integration test:
- Write idiomatic Rails
- Apply filters
- Run in browser
- Verify CRUD works

---

## Delivery Order

### Phase 1: rails/controller (highest value)

The controller filter provides the most visible Rails experience improvement.

**Tasks:**
1. Basic class → module transformation
2. Instance method → class method
3. Instance variable collection
4. Implicit view call injection
5. `redirect_to` transformation
6. `render` transformation
7. `params` transformation
8. `before_action` support
9. Private method handling

**Deliverable:** Write idiomatic Rails controllers, get working JavaScript.

### Phase 2: rails/model

Model DSL support for associations and validations.

**Tasks:**
1. `has_many` transformation
2. `belongs_to` transformation
3. `dependent: :destroy` support
4. `validates` DSL transformation
5. Callback support (`before_save`, etc.)
6. `scope` transformation

**Deliverable:** Write idiomatic Rails models, get working JavaScript.

### Phase 3: rails/routes

Route DSL for path helpers and route definitions.

**Tasks:**
1. `resources` expansion
2. Nested resources
3. Path helper generation
4. Custom routes (`get`, `post`, etc.)
5. `root` route

**Deliverable:** Write idiomatic `routes.rb`, get working router.

### Phase 4: rails/schema

Schema DSL for database setup.

**Tasks:**
1. `create_table` transformation
2. Column type mapping
3. `timestamps` support
4. `references` and foreign keys
5. Index creation

**Deliverable:** Write idiomatic `schema.rb`, get working database setup.

---

## Success Criteria

### Phase 1 Complete When: ✅ DONE

- [x] Controller filter transforms idiomatic Rails controller
- [x] Instance variables automatically passed to views
- [x] `redirect_to` produces correct output
- [x] `before_action` works for listed actions
- [x] Strong params (`article_params`) inlined and transformed
- [x] Imports auto-generated for models and views
- [x] Reserved word handling (`new` → `$new`, `index` → `index!`)
- [ ] Demo works with idiomatic controller (pending demo update)

**Files created:**
- `lib/ruby2js/filter/rails/controller.rb` (~570 lines)
- `lib/ruby2js/inflector.rb` (~70 lines) - Rails-compatible singularize
- `spec/rails_controller_spec.rb` (19 tests, 74 assertions)
- `spec/inflector_spec.rb` (11 tests, 36 assertions)

### Phase 2 Complete When: ✅ DONE

- [x] Model filter transforms `has_many`, `belongs_to`
- [x] `validates` DSL produces working validations
- [x] Callbacks generate hook methods (`before_save`, `after_create`, etc.)
- [x] Scopes produce static class methods with chained queries
- [x] `dependent: :destroy` generates cascading destroy
- [ ] Demo models are idiomatic Rails (pending demo update)

**Files created/modified:**
- `lib/ruby2js/filter/rails/model.rb` (~350 lines)
- `lib/ruby2js/inflector.rb` - Added `pluralize` method (~40 lines)
- `spec/rails_model_spec.rb` (21 tests, 78 assertions)
- `spec/inflector_spec.rb` - Added pluralize tests (22 tests, 72 assertions)

### Phase 3 Complete When: ✅ DONE

- [x] `resources :x` generates all 7 RESTful routes
- [x] Nested resources work with parent param (`:article_id`)
- [x] Path helpers generated for all routes
- [x] `only:` and `except:` options respected
- [x] Custom routes (`get`, `post`, `patch`, `put`, `delete`)
- [x] `root` route support
- [ ] Demo routes.rb is idiomatic Rails (pending demo update)

**Files created:**
- `lib/ruby2js/filter/rails/routes.rb` (~400 lines)
- `spec/rails_routes_spec.rb` (23 tests, 112 assertions)

### Phase 4 Complete When:

- [ ] `create_table` generates valid SQL
- [ ] All common column types supported
- [ ] Demo schema.rb is idiomatic Rails

### Overall Success:

The Rails-in-JS demo can be rewritten using **idiomatic Rails patterns** (as shown in the original RAILS_IN_JS.md plan Stage 1), and the filters transform it to working JavaScript.

A Rails developer should look at the code and say "that's just Rails."

---

## Implications for Remaining Phases

Based on Phase 1 implementation experience:

### Phase 2 (rails/model)
- **Reserved words**: May need similar handling for methods like `delete`, `class`
- **Process nodes**: Remember to wrap generated AST in `process()` for filter chain
- **Validation methods**: `valid?` predicate needs special handling (emit `is_valid`)
- **Association imports**: Like controller imports, may need to auto-generate model imports

### Phase 3 (rails/routes)
- **Path helper naming**: Must match controller's `index!` / `$new` patterns
- **Action mapping**: `index` → `index`, `new` → `$new` in route definitions
- **Integration with controller**: Router needs to call methods with correct names

### Phase 4 (rails/schema)
- **Metadata sharing**: Consider how schema info flows to model filter
- **Column accessors**: Could auto-generate based on schema columns
- **Type mapping**: SQLite TEXT for most types works for demo

### General Patterns Established
- Filters emit `!`-suffixed names to avoid Functions filter collisions
- Converter's `jsvar()` handles reserved words with `$` prefix
- `process()` is essential for generated nodes to flow through filter pipeline
- Auto-generating imports based on code analysis works well

## Open Questions

1. **Filter registration:** Separate gem? Part of core Ruby2JS? Opt-in?
2. **Error messages:** How to report when Rails patterns can't be transformed?
3. **Partial support:** Which Rails features are out of scope?
4. **View helper methods:** `link_to`, `form_with` - filter or runtime?
5. **Testing Rails code:** Can we run the same tests in Ruby and JS?

---

## References

- [RAILS_IN_JS.md](./RAILS_IN_JS.md) - Original demo plan with idiomatic Rails examples
- [TRANSPILATION_NOTES.md](../demo/rails-in-js/TRANSPILATION_NOTES.md) - Documented pitfalls to absorb
- [Ruby2JS Filters Documentation](https://www.ruby2js.com/docs/filters)
- [Rails Getting Started Guide](https://guides.rubyonrails.org/getting_started.html)
