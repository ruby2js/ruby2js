# Preface

If I were to start a separate Claude session and ask if it were possible to run Rails apps on GitHub pages, Cloudflare Workers, Android Phones, or to integrate with React in ways that are comparable to React Server Components, the answer would be no. But the key is in how the question is phrased: none of that is possible with Ruby on Rails, all of it is possible with JavaScript, so the remaining task is Ruby to JavaScript, and Ruby2JS has already made substantial progress on making that a reality, and what is left is merely work to the done.

Once the three plans (node-target-rpc.md, path-helper-rpc.md, and notes-demo.md) are complete I'll post to twitter, bluesky, mastadon and linkedin a link to a blog post. The blog post will link to demos and docs. The goal will be to attract users and contributors.

I'm retired and the code is open source; there are no deadlines. If in the course of implementing these plans we find a transpilation bug or a missing feature, I would rather pause progress on plans, fix the bug or add the feature, complete with tests and docs, then resume the plan. To do anything less incurs technical debt.

A few links for when the time comes. I'm posting them here because undoubtedly there will be need to compact and I don't want the context to be lost:

- `CLAUDE.md` - project instructions for Claude Code
- `./docs/src/_docs` - documentation
- `test/integration` - integration tests
- `./demo/selfhost/spec_manifest.json` - selfhost status
- `./docs/src/_docs/filters/pragma.md` - pragmas
- `.github/workflows/ci.yml` - publishes the demos
- `packages/ruby2js-rails/` - npm package with runtime (rpc/, adapters/, targets/)

The bulk of the code is written in Ruby and transpiles to JavaScript. Vite run the JavaScript, so it is important that the implementation transpiles correctly. If need be we may need to add pragmas or complete more of the selfhost effort.

# Plan: Path Helper RPC for Ruby2JS-Rails

## Goal

Enable RBX views to call controller actions via path helpers with HTTP method semantics. Path helpers become callable endpoints that return Response objects, following Rails conventions.

## Vision

From the blog post:

> The next step is to follow the lead of Rails path helpers to provide ways for views to make calls to controller actions. `config/routes.rb` provides the roadmap. Path helpers have get, post, put, and delete methods which return Response objects. Call `blob`, `bytes`, `json`, or `text`. Pass the results to `Turbo.renderStreamMessage`.

## Current State

Path helpers generated by `rails/routes` filter return URL strings:

```javascript
articles_path()        // → "/articles"
article_path(article)  // → "/articles/1"
new_article_path()     // → "/articles/new"
```

## Target State

Path helpers return objects with HTTP methods that return `Response` objects:

```ruby
# GET requests - params become query string
articles_path.get(format: :json)           # GET /articles.json
articles_path.get(page: 2, format: :json)  # GET /articles.json?page=2

# POST/PUT/PATCH/DELETE - params become JSON body
articles_path.post(title: "New", format: :json)  # POST /articles.json
article_path(1).get(format: :json)               # GET /articles/1.json
article_path(1).patch(title: "Updated")          # PATCH /articles/1
article_path(1).delete                           # DELETE /articles/1
```

## Target-Specific Behavior

Same API, different implementation based on build target:

| Target | Behavior |
|--------|----------|
| Server (Node, Cloudflare, etc.) | `fetch()` to HTTP endpoint |
| Browser | Direct call to client-side controller, synthetic `Response` |

This mirrors the model adapter pattern (Dexie vs RPC). Implementation via either:
- Target-aware filter transformation, or
- Vite aliasing to swap `path_helper.mjs` / `path_helper_browser.mjs`

## API Design

### Format Parameter (Rails Convention)

All HTTP methods accept a `format` parameter:
- `:json` → appends `.json` to URL
- `:html` → appends `.html` (or no extension, default)
- `:turbo_stream` → appends `.turbo_stream`
- String values also accepted: `format: 'json'`

### GET Requests

Parameters (excluding `format`) become query string:

```ruby
articles_path.get(page: 2, per_page: 10, format: :json)
# → GET /articles.json?page=2&per_page=10
```

### POST/PUT/PATCH/DELETE Requests

Parameters (excluding `format`) become JSON body:

```ruby
articles_path.post(article: { title: "New", body: "Content" }, format: :json)
# → POST /articles.json
# → Content-Type: application/json
# → Body: {"article":{"title":"New","body":"Content"}}
```

### Return Value

- Returns native [`Response`](https://developer.mozilla.org/en-US/docs/Web/API/Response) object
- Caller consumes with `.json()`, `.text()`, `.blob()`, `.bytes()`
- Turbo Stream responses can be passed to `Turbo.renderStreamMessage()`

### CSRF Protection

- Mutating requests (POST/PUT/PATCH/DELETE) include CSRF token automatically
- Token read from `<meta name="csrf-token">` (same as RPC client)
- Header: `X-Authenticity-Token`

## Implementation

### Phase 1: PathHelper Class (Server Target)

**File**: `packages/ruby2js-rails/lib/path_helper.mjs`

```javascript
/**
 * Create a path helper with HTTP methods
 * @param {string} path - The URL path
 * @returns {PathHelper} Object with get/post/put/patch/delete methods
 */
export function createPathHelper(path) {
  const helper = {
    // Preserve string coercion for backward compatibility
    toString() { return path; },
    valueOf() { return path; },

    async get(params = {}) {
      const { format, ...query } = params;
      const url = buildUrl(path, format, query);
      return fetch(url, {
        method: 'GET',
        headers: { 'Accept': acceptHeader(format) },
        credentials: 'same-origin'
      });
    },

    async post(params = {}) {
      return mutatingRequest('POST', path, params);
    },

    async put(params = {}) {
      return mutatingRequest('PUT', path, params);
    },

    async patch(params = {}) {
      return mutatingRequest('PATCH', path, params);
    },

    async delete(params = {}) {
      return mutatingRequest('DELETE', path, params);
    }
  };

  return helper;
}

function buildUrl(path, format, query = {}) {
  let url = path;

  // Append format extension
  if (format) {
    const ext = typeof format === 'symbol' ? format.description : format;
    url += `.${ext}`;
  }

  // Append query string
  const queryString = new URLSearchParams(query).toString();
  if (queryString) {
    url += `?${queryString}`;
  }

  return url;
}

function acceptHeader(format) {
  const formatStr = typeof format === 'symbol' ? format.description : format;
  switch (formatStr) {
    case 'json': return 'application/json';
    case 'turbo_stream': return 'text/vnd.turbo-stream.html';
    default: return 'text/html';
  }
}

function getCSRFToken() {
  return document.querySelector('meta[name="csrf-token"]')?.content;
}

async function mutatingRequest(method, path, params) {
  const { format, ...body } = params;
  const url = buildUrl(path, format);

  const headers = {
    'Content-Type': 'application/json',
    'Accept': acceptHeader(format)
  };

  const token = getCSRFToken();
  if (token) {
    headers['X-Authenticity-Token'] = token;
  }

  return fetch(url, {
    method,
    headers,
    credentials: 'same-origin',
    body: Object.keys(body).length > 0 ? JSON.stringify(body) : undefined
  });
}
```

### Phase 1b: PathHelper Class (Browser Target)

**File**: `packages/ruby2js-rails/lib/path_helper_browser.mjs`

For browser targets, path helpers invoke client-side controllers directly and return synthetic `Response` objects:

```javascript
import { Router } from './rails.js';

export function createPathHelper(path, controllerAction) {
  const helper = {
    toString() { return path; },
    valueOf() { return path; },

    async get(params = {}) {
      const { format, ...query } = params;
      const result = await invokeController('GET', path, format, query);
      return syntheticResponse(result, format);
    },

    async post(params = {}) {
      const { format, ...body } = params;
      const result = await invokeController('POST', path, format, body);
      return syntheticResponse(result, format);
    },

    // ... put, patch, delete similarly
  };

  return helper;
}

async function invokeController(method, path, format, params) {
  // Route to client-side controller
  const { controller, action, routeParams } = Router.match(path, method);
  const context = Router.createContext({ ...routeParams, ...params });
  return await controller[action](context, ...Object.values(routeParams));
}

function syntheticResponse(result, format) {
  // Wrap controller result in Response-like object
  return {
    ok: true,
    status: 200,
    async json() { return result; },
    async text() { return typeof result === 'string' ? result : JSON.stringify(result); },
    async blob() { return new Blob([JSON.stringify(result)]); }
  };
}
```

Vite aliasing swaps implementations:
- Server targets: `lib/path_helper.mjs` (fetch-based)
- Browser target: `lib/path_helper_browser.mjs` (direct invocation)

### Phase 1c: CSRF Token Integration

Currently CSRF tokens work for RPC model calls but not for regular form submissions or path helper calls.

**Server validation** - Update `Router.dispatch()` in `rails_server.js`:

```javascript
// After parsing body, before processing mutating requests
if (['POST', 'PATCH', 'PUT', 'DELETE'].includes(method)) {
  const token = req.headers['x-authenticity-token'] || params.authenticity_token;
  if (!csrf.validateToken(token)) {
    res.writeHead(422, { 'Content-Type': 'text/html' });
    res.end('<h1>422 Invalid Authenticity Token</h1>');
    return;
  }
}
```

**Layout meta tag** - Update `csrf_meta_tags` helper in `rails/helpers.rb`:

```ruby
# Currently stubbed - change to:
if method == :csrf_meta_tags && target.nil?
  # Reference token from context passed to render function
  return s(:gvar, :$csrfMetaTag)
end
```

The server passes `$csrfMetaTag` when rendering views (output of `csrfMetaTag()` from rpc/server.mjs).

**Form hidden fields** - Update form helpers (form_with, form_for, form_tag, button_to):

```html
<input type="hidden" name="authenticity_token" value="${$context.authenticityToken}">
```

Forms reference `$context.authenticityToken` which is passed at render time.

**File changes:**
- `packages/ruby2js-rails/rails_server.js` - Add token validation to dispatch
- `packages/ruby2js-rails/targets/node/rails.js` - Add token validation to dispatch
- `lib/ruby2js/filter/rails/helpers.rb` - Update csrf_meta_tags, add hidden field to forms

### Phase 2: Update rails/routes Filter

**File**: `lib/ruby2js/filter/rails/routes.rb`

Modify `build_path_helper` to return `createPathHelper()` calls:

```ruby
def build_path_helper(helper)
  path = helper[:path]
  params = helper[:params]

  if params.empty?
    # Static path: createPathHelper("/articles")
    body = s(:send, nil, :createPathHelper, s(:str, path))
  else
    # Dynamic path: createPathHelper(`/articles/${extract_id(article)}`)
    # Build interpolated string as before, wrap in createPathHelper
    body = s(:send, nil, :createPathHelper, build_interpolated_path(helper))
  end

  args = params.map { |p| s(:arg, p) }
  s(:def, helper[:name], s(:args, *args), s(:autoreturn, body))
end
```

Add import for `createPathHelper`:

```ruby
def build_paths_only_module
  statements = []

  # Import createPathHelper
  statements << s(:import, 'ruby2js-rails/lib/path_helper.mjs',
    [s(:const, nil, :createPathHelper)])

  # ... rest of path helper generation
end
```

### Phase 3: Package Export

**File**: `packages/ruby2js-rails/package.json`

Add export:

```json
{
  "exports": {
    "./lib/path_helper.mjs": "./lib/path_helper.mjs"
  }
}
```

### Phase 4: RBX Integration (Optional Enhancement)

Track path helper usage in RBX files for auto-import, similar to how `rails/helpers` tracks them for ERB.

**Option A**: Add to react filter
**Option B**: Require explicit imports (simpler, more explicit)

Recommend Option B initially - explicit imports are clearer and match the model import pattern shown in the workflow demo.

## File Changes Summary

| File | Change |
|------|--------|
| `packages/ruby2js-rails/lib/path_helper.mjs` | NEW - PathHelper with fetch (server targets) |
| `packages/ruby2js-rails/lib/path_helper_browser.mjs` | NEW - PathHelper with direct invocation (browser target) |
| `lib/ruby2js/filter/rails/routes.rb` | Update to use createPathHelper() |
| `packages/ruby2js-rails/vite.mjs` | Alias path_helper based on target |
| `packages/ruby2js-rails/package.json` | Export path_helper modules |
| `packages/ruby2js-rails/rails_server.js` | Add CSRF validation to dispatch |
| `packages/ruby2js-rails/targets/node/rails.js` | Add CSRF validation to dispatch |
| `lib/ruby2js/filter/rails/helpers.rb` | csrf_meta_tags output, form hidden fields |

## Usage Examples

### Basic CRUD in RBX

```ruby
import { articles_path, article_path } from '../../../config/paths.js'

export default def ArticleList()
  articles, setArticles = useState([])

  # Load articles on mount
  useEffect(-> {
    articles_path.get(format: :json).then do |response|
      response.json.then { |data| setArticles(data) }
    end
  }, [])

  # Create new article
  handleCreate = ->(form_data) {
    articles_path.post(article: form_data, format: :json).then do |response|
      response.json.then { |article| setArticles([...articles, article]) }
    end
  }

  # Delete article
  handleDelete = ->(article) {
    article_path(article).delete.then do
      setArticles(articles.filter { |a| a.id != article.id })
    end
  }

  %x{
    <div>
      {articles.map(article => (
        <ArticleCard
          key={article.id}
          article={article}
          onDelete={handleDelete}
        />
      ))}
    </div>
  }
end
```

### Turbo Stream Response

```ruby
handleUpdate = ->(article, form_data) {
  article_path(article).patch(article: form_data, format: :turbo_stream).then do |response|
    response.text.then { |html| Turbo.renderStreamMessage(html) }
  end
}
```

### Pagination with Query Params

```ruby
loadPage = ->(page) {
  articles_path.get(page: page, per_page: 20, format: :json).then do |response|
    response.json.then { |data| setArticles(data) }
  end
}
```

## Backward Compatibility

The `toString()` and `valueOf()` methods ensure existing code continues to work:

```ruby
# These still work (string coercion)
%x{ <a href={articles_path}>All Articles</a> }
navigate(article_path(article))

# New callable API
articles_path.get(format: :json)
```

## Testing Plan

1. Unit tests for `path_helper.mjs` - URL building, headers, CSRF
2. Integration test with workflow demo - convert model calls to controller calls
3. Verify backward compatibility - existing path helper uses unchanged
4. Test all HTTP methods with format parameter
5. Test Turbo Stream consumption

## Future Considerations

- **Error handling**: Standardized error response parsing
- **Retry logic**: Automatic retry on network failures
- **Caching**: Optional response caching for GET requests
- **TypeScript types**: Type definitions for path helpers
