<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Ruby2JS Editor</title>
  <script src="coi-serviceworker.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/monaco-editor@0.52.2/min/vs/editor/editor.main.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@xterm/xterm@5.5.0/css/xterm.min.css">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { height: 100%; font-family: system-ui, sans-serif; background: #1e1e1e; color: #ccc; }
    #app { display: grid; grid-template-columns: 220px 1fr 1fr; grid-template-rows: 1fr 220px; height: 100vh; }
    #file-tree { grid-row: 1 / 2; overflow-y: auto; background: #252526; border-right: 1px solid #333; padding: 8px 0; font-size: 13px; }
    #editor-container { grid-row: 1 / 2; min-width: 0; }
    #preview-pane { grid-row: 1 / 2; border-left: 1px solid #333; display: flex; flex-direction: column; }
    #preview-pane iframe { flex: 1; border: none; background: #fff; }
    #preview-header { padding: 4px 8px; background: #252526; border-bottom: 1px solid #333; font-size: 12px; color: #999; }
    #terminal-pane { grid-column: 1 / -1; grid-row: 2 / 3; border-top: 1px solid #333; display: flex; flex-direction: column; }
    #terminal-header { padding: 4px 8px; background: #252526; border-bottom: 1px solid #333; font-size: 12px; color: #999; }
    #terminal { flex: 1; }

    .tree-item { padding: 2px 8px 2px 0; cursor: pointer; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .tree-item:hover { background: #2a2d2e; }
    .tree-item.active { background: #37373d; color: #fff; }
    .tree-item.dir { color: #999; }
    .tree-item.file { color: #ccc; }
    .tree-dir-children { display: none; }
    .tree-dir-children.open { display: block; }

    #loading-overlay { position: fixed; inset: 0; background: #1e1e1e; display: flex; align-items: center; justify-content: center; z-index: 1000; flex-direction: column; gap: 16px; }
    #loading-overlay .spinner { width: 40px; height: 40px; border: 3px solid #333; border-top-color: #569cd6; border-radius: 50%; animation: spin 0.8s linear infinite; }
    @keyframes spin { to { transform: rotate(360deg); } }
    #loading-overlay .status { font-size: 14px; color: #999; }
  </style>
</head>
<body>
  <div id="loading-overlay">
    <div class="spinner"></div>
    <div class="status" id="loading-status">Initializing...</div>
  </div>
  <div id="app">
    <div id="file-tree"></div>
    <div id="editor-container"></div>
    <div id="preview-pane">
      <div id="preview-header">Preview</div>
      <iframe id="preview-iframe" sandbox="allow-scripts allow-same-origin allow-forms allow-popups"></iframe>
    </div>
    <div id="terminal-pane">
      <div id="terminal-header">Terminal</div>
      <div id="terminal"></div>
    </div>
  </div>

  <script type="module">
    import { Terminal } from 'https://cdn.jsdelivr.net/npm/@xterm/xterm@5.5.0/+esm';
    import { FitAddon } from 'https://cdn.jsdelivr.net/npm/@xterm/addon-fit@0.10.0/+esm';

    // Determine demo from URL params
    const params = new URLSearchParams(location.search);
    const demo = params.get('demo') || 'blog';
    document.title = `Ruby2JS Editor — ${demo}`;

    // Editable file extensions
    const EDITABLE_EXT = /\.(rb|erb|html|css|js|json|yml|yaml|rake|ru|gemfile)$/i;
    const EDITABLE_DIRS = ['app/', 'config/', 'db/', 'test/', 'Gemfile', 'Rakefile'];

    function shouldShow(path) {
      if (path.startsWith('node_modules/') || path.startsWith('.git/') ||
          path.startsWith('dist/') || path.startsWith('tmp/') ||
          path.startsWith('log/') || path.startsWith('storage/')) return false;
      for (const d of EDITABLE_DIRS) {
        if (path.startsWith(d) || path === d.replace(/\/$/, '')) return true;
      }
      if (!path.includes('/') && EDITABLE_EXT.test(path)) return true;
      return false;
    }

    // Build file tree UI
    function buildFileTreeUI(files, containerEl, onFileClick) {
      const paths = Object.keys(files).filter(shouldShow).sort();
      const dirTree = {};

      for (const p of paths) {
        const parts = p.split('/');
        let node = dirTree;
        for (let i = 0; i < parts.length; i++) {
          const key = parts[i];
          if (i === parts.length - 1) {
            node[key] = p;
          } else {
            if (!node[key] || typeof node[key] === 'string') node[key] = {};
            node = node[key];
          }
        }
      }

      function renderTree(obj, parent, depth) {
        const entries = Object.entries(obj).sort(([a, va], [b, vb]) => {
          const aDir = typeof va === 'object';
          const bDir = typeof vb === 'object';
          if (aDir !== bDir) return aDir ? -1 : 1;
          return a.localeCompare(b);
        });

        for (const [name, value] of entries) {
          if (typeof value === 'object') {
            const dirEl = document.createElement('div');
            dirEl.className = 'tree-item dir';
            dirEl.style.paddingLeft = (depth * 12 + 8) + 'px';
            dirEl.textContent = '\u25B8 ' + name;
            parent.appendChild(dirEl);

            const children = document.createElement('div');
            children.className = 'tree-dir-children';
            parent.appendChild(children);

            dirEl.addEventListener('click', () => {
              const open = children.classList.toggle('open');
              dirEl.textContent = (open ? '\u25BE ' : '\u25B8 ') + name;
            });

            renderTree(value, children, depth + 1);
          } else {
            const fileEl = document.createElement('div');
            fileEl.className = 'tree-item file';
            fileEl.style.paddingLeft = (depth * 12 + 8) + 'px';
            fileEl.textContent = name;
            fileEl.dataset.path = value;
            fileEl.addEventListener('click', () => onFileClick(value, fileEl));
            parent.appendChild(fileEl);
          }
        }
      }

      renderTree(dirTree, containerEl, 0);
    }

    // Language detection for Monaco
    function langForPath(path) {
      if (path.endsWith('.rb')) return 'ruby';
      if (path.endsWith('.erb')) return 'html';
      if (path.endsWith('.js')) return 'javascript';
      if (path.endsWith('.json')) return 'json';
      if (path.endsWith('.css')) return 'css';
      if (path.endsWith('.html')) return 'html';
      if (path.endsWith('.yml') || path.endsWith('.yaml')) return 'yaml';
      return 'plaintext';
    }

    // Main boot sequence
    async function boot() {
      const status = document.getElementById('loading-status');

      // Step 1: Fetch snapshot (JSON mount tree built by editor/snapshot.mjs)
      status.textContent = `Fetching ${demo} snapshot...`;

      const basePath = document.baseURI.includes('/editor/')
        ? document.baseURI.replace(/\/editor\/.*$/, '')
        : '/ruby2js';
      const snapshotUrl = `${basePath}/editor/snapshots/${demo}.json`;
      let mountTree;
      try {
        const response = await fetch(snapshotUrl);
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        mountTree = await response.json();
      } catch (err) {
        status.textContent = `Failed to load snapshot: ${err.message}`;
        return;
      }

      // Step 3: Boot WebContainer
      status.textContent = 'Booting WebContainer...';

      const { WebContainer } = await import('https://unpkg.com/@webcontainer/api@1.5.1/dist/index.js');
      let container;
      try {
        container = await WebContainer.boot();
      } catch (err) {
        if (!window.crossOriginIsolated) {
          status.textContent = 'Enabling Cross-Origin Isolation (reloading)...';
          setTimeout(() => location.reload(), 1500);
        } else {
          status.textContent = `WebContainer boot failed: ${err.message}`;
        }
        return;
      }

      // Step 3: Mount files — decode base64 binary files to Uint8Array
      status.textContent = 'Mounting file system...';
      function decodeBinaries(node) {
        for (const [key, value] of Object.entries(node)) {
          if (value.directory) {
            decodeBinaries(value.directory);
          } else if (value.file && value.file.binary) {
            const b64 = value.file.contents;
            const bin = Uint8Array.from(atob(b64), c => c.charCodeAt(0));
            value.file.contents = bin;
            delete value.file.binary;
          }
        }
      }
      decodeBinaries(mountTree);
      await container.mount(mountTree);

      // Step 5: Load Monaco
      status.textContent = 'Loading editor...';

      await new Promise((resolve) => {
        const script = document.createElement('script');
        script.src = 'https://cdn.jsdelivr.net/npm/monaco-editor@0.52.2/min/vs/loader.js';
        script.onload = () => {
          require.config({ paths: { vs: 'https://cdn.jsdelivr.net/npm/monaco-editor@0.52.2/min/vs' } });
          require(['vs/editor/editor.main'], resolve);
        };
        document.head.appendChild(script);
      });

      const editor = monaco.editor.create(document.getElementById('editor-container'), {
        value: '// Select a file from the tree on the left',
        language: 'plaintext',
        theme: 'vs-dark',
        minimap: { enabled: false },
        fontSize: 13,
        automaticLayout: true,
      });

      // Extract flat file map from mount tree for editor and file tree
      const textCache = {};
      function extractFiles(node, prefix) {
        for (const [name, entry] of Object.entries(node)) {
          const path = prefix ? `${prefix}/${name}` : name;
          if (entry.directory) {
            extractFiles(entry.directory, path);
          } else if (entry.file) {
            const c = entry.file.contents;
            if (typeof c === 'string') {
              textCache[path] = c;
            }
            // skip binary (base64) files for editing
          }
        }
      }
      extractFiles(mountTree, '');

      let currentPath = null;
      let activeTreeItem = null;
      let writeTimeout = null;

      function openFile(path, treeEl) {
        if (activeTreeItem) activeTreeItem.classList.remove('active');
        if (treeEl) { treeEl.classList.add('active'); activeTreeItem = treeEl; }
        currentPath = path;
        const text = textCache[path] || '';
        const model = monaco.editor.createModel(text, langForPath(path));
        editor.setModel(model);
      }

      // Debounced write-back
      editor.onDidChangeModelContent(() => {
        if (!currentPath) return;
        const value = editor.getValue();
        textCache[currentPath] = value;
        clearTimeout(writeTimeout);
        writeTimeout = setTimeout(() => {
          container.fs.writeFile(currentPath, value);
        }, 300);
      });

      // Build tree UI
      const treeEl = document.getElementById('file-tree');
      buildFileTreeUI(textCache, treeEl, openFile);

      // Auto-expand app/ and open default file
      const appDir = treeEl.querySelector('.tree-item.dir');
      if (appDir) appDir.click();

      const defaultFile = 'app/models/article.rb';
      if (textCache[defaultFile]) {
        const fileEl = treeEl.querySelector(`[data-path="${defaultFile}"]`);
        if (fileEl) {
          let parent = fileEl.parentElement;
          while (parent && parent !== treeEl) {
            if (parent.classList.contains('tree-dir-children')) {
              parent.classList.add('open');
              const dirItem = parent.previousElementSibling;
              if (dirItem) dirItem.textContent = dirItem.textContent.replace('\u25B8', '\u25BE');
            }
            parent = parent.parentElement;
          }
          openFile(defaultFile, fileEl);
        }
      }

      // Step 6: Set up xterm.js terminal
      const xterm = new Terminal({
        theme: {
          background: '#1a1a1a',
          foreground: '#cccccc',
          cursor: '#ffffff',
        },
        fontSize: 13,
        fontFamily: "'Cascadia Code', 'Fira Code', 'Menlo', monospace",
        cursorBlink: true,
      });
      const fitAddon = new FitAddon();
      xterm.loadAddon(fitAddon);
      xterm.open(document.getElementById('terminal'));
      fitAddon.fit();

      // Refit on resize
      new ResizeObserver(() => fitAddon.fit()).observe(document.getElementById('terminal'));

      // Hide overlay — editor and terminal are ready
      document.getElementById('loading-overlay').style.display = 'none';

      // Listen for server-ready to connect preview iframe
      container.on('server-ready', (port, url) => {
        xterm.writeln(`\r\n\x1b[32mServer ready on port ${port}: ${url}\x1b[0m`);
        document.getElementById('preview-header').textContent = `Preview — ${url}`;
        document.getElementById('preview-iframe').src = url;
      });

      // Spawn interactive shell
      const shell = await container.spawn('jsh', {
        terminal: { cols: xterm.cols, rows: xterm.rows },
        env: { JUNTOS_DATABASE: 'dexie' },
      });

      // Pipe shell output to xterm
      shell.output.pipeTo(new WritableStream({
        write(data) { xterm.write(data); }
      }));

      // Pipe xterm input to shell
      const shellInput = shell.input.getWriter();
      xterm.onData(data => shellInput.write(data));

      // Resize shell when terminal resizes
      xterm.onResize(({ cols, rows }) => {
        shell.resize({ cols, rows });
      });

      // Log exit
      shell.exit.then(code => {
        xterm.writeln(`\r\n\x1b[33mShell exited (code ${code}). Refresh to restart.\x1b[0m`);
      });
    }

    boot().catch(err => {
      document.getElementById('loading-status').textContent = `Fatal: ${err.message}`;
      console.error(err);
    });
  </script>
</body>
</html>
