#!/usr/bin/env node
// Ink Console - Interactive database console for Juntos projects
//
// Usage:
//   bin/console                    # Default: development environment
//   bin/console -e production      # Use production environment
//   bin/console -d pg              # Override database adapter
//   bin/console -v                 # Verbose output

import { render, Box, Text, useInput, useApp } from 'ink';
import TextInput from 'ink-text-input';
import Spinner from 'ink-spinner';
import React, { useState, useEffect } from 'react';
import { parseArgs } from 'util';
import { readFileSync, existsSync } from 'fs';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';
import yaml from 'yaml';

// Query evaluator (uses Knex for database access)
import { initKnex, initQueryEvaluator, evaluateQuery, formatResult, getTables, getTableColumns, getSchema } from '../lib/query_evaluator.mjs';

const __dirname = dirname(fileURLToPath(import.meta.url));
const PROJECT_ROOT = join(__dirname, '..');

// Parse command-line arguments
const { values: args } = parseArgs({
  options: {
    database: { type: 'string', short: 'd' },
    environment: { type: 'string', short: 'e', default: 'development' },
    verbose: { type: 'boolean', short: 'v', default: false },
    help: { type: 'boolean', short: 'h', default: false }
  },
  strict: false
});

if (args.help) {
  console.log(`
Ink Console - Interactive database console for Juntos projects

Usage:
  bin/console [options]

Options:
  -d, --database ADAPTER   Database adapter (overrides database.yml)
  -e, --environment ENV    Rails environment (default: development)
  -v, --verbose            Show detailed output
  -h, --help               Show this help

Examples:
  bin/console                    # Use development environment
  bin/console -e production      # Use production environment
  bin/console -d pg              # Use PostgreSQL adapter
`);
  process.exit(0);
}

// Load database configuration
function loadDatabaseConfig() {
  const env = args.environment || process.env.RAILS_ENV || process.env.NODE_ENV || 'development';

  if (args.database) {
    return { adapter: args.database, _source: 'command line' };
  }

  const configPath = join(PROJECT_ROOT, 'config/database.yml');
  if (existsSync(configPath)) {
    try {
      const config = yaml.parse(readFileSync(configPath, 'utf8'));
      if (config && config[env]) {
        return { ...config[env], _source: `database.yml [${env}]` };
      }
    } catch (e) {
      console.error(`Error reading database.yml: ${e.message}`);
    }
  }

  return { adapter: 'sqlite', database: 'db/development.sqlite3', _source: 'default' };
}

// React.createElement shorthand
const e = React.createElement;

// Result display component
function ResultDisplay({ result, type }) {
  if (!result) return null;

  if (type === 'table' && Array.isArray(result)) {
    if (result.length === 0) {
      return e(Box, { marginY: 1 },
        e(Text, { dimColor: true }, 'No records found')
      );
    }

    const columns = Object.keys(result[0]);
    const colWidths = columns.map(col => {
      const maxDataWidth = Math.max(...result.map(r => String(r[col] ?? '').length));
      return Math.min(Math.max(col.length, maxDataWidth) + 2, 25);
    });

    return e(Box, { flexDirection: 'column', marginY: 1 },
      // Header
      e(Box, null,
        ...columns.map((col, i) =>
          e(Box, { key: col, width: colWidths[i] },
            e(Text, { bold: true }, col)
          )
        )
      ),
      // Separator
      e(Box, null,
        e(Text, { dimColor: true }, columns.map((_, i) => '─'.repeat(colWidths[i] - 1)).join(' '))
      ),
      // Rows
      ...result.map((row, rowIdx) =>
        e(Box, { key: rowIdx },
          ...columns.map((col, i) =>
            e(Box, { key: col, width: colWidths[i] },
              e(Text, null, String(row[col] ?? 'null').slice(0, colWidths[i] - 2))
            )
          )
        )
      ),
      // Count
      e(Box, { marginTop: 1 },
        e(Text, { dimColor: true }, `${result.length} record(s)`)
      )
    );
  }

  if (type === 'record') {
    const entries = Object.entries(result);
    return e(Box, { flexDirection: 'column', marginY: 1 },
      ...entries.map(([key, value]) =>
        e(Box, { key },
          e(Text, { bold: true }, `${key}: `),
          e(Text, null, String(value ?? 'null'))
        )
      )
    );
  }

  // Handle string values (like schema output) - display as-is
  if (typeof result === 'string') {
    return e(Box, { marginY: 1 },
      e(Text, null, result)
    );
  }

  // Default: show as JSON
  return e(Box, { marginY: 1 },
    e(Text, null, JSON.stringify(result, null, 2))
  );
}

// Main Console component
function Console({ dbConfig, verbose }) {
  const { exit } = useApp();
  const [query, setQuery] = useState('');
  const [history, setHistory] = useState([]);
  const [historyIndex, setHistoryIndex] = useState(-1);
  const [error, setError] = useState(null);
  const [loading, setLoading] = useState(true);
  const [executing, setExecuting] = useState(false);

  useEffect(() => {
    async function init() {
      try {
        await initKnex({ database: dbConfig.database || 'db/development.sqlite3' });
        await initQueryEvaluator();
        setLoading(false);
      } catch (err) {
        setError(err.message);
        setLoading(false);
      }
    }
    init();
  }, []);

  // Handle up/down for history navigation
  useInput((input, key) => {
    if (key.upArrow && history.length > 0) {
      const newIndex = historyIndex < history.length - 1 ? historyIndex + 1 : historyIndex;
      setHistoryIndex(newIndex);
      setQuery(history[history.length - 1 - newIndex]?.query || '');
    }
    if (key.downArrow) {
      const newIndex = historyIndex > 0 ? historyIndex - 1 : -1;
      setHistoryIndex(newIndex);
      setQuery(newIndex >= 0 ? history[history.length - 1 - newIndex]?.query || '' : '');
    }
    if (key.ctrl && input === 'c') {
      exit();
    }
  });

  const handleSubmit = async (value) => {
    if (!value.trim()) return;

    const trimmed = value.trim().toLowerCase();
    if (trimmed === 'exit' || trimmed === 'quit') {
      exit();
      return;
    }

    if (trimmed === 'clear') {
      setHistory([]);
      setQuery('');
      setError(null);
      return;
    }

    if (trimmed === 'help') {
      setHistory(prev => [...prev, {
        query: value,
        result: `Query Commands:
  Post.all              - Get all records
  Post.find(1)          - Find by ID
  Post.where(...)       - Filter records
  Post.first / Post.last
  Post.order(:column)
  Post.limit(n)
  Post.count

Schema Commands:
  tables                - List all tables
  schema                - Show all table schemas
  schema posts          - Show columns for 'posts' table

Other:
  exit, clear, help`,
        type: 'value'
      }]);
      setQuery('');
      return;
    }

    setExecuting(true);
    setError(null);

    try {
      const result = await evaluateQuery(value);
      const formatted = formatResult(result);

      // Handle 'tables' command
      if (formatted.type === 'command' && formatted.data === 'tables') {
        const tables = await getTables();
        setHistory(prev => [...prev, {
          query: value,
          result: tables.length > 0 ? tables.join(', ') : 'No tables found',
          type: 'value'
        }]);
        setQuery('');
        setExecuting(false);
        return;
      }

      // Handle 'schema' command (all tables)
      if (formatted.type === 'command' && formatted.data === 'schema') {
        const schema = await getSchema();
        const schemaText = Object.entries(schema).map(([table, columns]) => {
          const colDefs = columns.map(col => {
            let def = `  ${col.name}: ${col.type}`;
            if (col.primaryKey) def += ' [PK]';
            if (!col.nullable) def += ' NOT NULL';
            if (col.default !== null) def += ` DEFAULT ${col.default}`;
            return def;
          }).join('\n');
          return `${table}:\n${colDefs}`;
        }).join('\n\n');
        setHistory(prev => [...prev, {
          query: value,
          result: schemaText || 'No tables found',
          type: 'value'
        }]);
        setQuery('');
        setExecuting(false);
        return;
      }

      // Handle 'schema tablename' command
      if (formatted.type === 'command' && formatted.data === 'schema_table') {
        const columns = await getTableColumns(formatted.table);
        if (columns.length === 0) {
          setHistory(prev => [...prev, {
            query: value,
            error: `Table '${formatted.table}' not found`
          }]);
        } else {
          setHistory(prev => [...prev, {
            query: value,
            result: columns,
            type: 'table'
          }]);
        }
        setQuery('');
        setExecuting(false);
        return;
      }

      if (formatted.type === 'command') {
        if (formatted.data === 'exit') exit();
        if (formatted.data === 'clear') {
          setHistory([]);
          setQuery('');
        }
      } else {
        setHistory(prev => [...prev, {
          query: value,
          result: formatted.data,
          type: formatted.type,
          count: formatted.count
        }]);
      }
    } catch (err) {
      setHistory(prev => [...prev, {
        query: value,
        error: err.message
      }]);
    }

    setQuery('');
    setHistoryIndex(-1);
    setExecuting(false);
  };

  if (loading) {
    return e(Box, { flexDirection: 'column', padding: 1 },
      e(Box, null,
        e(Spinner, { type: 'dots' }),
        e(Text, { color: 'yellow' }, ' Initializing Ruby2JS...')
      )
    );
  }

  const children = [
    // Header
    e(Box, { key: 'header', marginBottom: 1 },
      e(Text, { bold: true, color: 'green' }, 'ink-console'),
      e(Text, { dimColor: true }, ` (${dbConfig.adapter} via ${dbConfig._source})`)
    )
  ];

  // Verbose output
  if (verbose) {
    children.push(
      e(Box, { key: 'verbose', marginBottom: 1 },
        e(Text, { dimColor: true }, `Database: ${JSON.stringify(dbConfig)}`)
      )
    );
  }

  // Error display
  if (error) {
    children.push(
      e(Box, { key: 'error', marginBottom: 1, borderStyle: 'round', borderColor: 'red', paddingX: 1 },
        e(Text, { color: 'red' }, `Error: ${error}`)
      )
    );
  }

  // History
  history.forEach((entry, i) => {
    children.push(
      e(Box, { key: `history-${i}`, flexDirection: 'column', marginBottom: 1 },
        e(Text, { color: 'cyan' }, `> ${entry.query}`),
        entry.error
          ? e(Text, { color: 'red' }, `Error: ${entry.error}`)
          : e(ResultDisplay, { result: entry.result, type: entry.type })
      )
    );
  });

  // Input prompt
  children.push(
    e(Box, { key: 'prompt' },
      executing
        ? e(Box, null,
            e(Spinner, { type: 'dots' }),
            e(Text, { color: 'yellow' }, ' Executing...')
          )
        : e(Box, null,
            e(Text, { color: 'green' }, '> '),
            e(TextInput, {
              value: query,
              onChange: setQuery,
              onSubmit: handleSubmit,
              placeholder: "Post.all, Post.find(1), or 'help'"
            })
          )
    )
  );

  // Help text
  children.push(
    e(Box, { key: 'help', marginTop: 1 },
      e(Text, { dimColor: true }, "↑/↓ history • 'help' for commands • 'exit' to quit • Ctrl+C force quit")
    )
  );

  return e(Box, { flexDirection: 'column', padding: 1 }, ...children);
}

// Main
const dbConfig = loadDatabaseConfig();

if (args.verbose) {
  console.log(`Database: ${dbConfig.adapter} (${dbConfig._source})`);
}

render(e(Console, { dbConfig, verbose: args.verbose }));
