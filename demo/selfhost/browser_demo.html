<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Ruby2JS Self-Hosted Demo</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      max-width: 900px;
      margin: 0 auto;
      padding: 20px;
      background: #f5f5f5;
    }
    h1 { color: #333; }
    .container {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
    }
    .panel {
      background: white;
      border-radius: 8px;
      padding: 15px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .panel h2 {
      margin-top: 0;
      font-size: 16px;
      color: #666;
    }
    textarea {
      width: 100%;
      height: 200px;
      font-family: 'Monaco', 'Menlo', monospace;
      font-size: 14px;
      border: 1px solid #ddd;
      border-radius: 4px;
      padding: 10px;
      box-sizing: border-box;
      resize: vertical;
    }
    #output {
      background: #1e1e1e;
      color: #d4d4d4;
    }
    button {
      background: #c41e3a;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      margin-top: 10px;
    }
    button:hover {
      background: #a01830;
    }
    button:disabled {
      background: #ccc;
      cursor: not-allowed;
    }
    #status {
      margin-top: 10px;
      padding: 10px;
      border-radius: 4px;
      font-size: 14px;
    }
    .loading { background: #fff3cd; color: #856404; }
    .success { background: #d4edda; color: #155724; }
    .error { background: #f8d7da; color: #721c24; }
    .info {
      margin-top: 20px;
      padding: 15px;
      background: white;
      border-radius: 8px;
      font-size: 14px;
      color: #666;
    }
    .info code {
      background: #f5f5f5;
      padding: 2px 6px;
      border-radius: 3px;
    }
  </style>
</head>
<body>
  <h1>Ruby2JS Self-Hosted Demo</h1>
  <p>This demo runs Ruby2JS entirely in the browser using:</p>
  <ul>
    <li><strong>@ruby/prism</strong> - Ruby parser compiled to WebAssembly (~2.7MB)</li>
    <li><strong>Transpiled PrismWalker</strong> - AST translation (from Ruby via selfhost filter)</li>
    <li><strong>Minimal Converter</strong> - AST to JavaScript conversion</li>
  </ul>

  <div class="container">
    <div class="panel">
      <h2>Ruby Input</h2>
      <textarea id="input" placeholder="Enter Ruby code...">puts "Hello, World!"

x = 42
y = [1, 2, 3]

def greet(name)
  puts name
end</textarea>
    </div>
    <div class="panel">
      <h2>JavaScript Output</h2>
      <textarea id="output" readonly placeholder="JavaScript will appear here..."></textarea>
    </div>
  </div>

  <button id="convert" disabled>Loading Prism...</button>
  <div id="status" class="loading">Loading @ruby/prism WebAssembly module...</div>

  <div class="info">
    <strong>Note:</strong> This is a proof-of-concept demonstrating self-hosting.
    The converter handles basic patterns: literals, variables, arrays, hashes,
    method calls (<code>puts</code> → <code>console.log</code>), and simple method definitions.
    <br><br>
    <strong>Bundle size:</strong> ~2.7MB (vs 24MB with Opal)
  </div>

  <script type="module">
    import { loadPrism } from "https://esm.sh/@ruby/prism@1.4.0";

    // Inline the transpiled walker and converter
    // (In production, this would be bundled separately)

    class Node {
      constructor(type, children, options = {}) {
        this.type = type;
        this.children = children;
        this.location = options.location;
      }
    }

    function s(type, ...children) {
      return new Node(type, children);
    }

    // Minimal PrismWalker (transpiled from Ruby)
    class PrismWalker {
      visit(node) {
        if (!node) return null;
        let method = this[`visit${node.constructor.name}`];
        return method ? method.call(this, node) : null;
      }

      constructor(source, file = null) {
        this._source = source;
        this._file = file;
      }

      s(type, ...children) {
        return new Node(type, children);
      }

      visit_all(nodes) {
        if (nodes == null) return [];
        return nodes.map(n => this.visit(n)).filter(x => x != null);
      }

      // Literals
      visitIntegerNode(node) { return this.s("int", node.value); }
      visitFloatNode(node) { return this.s("float", node.value); }
      visitNilNode(node) { return this.s("nil"); }
      visitTrueNode(node) { return this.s("true"); }
      visitFalseNode(node) { return this.s("false"); }
      visitStringNode(node) { return this.s("str", node.unescaped.value); }
      visitSymbolNode(node) { return this.s("sym", node.unescaped.value); }
      visitSelfNode(node) { return this.s("self"); }

      // Variables
      visitLocalVariableReadNode(node) { return this.s("lvar", node.name); }
      visitLocalVariableWriteNode(node) { return this.s("lvasgn", node.name, this.visit(node.value)); }
      visitInstanceVariableReadNode(node) { return this.s("ivar", node.name); }
      visitInstanceVariableWriteNode(node) { return this.s("ivasgn", node.name, this.visit(node.value)); }

      // Collections
      visitArrayNode(node) { return this.s("array", ...this.visit_all(node.elements)); }
      visitHashNode(node) { return this.s("hash", ...this.visit_all(node.elements)); }
      visitAssocNode(node) { return this.s("pair", this.visit(node.key), this.visit(node.value)); }

      // Calls
      visitCallNode(node) {
        let receiver = this.visit(node.receiver);
        let args = node.arguments_ ? this.visit_all(node.arguments_.arguments_) : [];
        return this.s("send", receiver, node.name, ...args);
      }

      // Definitions
      visitDefNode(node) {
        let args = this.visit(node.parameters) || this.s("args");
        let body = this.visit(node.body);
        return this.s("def", node.name, args, body);
      }

      visitParametersNode(node) {
        let params = [];
        for (let p of node.requireds) params.push(this.visit(p));
        for (let p of node.optionals) params.push(this.visit(p));
        if (node.rest) params.push(this.visit(node.rest));
        return this.s("args", ...params);
      }

      visitRequiredParameterNode(node) { return this.s("arg", node.name); }
      visitOptionalParameterNode(node) { return this.s("optarg", node.name, this.visit(node.value)); }
      visitRestParameterNode(node) { return this.s("restarg", node.name); }

      // Control Flow
      visitIfNode(node) {
        return this.s("if", this.visit(node.predicate), this.visit(node.statements), this.visit(node.subsequent));
      }

      visitStatementsNode(node) {
        let children = this.visit_all(node.body);
        return children.length == 1 ? children[0] : this.s("begin", ...children);
      }

      visitProgramNode(node) {
        return this.visit(node.statements);
      }
    }

    // Minimal Converter
    class Converter {
      constructor() {
        this._handlers = {
          'int': node => node.children[0].toString(),
          'float': node => node.children[0].toString(),
          'str': node => JSON.stringify(node.children[0]),
          'sym': node => JSON.stringify(node.children[0]),
          'nil': () => 'null',
          'true': () => 'true',
          'false': () => 'false',
          'self': () => 'this',
          'lvar': node => node.children[0].toString(),
          'ivar': node => 'this._' + node.children[0].toString().replace(/^@/, ''),
          'lvasgn': node => 'let ' + node.children[0].toString() + ' = ' + this.convert(node.children[1]),
          'ivasgn': node => 'this._' + node.children[0].toString().replace(/^@/, '') + ' = ' + this.convert(node.children[1]),
          'array': node => '[' + node.children.map(c => this.convert(c)).join(', ') + ']',
          'hash': node => '{' + node.children.map(c => this.convert(c)).join(', ') + '}',
          'pair': node => this.convert(node.children[0]) + ': ' + this.convert(node.children[1]),
          'send': node => this.convertSend(node),
          'def': node => this.convertDef(node),
          'begin': node => node.children.map(c => this.convert(c)).join(';\n'),
          'if': node => this.convertIf(node),
          'args': node => node.children.map(c => this.convert(c)).join(', '),
          'arg': node => node.children[0].toString(),
          'optarg': node => node.children[0].toString() + '=' + this.convert(node.children[1]),
          'restarg': node => '...' + node.children[0].toString()
        };
      }

      convert(node) {
        if (node == null) return 'null';
        const handler = this._handlers[node.type];
        if (handler) return handler(node);
        return '/* unknown: ' + node.type + ' */';
      }

      convertSend(node) {
        const [receiver, methodName, ...args] = node.children;
        const argsStr = args.map(a => this.convert(a)).join(', ');
        if (receiver == null && methodName === 'puts') {
          return 'console.log(' + argsStr + ')';
        }
        if (receiver == null) {
          return methodName.toString() + '(' + argsStr + ')';
        } else {
          return this.convert(receiver) + '.' + methodName.toString() + '(' + argsStr + ')';
        }
      }

      convertDef(node) {
        const [name, args, body] = node.children;
        const argsStr = this.convert(args);
        const bodyStr = body ? this.convert(body) : '';
        return 'function ' + name.toString() + '(' + argsStr + ') {\n  return ' + bodyStr + ';\n}';
      }

      convertIf(node) {
        const [cond, thenBody, elseBody] = node.children;
        let result = 'if (' + this.convert(cond) + ') {\n  ' + (thenBody ? this.convert(thenBody) : '') + '\n}';
        if (elseBody) {
          result += ' else {\n  ' + this.convert(elseBody) + '\n}';
        }
        return result;
      }
    }

    // Initialize
    const input = document.getElementById('input');
    const output = document.getElementById('output');
    const button = document.getElementById('convert');
    const status = document.getElementById('status');

    let parse;

    async function init() {
      try {
        parse = await loadPrism();
        button.disabled = false;
        button.textContent = 'Convert →';
        status.className = 'success';
        status.textContent = 'Ready! @ruby/prism loaded successfully.';
      } catch (e) {
        status.className = 'error';
        status.textContent = 'Error loading Prism: ' + e.message;
      }
    }

    function convert() {
      try {
        const rubyCode = input.value;
        const result = parse(rubyCode);

        if (result.errors.length > 0) {
          output.value = 'Parse errors:\n' + result.errors.map(e => e.message).join('\n');
          status.className = 'error';
          status.textContent = 'Parse error';
          return;
        }

        const walker = new PrismWalker(rubyCode);
        const ast = walker.visit(result.value);
        const converter = new Converter();
        const js = converter.convert(ast);

        output.value = js;
        status.className = 'success';
        status.textContent = 'Converted successfully!';
      } catch (e) {
        output.value = 'Error: ' + e.message;
        status.className = 'error';
        status.textContent = 'Conversion error: ' + e.message;
      }
    }

    button.addEventListener('click', convert);
    input.addEventListener('input', () => {
      status.className = '';
      status.textContent = 'Press "Convert" to see JavaScript output';
    });

    init();
  </script>
</body>
</html>
