// Transpiled spec file - auto-generated by Ruby2JS self-hosting
// Do not edit directly - regenerate from Ruby source

import { loadPrism } from "@ruby/prism";
import { PrismWalker } from "./transpiled_walker.mjs";
import { Converter } from "./selfhost_converter.mjs";
import { describe, it, printResults } from "./test_harness.mjs";

// Load Prism parser
const parse = await loadPrism();

// Self-hosted convert function (replaces Ruby2JS.convert)
function convert(rubyCode, opts = {}) {
  const result = parse(rubyCode);
  if (result.errors && result.errors.length > 0) {
    throw new Error("Parse error: " + result.errors[0].message);
  }
  const walker = new PrismWalker(rubyCode);
  const ast = walker.visit(result.value);
  const converter = new Converter(ast, new Map());
  // Default to ES5 (no let/const) to match Ruby transliteration_spec defaults
  converter.eslevel = opts.eslevel || 5;
  converter.convert();
  return converter.to_s();
}

// Ruby2JS namespace for compatibility
const Ruby2JS = { convert };

// Stub for Rational (used in ivars test)
function Rational(n, d) { return Math.floor(n / d); }

// RUBY_VERSION stub (used in conditional tests)
const RUBY_VERSION = "3.4.0";

// it "should eval" do
//   to_js('eval( "hi" )').must_equal 'eval("hi")'
// end
// support a JavaScript-like syntax too.
// This test passes a live Proc object which requires find_block to locate
// the block by line number. The prism walker uses offset-based locations
// and doesn't yet support line number lookups.
// This test passes a live Proc object which requires find_block to locate
// the block by line number. The prism walker uses offset-based locations
// and doesn't yet support line number lookups.
// not allowed by Ruby or JS, but useful for adding JS specific flags
describe(Ruby2JS, () => {
  function to_js(string, opts={}) {
    return Ruby2JS.convert(string, {...opts, filters: []}).toString()
  };

  describe("literals", () => {
    it("should parse literals and strings", () => {
      to_js("1").must_equal("1");
      to_js("'string'").must_equal("\"string\"");
      to_js(":symbol").must_equal("\"symbol\"");
      to_js("nil").must_equal("null");
      to_js("Constant").must_equal("Constant");
      let unicode = to_js("\"\\u2620\"");
      return unicode.must_equal("\"â˜ \"")
    });

    it("should parse simple hash", () => {
      to_js("{}").must_equal("{}");
      to_js("{ a: :b }").must_equal("{a: \"b\"}");
      return to_js("{ :a => :b, 'c' => :d }").must_equal("{a: \"b\", c: \"d\"}")
    });

    it("should handle hashes with keys that aren't identifiers", () => {
      to_js("{ 1 => 2 }").must_equal("{1: 2}");
      return to_js("{ 'data-foo' => 2 }").must_equal("{\"data-foo\": 2}")
    });

    it("should parse array", () => {
      to_js("[]").must_equal("[]");
      return to_js("[1, 2, 3]").must_equal("[1, 2, 3]")
    });

    it(
      "should parse nested hash",
      () => to_js("{ :a => {:b => :c} }").must_equal("{a: {b: \"c\"}}")
    );

    it(
      "should parse array",
      () => to_js("[1, [2, 3]]").must_equal("[1, [2, 3]]")
    );

    it(
      "should parse global variables",
      () => to_js("$a = 1").must_equal("var $a = 1")
    );

    return it(
      "should parse regular expression capture groups",
      () => to_js("$1 == 'a'").must_equal("RegExp.$1 == \"a\"")
    )
  });

  describe("assign", () => {
    it("should parse left assign", () => {
      to_js("a = 1").must_equal("var a = 1");
      to_js("a = 'string'").must_equal("var a = \"string\"");
      return to_js("a = :symbol").must_equal("var a = \"symbol\"")
    });

    it(
      "should parse constant assign",
      () => to_js("PI = 3.14159").must_equal("var PI = 3.14159")
    );

    it(
      "should not output var if variable is allready declared within a context",
      () => to_js("a = 1; a = 2").must_equal("var a = 1; a = 2")
    );

    it("should parse mass assign", () => {
      to_js("a, b = 1, 2").must_equal("var a = 1; var b = 2");
      to_js("a = 1, 2").must_equal("var a = [1, 2]");
      return to_js("a, b = c").must_equal("var a = c[0]; var b = c[1]")
    });

    it("should parse chained assignment statements", () => {
      to_js("a = b = 1").must_equal("var a, b; a = b = 1");
      to_js("x.a = b = 1").must_equal("var b; x.a = b = 1");
      to_js("@a = b = 1").must_equal("var b; this._a = b = 1");
      to_js("@@a = b = 1").must_equal("var b; this.constructor._a = b = 1");
      return to_js("A = b = 1").must_equal("var b; var A = b = 1")
    });

    it("should parse op assignments", () => {
      to_js("a += 1").must_equal("a++");
      to_js("@a += 1").must_equal("this._a++");
      return to_js("@@a += 1").must_equal("this.constructor._a++")
    });

    it("should parse unary operators", () => {
      to_js("+a").must_equal("+a");
      return to_js("-a").must_equal("-a")
    });

    it(
      "should parse exponential operators",
      () => to_js("2 ** 0.5").must_equal("Math.pow(2, 0.5)")
    );

    it("should do short circuit assign", () => {
      to_js("a = nil; a ||= 1").must_equal("var a = null; a = a || 1");
      to_js("@a ||= 1").must_equal("this._a = this._a || 1");
      to_js("@@a ||= 1").must_equal("this.constructor._a = this.constructor._a || 1");
      to_js("self.p ||= 1").must_equal("this.p = this.p || 1");
      return to_js("a[i] ||= 1").must_equal("a[i] = a[i] || 1")
    });

    return it("should parse ternary operator", () => {
      to_js("x = true ? true : false").must_equal("var x = true ? true : false");
      to_js("x = (true if y)").must_equal("var x = y ? true : null");
      to_js("x = (true unless y)").must_equal("var x = !y ? true : null");
      return to_js("x = a + (b ? 1 : 0)").must_equal("var x = a + (b ? 1 : 0)")
    })
  });

  describe("method call", () => {
    it(
      "should parse function call with no args",
      () => to_js("a()").must_equal("a()")
    );

    it(
      "should parse method call with no args",
      () => to_js("a.b()").must_equal("a.b()")
    );

    it(
      "should parse method call with args",
      () => to_js("a 1, 2, 3").must_equal("a(1, 2, 3)")
    );

    it(
      "should parse lvar as variable call",
      () => to_js("a = 1; a").must_equal("var a = 1; a")
    );

    it("should parse square bracket call", () => {
      to_js("a = [1]; a[0]").must_equal("var a = [1]; a[0]");
      to_js("a['x']").must_equal("a.x");
      return to_js("a[:x]").must_equal("a.x")
    });

    it("should parse square bracket assignment", () => {
      to_js("a = [1]; a[0]=2").must_equal("var a = [1]; a[0] = 2");
      to_js("a['x']=1").must_equal("a.x = 1");
      return to_js("a[:x]=1").must_equal("a.x = 1")
    });

    it(
      "should parse nested square bracket call",
      () => to_js("a = [[1]]; a[0][0]").must_equal("var a = [[1]]; a[0][0]")
    );

    it(
      "should parse binary operation",
      () => to_js("1 + 1").must_equal("1 + 1")
    );

    it(
      "should call method on literal",
      () => to_js("[0][0]").must_equal("[0][0]")
    );

    it("should nest arguments as needed", () => {
      let exp = "a((1 + 2) * 2)";
      return to_js(exp).must_equal(exp)
    });

    it("should chain method calls", () => {
      let exp = "a().one().two().three()";
      return to_js(exp).must_equal(exp)
    });

    it(
      "should drop ! and ? from method calls and property accesses",

      () => {
        to_js("a!()").must_equal("a()");
        to_js("a?()").must_equal("a()");
        to_js("a!").must_equal("var a");
        return to_js("a?").must_equal("var a")
      }
    );

    return it(
      "should wrap numeric literals in parenthesis",
      () => to_js("1000.toLocaleString()").must_equal("(1000).toLocaleString()")
    )
  });

  describe("splat", () => {
    it("should pass splat", () => (
      to_js("console.log 'a', 'b', *%w(c d e)").must_equal("console.log.apply(console, [\"a\", \"b\"].concat([\"c\", \"d\", \"e\"]))")
    ));

    it("should optimize splat as only arg", () => (
      to_js("console.log *%w(a b c d e)").must_equal("console.log.apply(console, [\"a\", \"b\", \"c\", \"d\", \"e\"])")
    ));

    it("should receive splat", () => (
      to_js("def f(a,*b); return b; end").must_equal("function f(a) {var b = Array.prototype.slice.call(arguments, 1); return b}")
    ));

    it("should receive unnamed splat", () => (
      to_js("def f(a,*); return a; end").must_equal("function f(a) {return a}")
    ));

    it("should receive splat and block", () => (
      to_js("def f(a,*args, &block); end").must_equal("function f(a) {var args = Array.prototype.slice.call(arguments, 2, arguments.length - 1); var block = arguments[arguments.length - 1]; if (arguments.length <= 1) {block = null} else if (typeof block !== \"function\") {args.push(block); block = null}}")
    ));

    return it("should handle splats in array literals", () => (
      to_js("[*a,1,2,*b,3,4,*c]").must_equal("a.concat([1, 2]).concat(b).concat([3, 4]).concat(c)")
    ))
  });

  describe("boolean", () => {
    it(
      "should parse boolean",
      () => to_js("true; false").must_equal("true; false")
    );

    it("should parse relation operators", () => {
      to_js("a < b").must_equal("a < b");
      to_js("a <= b").must_equal("a <= b");
      to_js("a == b").must_equal("a == b");
      to_js("a === b").must_equal("a === b");
      to_js("a >= b").must_equal("a >= b");
      to_js("a > b").must_equal("a > b");
      return to_js("a <=> b").must_equal("a < b ? -1 : a > b ? 1 : 0")
    });

    it("should parse logic operators", () => {
      to_js("true && false").must_equal("true && false");
      to_js("true and false").must_equal("true && false");
      to_js("true || false").must_equal("true || false");
      return to_js("true or false").must_equal("true || false")
    });

    it(
      "should respect parens",
      () => to_js("true && (true || false)").must_equal("true && (true || false)")
    );

    it("should parse not", () => to_js("not true").must_equal("!true"));

    it(
      "should parse nested logic",
      () => to_js("not (true or false)").must_equal("!(true || false)")
    );

    it("should parse more complex nested logic", () => {
      let logic = "!((true && false) || (false || false))";
      return to_js(logic).must_equal(logic)
    });

    return it("should parse another nested login example", () => {
      let logic = "!true && true";
      return to_js(logic).must_equal(logic)
    })
  });

  describe("expressions", () => {
    it("should handle simple chaining", () => {
      let exp = "1 + 1 + 1";
      return to_js(exp).must_equal(exp)
    });

    it("should respect parens", () => {
      let exp = "1 + (1 - 1)";
      return to_js(exp).must_equal(exp)
    });

    it("should not nest", () => {
      let exp = "1 + 1 * 1";
      return to_js(exp).must_equal(exp)
    });

    it("should parse nested expressions", () => {
      let exp = "(1 + 1) * 1";
      return to_js(exp).must_equal(exp)
    });

    it("should parse complex nested expressions", () => {
      let exp = "1 + (1 + (1 + 1 * (2 - 1)))";
      return to_js(exp).must_equal(exp)
    });

    it(
      "should parse complex nested expressions with method calls",

      () => {
        let exp = "1 + (a() + (1 + 1 * (b() - d())))";
        return to_js(exp).must_equal(exp)
      }
    );

    it(
      "should parse complex nested expressions with method calls and variables",

      () => {
        let exp = "a = 5; 1 + (a + (1 + a * (b() - d())))";
        return to_js(exp).must_equal("var ".push(exp))
      }
    );

    it("should parse nested sender", () => {
      let exp = "((1 / 2) * 4 - (1 + 1)) - 1";
      return to_js(exp).must_equal(exp)
    });

    it("nest expressions when needed in string interpolation", () => {
      to_js("\"\#{a}\#{b}\".length").must_equal("(a + b).length");
      to_js("\"\#{a}\#{b}\".split(\" \")").must_equal("(a + b).split(\" \")");
      return to_js("\"a\#{b+c}\"").must_equal("\"a\" + (b + c)")
    });

    it(
      "should concatenate strings",
      () => to_js("\"a\"+\"b\"").must_equal("\"ab\"")
    );

    it("should nest methods called on expressions", () => {
      let exp = "(a + b).length";
      to_js(exp).must_equal(exp);
      exp = "(a + b).split(\" \")";
      return to_js(exp).must_equal(exp)
    });

    it("should nest arguments as needed", () => {
      let exp = "a((1 + 2) * 2 - 1)";
      return to_js(exp).must_equal(exp)
    });

    return it("should handle function calls", () => (
      to_js("a = lambda {|x| return x+1}; a.(nil, 1)").must_equal("var a = function(x) {return x + 1}; a.call(null, 1)")
    ))
  });

  describe("string concat", () => {
    it("should parse string ", () => (
      to_js("\"time is \#{ Time.now() }, say \#{ hello }\"").must_equal("\"time is \" + Time.now() + \", say \" + hello")
    ));

    it("should parse string", () => (
      to_js("\"time is \#{ Time.now() }\"").must_equal("\"time is \" + Time.now()")
    ));

    return it(
      "should parse interpolated symbols",
      () => to_js(":\"a\#{b}c\"").must_equal("\"a\" + b + \"c\"")
    )
  });

  describe("wow, such empty", () => {
    it(
      "should handle totally empty interpolation",
      () => to_js("\"\#{}\"").must_equal("\"\"")
    );

    it(
      "should handle mixed empty interpolation",
      () => to_js("\"x\#{}y\"").must_equal("\"x\" + \"\" + \"y\"")
    );

    it(
      "should handle empty here docs",
      () => to_js("x = <<HERE\nHERE").must_equal("var x = \"\"\n")
    );

    return it(
      "should handle mixed empty parens",
      () => to_js("x = ()").must_equal("var x = null")
    )
  });

  describe("array push", () => {
    it(
      "should convert << statements to .push calls",
      () => to_js("a << b").must_equal("a.push(b)")
    );

    it(
      "should convert multiple << statements to a single .push call",
      () => to_js("a << b << c << d << e").must_equal("a.push(b, c, d, e)")
    );

    return it(
      "should leave << expressions alone",
      () => to_js("y = a << b").must_equal("var y = a << b")
    )
  });

  describe("control", () => {
    it(
      "should parse single line if",
      () => to_js("1 if true").must_equal("if (true) 1")
    );

    it("should parse single line unless", () => {
      to_js("1 unless false").must_equal("if (!false) 1");
      to_js("1 unless a").must_equal("if (!a) 1");
      to_js("1 unless a == b").must_equal("if (a != b) 1");
      to_js("1 unless a === b").must_equal("if (a !== b) 1");
      to_js("1 unless a or b").must_equal("if (!a && !b) 1");
      return to_js("1 unless a and b").must_equal("if (!a || !b) 1")
    });

    it(
      "should parse if else",
      () => to_js("if true; 1; else; 2; end").must_equal("if (true) {1} else {2}")
    );

    it("should parse if else unless", () => (
      to_js("if true; 1; else; 2 unless false; end").must_equal("if (true) {1} else if (!false) {2}")
    ));

    it("should parse if elsif", () => (
      to_js("if true; 1; elsif false; 2; else; 3; end").must_equal("if (true) {1} else if (false) {2} else {3}")
    ));

    it("should parse if elsif elsif", () => (
      to_js("if true; 1; elsif false; 2; elsif (true or false); 3; else; nassif(); end").must_equal("if (true) {1} else if (false) {2} else if (true || false) {3} else {nassif()}")
    ));

    it("should parse if as an expression", () => (
      to_js("x = if a; b = 1; b; elsif c; x=1; x; end").must_equal("var x = a ? function() {var b = 1; return b}() : c ? function() {var x = 1; return x}() : null")
    ));

    it("should handle basic variable scope", () => {
      to_js("z = 1; if a; b; elsif c; d = proc do e = 1; end; end; z = d").must_equal("var d; var z = 1; if (a) {var b} else if (c) {d = function() {var e = 1}}; z = d");
      return to_js("if a == 1; b = 0; c.forEach {|d| if d; b += d; end} end").must_equal("if (a == 1) {var b = 0; c.forEach(function(d) {if (d) b += d})}")
    });

    it("should handle while loop", () => (
      to_js("a = 0; while true; a += 1; end").must_equal("var a = 0; while (true) {a++}")
    ));

    it("should handle while loop that assigns a variable", () => (
      to_js("while match=f(); end").must_equal("var match; while (match = f()) {}")
    ));

    it("should handle another while loop syntax", () => (
      to_js("a = 0; while true || false; a += 1; end").must_equal("var a = 0; while (true || false) {a++}")
    ));

    it("should handle a redo within a loop", () => (
      to_js("while true do redo; end").must_equal("while (true) {var redo$; do {redo$ = false; redo$ = true; continue} while(redo$)}")
    ));

    it("should handle simple case statement", () => (
      to_js("case a; when 1,2; puts :a; end").must_equal("switch (a) {case 1: case 2: puts(\"a\")}")
    ));

    it("should handle case statement with irange", () => (
      to_js("case a; when 1..2; puts :a; end").must_equal("switch (true) {case a >= 1 && a <= 2: puts(\"a\")}")
    ));

    it("should handle case statement with erange", () => (
      to_js("case a; when 1...2; puts :a; end").must_equal("switch (true) {case a >= 1 && a < 2: puts(\"a\")}")
    ));

    it(
      "should handle case statement with mixed values and ranges",

      () => (
        to_js("case a; when 1...2, 3; puts :a; end").must_equal("switch (true) {case a >= 1 && a < 2: case a == 3: puts(\"a\")}")
      )
    );

    it("should parse when and else clauses as statements", () => (
      to_js("case 1; when 1; if true; end; else if false; end; end").must_equal("switch (1) {case 1: if (true) null; break; default: if (false) null}")
    ));

    it("should parse case expressions", () => (
      to_js("x = case a; when true; b; else; c; end").must_equal("var x = function() {switch (a) {case true: return b; default: return c}}()")
    ));

    it("should handle empty when blocks", () => (
      to_js("case a; when 1; when 2; b; end").must_equal("switch (a) {case 1: ; break; case 2: var b}")
    ));

    it("should handle a for loop", () => (
      to_js("a = {}; b = {}; for i in a; b[i] = a[i]; end").must_equal("var a = {}; var b = {}; for (var i in a) {b[i] = a[i]}")
    ));

    it("should handle a for loop with an inclusive range", () => (
      to_js("a = 0; for i in 1..3; a += i; end").must_equal("var a = 0; for (var i = 1; i <= 3; i++) {a += i}")
    ));

    it("should handle a for loop with an exclusive range", () => (
      to_js("a = 0; for i in 1...4; a += i; end").must_equal("var a = 0; for (var i = 1; i < 4; i++) {a += i}")
    ));

    it("should handle a stepped range with an inclusive range", () => (
      to_js("a = 0; (1..3).step(2) {|i| a += i}").must_equal("var a = 0; for (var i = 1; i <= 3; i += 2) {a += i}")
    ));

    it("should handle a stepped range with an exclusive range", () => (
      to_js("a = 0; (1...4).step(2) {|i| a += i}").must_equal("var a = 0; for (var i = 1; i < 4; i += 2) {a += i}")
    ));

    it(
      "should handle break",
      () => to_js("while true; break; end").must_equal("while (true) {break}")
    );

    it("should handle next as return", () => {
      to_js("x.forEach { next }").must_equal("x.forEach(function() {return})");
      return to_js("x.map {|i| next i}").must_equal("x.map(function(i) {return i})")
    });

    it(
      "should handle next as continue",
      () => to_js("while false; next; end").must_equal("while (false) {continue}")
    );

    it("should handle next as continue for step", () => (
      to_js("(1..3).step(1) {|i| next if i%2 == 0}").must_include("{if (i % 2 == 0) continue}")
    ));

    it(
      "should handle until",
      () => to_js("1 until false").must_equal("while (!false) {1}")
    );

    it("should handle while with post condition", () => (
      to_js("begin; foo(); end while condition").must_equal("do {foo()} while (condition)")
    ));

    return it("should handle until with post condition", () => (
      to_js("begin; foo(); end until condition").must_equal("do {foo()} while (!condition)")
    ))
  });

  describe("blocks", () => {
    it("should parse return", () => {
      let exp = "return 1";
      return to_js(exp).must_equal(exp)
    });

    it(
      "should parse proc",
      () => to_js("Proc.new {}").must_equal("function() {}")
    );

    it("should parse lambda", () => {
      to_js("lambda {}").must_equal("function() {}");
      return to_js("y = lambda {|x| x + 1}").must_equal("var y = function(x) {return x + 1}")
    });

    it(
      "should parse proc",
      () => to_js("proc {}").must_equal("function() {}")
    );

    it(
      "should support calls to anonymous functions",
      () => to_js("proc {}[]").must_equal("(function() {})()")
    );

    it("should handle basic variable scope", () => (
      to_js("a = 1; lambda { a = 2; b = 1}").must_equal("var a = 1; function() {a = 2; var b = 1}")
    ));

    it("should handle shadow args", () => (
      to_js("a = 1; lambda {|;a| a = 2}").must_equal("var a = 1; function() {var a = 2}")
    ));

    it("named functions aren't closures", () => (
      to_js("a = 1; def f; a = 2; b = 1; end").must_equal("var a = 1; function f() {var a = 2; var b = 1}")
    ));

    it("should handle one argument", () => (
      to_js("lambda { |a| return a + 1 }").must_equal("function(a) {return a + 1}")
    ));

    it("should handle arguments", () => (
      to_js("lambda { |a,b| return a + b }").must_equal("function(a, b) {return a + b}")
    ));

    it("should pass functions", () => (
      to_js("run(\"task\"){ |task| do_run task}").must_equal("run(\"task\", function(task) {do_run(task)})")
    ));

    it("should handle variable scope", () => (
      to_js("a = 1; lambda {|b| c = 0; a = b - c }; lambda { |b| c = 1; a = b + c }").must_equal("var a = 1; function(b) {var c = 0; a = b - c}; function(b) {var c = 1; a = b + c}")
    ));

    it("should really handle variable scope", () => (
      to_js("a, d = 1, 2; lambda {|b| c = 0; a = b - c * d}; lambda { |b| c = 1; a = b + c * d}").must_equal("var a = 1; var d = 2; function(b) {var c = 0; a = b - c * d}; function(b) {var c = 1; a = b + c * d}")
    ));

    it(
      "should parse with explicit return",
      () => to_js("Proc.new {return nil}").must_equal("function() {return null}")
    );

    it("should passthrough function definitions", () => (
      to_js("a=1; b=function(a,c) {return a + c}").must_equal("var a = 1; var b = function(a, c) {return a + c}")
    ));

    if (RUBY_VERSION.split(".").map(item => parseInt(item)) < [2, 7, 0] ? -1 : RUBY_VERSION.split(".").map(item => (
      parseInt(item)
    )) > [2, 7, 0] ? 1 : 0 != -1) {
      return it("should handle numbered parameters", () => (
        to_js("lambda { _1 + _2 }").must_equal("function(_1, _2) {return _1 + _2}")
      ))
    }
  });

  describe("object definition", () => {
    it(
      "should parse class",
      () => to_js("class Person; end").must_equal("function Person() {}")
    );

    it("should parse include", () => (
      to_js("class Employee; include Person; end").must_equal("function Employee() {}; (function() {for (var $_ in Person) {Employee.prototype[$_] = Person[$_]}})()")
    ));

    it("should parse class with attr_accessor", () => (
      to_js("class Person; attr_accessor :a; end").must_equal("function Person() {}; Object.defineProperty(Person.prototype, \"a\", {enumerable: true, configurable: true, get: function() {return this._a}, set: function(a) {this._a = a}})")
    ));

    it("should parse class with constructor", () => (
      to_js("class Person; def initialize(name); @name = name; end; end").must_equal("function Person(name) {this._name = name}")
    ));

    it("should parse a nested class with constructor", () => (
      to_js("class A::Person; def initialize(name); @name = name; end; end").must_equal("A.Person = function(name) {this._name = name}")
    ));

    it("should parse class with constructor and method", () => (
      to_js("class Person; def initialize(name); @name = name; end; def name; @name; end; end").must_equal("function Person(name) {this._name = name}; Object.defineProperty(Person.prototype, \"name\", {enumerable: true, configurable: true, get: function() {return this._name}})")
    ));

    it("should parse class with constructor and two methods", () => (
      to_js("class Person; def initialize(name); @name = name; end; def name; @name; end; def reset!; @name = nil; end; end").must_equal("function Person(name) {this._name = name}; Object.defineProperty(Person.prototype, \"name\", {enumerable: true, configurable: true, get: function() {return this._name}}); Person.prototype.reset = function() {this._name = null}")
    ));

    it("should strip ? from predicate method names in prototype", () => (
      to_js("class Person; def valid?; @name != nil; end; end").must_equal("function Person() {}; Person.prototype.valid = function() {this._name != null}")
    ));

    it(
      "should parse class with constructor and methods with multiple arguments",

      () => (
        to_js("class Person; def initialize(name, surname); @name, @surname = name, surname; end; def full_name; @name  + @surname; end; end").must_equal("function Person(name, surname) {this._name = name; this._surname = surname}; Object.defineProperty(Person.prototype, \"full_name\", {enumerable: true, configurable: true, get: function() {return this._name + this._surname}})")
      )
    );

    it("should collapse multiple methods in a class", () => (
      to_js("class C; def a; end; def b; end; end").must_equal("function C() {}; Object.defineProperties(C.prototype, {a: {enumerable: true, configurable: true, get: function() {}}, b: {enumerable: true, configurable: true, get: function() {}}})")
    ));

    it("should collapse getters and setters in a class", () => (
      to_js("class C; def a; end; def a=(a); end; end").must_equal("function C() {}; Object.defineProperty(C.prototype, \"a\", {enumerable: true, configurable: true, get: function() {}, set: function(a) {}})")
    ));

    it("should collapse properties", () => (
      to_js("class C; def self.a; end; def self.b; end; end").must_equal("function C() {}; Object.defineProperties(C, {a: {enumerable: true, configurable: true, get: function() {}}, b: {enumerable: true, configurable: true, get: function() {}}})")
    ));

    it("should parse class with inheritance", () => (
      to_js("class Employee < Person; end").must_equal("function Employee() {Person.call(this)}; Employee.prototype = Object.create(Person.prototype); Employee.prototype.constructor = Employee")
    ));

    it("should handle super", () => {
      to_js("class A; def initialize(x); end; end; class B < A; end").must_equal("function A(x) {}; function B(x) {A.call(this, x)}; B.prototype = Object.create(A.prototype); B.prototype.constructor = B");
      to_js("class A; end; class B < A; def initialize(x); super; end; end").must_equal("function A() {}; function B(x) {A.call(this, x)}; B.prototype = Object.create(A.prototype); B.prototype.constructor = B");
      to_js("class A; end; class B < A; def initialize(x); super(3); end; end").must_equal("function A() {}; function B(x) {A.call(this, 3)}; B.prototype = Object.create(A.prototype); B.prototype.constructor = B");
      to_js("class A; end; class B < A; def foo(x); super; end; end").must_equal("function A() {}; function B() {A.call(this)}; B.prototype = Object.create(A.prototype); B.prototype.constructor = B; B.prototype.foo = function(x) {A.prototype.foo.call(this, x)}");
      return to_js("class A; end; class B < A; def foo(x); super(3); end; end").must_equal("function A() {}; function B() {A.call(this)}; B.prototype = Object.create(A.prototype); B.prototype.constructor = B; B.prototype.foo = function(x) {A.prototype.foo.call(this, 3)}")
    });

    it("should parse class with class variables", () => {
      to_js("class Person; @@count=0; end").must_equal("function Person() {}; Person._count = 0");
      return to_js("class Person; @@count={}; @@count[1]=1; end").must_equal("function Person() {}; Person._count = {}; Person._count[1] = 1")
    });

    it(
      "should parse class with instance variables, properties and methods",

      () => {
        to_js("class Person; @@count=0; def offset(x); return @@count+x; end; end").must_equal("function Person() {}; Person._count = 0; Person.prototype.offset = function(x) {return Person._count + x}");
        to_js("class Person; @@count=0; def count; @@count; end; end").must_equal("function Person() {}; Person._count = 0; Object.defineProperty(Person.prototype, \"count\", {enumerable: true, configurable: true, get: function() {return Person._count}})");
        to_js("class Person; @@count=0; def count(); return @@count; end; end").must_equal("function Person() {}; Person._count = 0; Person.prototype.count = function() {return Person._count}");
        to_js("class Person; def initialize(name); @name = name; end; def name; @name; end; @@count=0; def count; return @@count; end; end").must_equal("function Person(name) {this._name = name}; Object.defineProperty(Person.prototype, \"name\", {enumerable: true, configurable: true, get: function() {return this._name}}); Person._count = 0; Object.defineProperty(Person.prototype, \"count\", {enumerable: true, configurable: true, get: function() {return Person._count}})");
        return to_js("class Person; def initialize(name); @name = name; end; def name; @name; end; @@count=0; def count(); return @@count; end; end").must_equal("function Person(name) {this._name = name}; Object.defineProperty(Person.prototype, \"name\", {enumerable: true, configurable: true, get: function() {return this._name}}); Person._count = 0; Person.prototype.count = function() {return Person._count}")
      }
    );

    it("should parse instance methods with class variables", () => (
      to_js("class Person; def count; @@count; end; end").must_equal("function Person() {}; Object.defineProperty(Person.prototype, \"count\", {enumerable: true, configurable: true, get: function() {return Person._count}})")
    ));

    it("should parse class methods with class variables", () => {
      to_js("class Person; def self.count(); return @@count; end; end").must_equal("function Person() {}; Person.count = function() {return Person._count}");
      to_js("class Person; def self.count; @@count; end; end").must_equal("function Person() {}; Object.defineProperty(Person, \"count\", {enumerable: true, configurable: true, get: function() {return Person._count}})");
      return to_js("class Person; def self.count=(count); @@count=count; end; end").must_equal("function Person() {}; Object.defineProperty(Person, \"count\", {enumerable: true, configurable: true, set: function(count) {Person._count = count}})")
    });

    it("should parse constructor methods with class variables", () => (
      to_js("class Person; def initialize; @@count+=1; end; end").must_equal("function Person() {Person._count++}")
    ));

    it("should parse class with class constants", () => (
      to_js("class Person; ID=7; end").must_equal("function Person() {}; Person.ID = 7")
    ));

    it("should parse class with class methods", () => (
      to_js("class Person; def self.search(name); end; end").must_equal("function Person() {}; Person.search = function(name) {}")
    ));

    it("should parse class with alias", () => (
      to_js("class Person; def f(name); end; alias :g :f; end").must_equal("function Person() {}; Person.prototype.f = function(name) {}; Person.prototype.g = Person.prototype.f")
    ));

    it("should parse method def", () => {
      to_js("def method; end").must_equal("function method() {}");
      to_js("def question?; end").must_equal("function question() {}");
      return to_js("def bang!; end").must_equal("function bang() {}")
    });

    it("should parse endless method definitions (Ruby 3.0+)", () => {
      to_js("def square(x) = x * x").must_equal("function square(x) {return x * x}");
      return to_js("def add(a, b) = a + b").must_equal("function add(a, b) {return a + b}")
    });

    it("should parse endless singleton method definitions", () => (
      to_js("def self.double(x) = x * 2").must_equal("this.double = function(x) {return x * 2}")
    ));

    it("should parse argument forwarding (Ruby 2.7+)", () => {
      to_js("def wrapper(...); wrapped(...); end").must_equal("function wrapper(...args) {wrapped(...args)}");
      return to_js("def forward(...); a(...); b(...); end").must_equal("function forward(...args) {a(...args); b(...args)}")
    });

    it("should parse singleton method and property definitions", () => {
      to_js("def self.method(); end").must_equal("this.method = function() {}");
      to_js("def self.prop; @prop; end").must_equal("Object.defineProperty(this, \"prop\", {enumerable: true, configurable: true, get: function() {return this._prop}})");
      to_js("def self.prop=(prop); @prop=prop; end").must_equal("Object.defineProperty(this, \"prop\", {enumerable: true, configurable: true, set: function(prop) {this._prop = prop}})");
      return to_js("def self.prop; @prop; end; def self.prop=(prop); @prop=prop; end").must_equal("Object.defineProperty(this, \"prop\", {enumerable: true, configurable: true, get: function() {return this._prop}, set: function(prop) {this._prop = prop}})")
    });

    it("should parse nested classes", () => (
      to_js("class A; class B; class C; end; end; end").must_equal("function A() {}; A.B = function() {}; A.B.C = function() {}")
    ));

    it("should convert self to this", () => (
      to_js("def method; return self.foo; end").must_equal("function method() {return this.foo}")
    ));

    it("should prefix intra-method calls with 'this.'", () => (
      to_js("class C; def m1; end; def m2; m1; end; end").must_equal("function C() {}; Object.defineProperties(C.prototype, {m1: {enumerable: true, configurable: true, get: function() {}}, m2: {enumerable: true, configurable: true, get: function() {return this.m1}}})")
    ));

    it("should prefix property assignments with this.", () => (
      to_js("class C; def a=(x); @a=x; end; def b(); a+=1; end; end").must_equal("function C() {}; Object.defineProperty(C.prototype, \"a\", {enumerable: true, configurable: true, set: function(x) {this._a = x}}); C.prototype.b = function() {a++}")
    ));

    it("should prefix bind references to methods as properties", () => (
      to_js("class C; def m1(); end; def m2; m1; end; end").must_equal("function C() {}; C.prototype.m1 = function() {}; Object.defineProperty(C.prototype, \"m2\", {enumerable: true, configurable: true, get: function() {return this.m1.bind(this)}})")
    ));

    it(
      "should prefix class constants referenced in methods by class name",

      () => (
        to_js("class C; X = 1; def m; X; end; end").must_equal("function C() {}; C.X = 1; Object.defineProperty(C.prototype, \"m\", {enumerable: true, configurable: true, get: function() {return C.X}})")
      )
    );

    it("should insert var self = this when needed", () => {
      to_js("class C; def m; list.each do; @ivar; end; end; end").must_equal("function C() {}; Object.defineProperty(C.prototype, \"m\", {enumerable: true, configurable: true, get: function() {var self = this; return list.each(function() {self._ivar})}})");
      to_js("class C; def m(); list.each do; @ivar; @ivar; end; end; end").must_equal("function C() {}; C.prototype.m = function() {var self = this; list.each(function() {self._ivar; self._ivar})}");
      to_js("class C < S; def m; list.each do; @ivar; end; end; end").must_equal("function C() {S.call(this)}; C.prototype = Object.create(S.prototype); C.prototype.constructor = C; Object.defineProperty(C.prototype, \"m\", {enumerable: true, configurable: true, get: function() {var self = this; return list.each(function() {self._ivar})}})");
      to_js("class C < S; def m(); list.each do; @ivar; @ivar; end; end; end").must_equal("function C() {S.call(this)}; C.prototype = Object.create(S.prototype); C.prototype.constructor = C; C.prototype.m = function() {var self = this; list.each(function() {self._ivar; self._ivar})}");
      to_js("class C < S; def m(); list.each do; {n: @ivar}; end; end; end").must_equal("function C() {S.call(this)}; C.prototype = Object.create(S.prototype); C.prototype.constructor = C; C.prototype.m = function() {var self = this; list.each(function() {{n: self._ivar}})}");
      return to_js("class C; def self.a(); window.addEventListener :unload do; self.b(); end; end; end").must_equal("function C() {}; C.a = function() {var self = this; window.addEventListener(\"unload\", function() {self.b()})}")
    });

    it("should handle methods with multiple statements", () => (
      to_js("def method; self.foo(); self.bar; end").must_equal("function method() {this.foo(); this.bar}")
    ));

    it("should handle methods with optional arguments", () => (
      to_js("def method(opt=1); return opt; end").must_equal("function method(opt) {if (typeof opt === 'undefined') opt = 1; return opt}")
    ));

    it("should handle methods with block arguments", () => (
      to_js("def method(&b); return b; end").must_equal("function method(b) {return b}")
    ));

    return it(
      "should handle calls with block arguments",
      () => to_js("method(&b)").must_equal("method(b)")
    )
  });

  describe("class extensions", () => {
    it("should handle constructors", () => (
      to_js("++class F; def initialize() {}; end; end").must_equal("(function() {var $_ = F.prototype; (F = function F() {{}}).prototype = $_})()")
    ));

    it("should handle methods", () => (
      to_js("++class F; def m(); end; end").must_equal("F.prototype.m = function() {}")
    ));

    return it("should handle properties", () => (
      to_js("++class F; def p; 1; end; end").must_equal("Object.defineProperty(F.prototype, \"p\", {enumerable: true, configurable: true, get: function() {return 1}})")
    ))
  });

  describe("anonymous classes", () => {
    it("should handle anonymous classes without inheritance", () => (
      to_js("x = Class.new do def f(); return 1; end; end").must_equal("var x = function() {function $$() {}; $$.prototype.f = function() {return 1}; return $$}()")
    ));

    return it("should handle anonymous classes with inheritance", () => (
      to_js("x = Class.new(D) do def f(); return 1; end; end").must_equal("var x = function() {function $$() {D.call(this)}; $$.prototype = Object.create(D.prototype); $$.prototype.constructor = $$; $$.prototype.f = function() {return 1}; return $$}()")
    ))
  });

  describe("module definition", () => {
    it(
      "should handle empty modules",
      () => to_js("module A; end").must_equal("A = {}")
    );

    it("should handle module definitions", () => {
      to_js("module A; B=1; end").must_equal("A = function() {var B = 1; return {B: B}}()");
      to_js("module A; def b; return 1; end; end").must_equal("var A = {}; Object.defineProperty(A.prototype, \"b\", {enumerable: true, configurable: true, get: function() {return 1}})");
      to_js("module A; def b(); return 1; end; end").must_equal("var A = {b: function() {return 1}}");
      return to_js("module A; class B; def initialize; @c=1; end; end; end").must_equal("A = function() {function B() {this._c = 1}; return {B: B}}()")
    });

    it("should handle private sections", () => (
      to_js("module A; B=1; private; C=1; end").must_equal("A = function() {var B = 1; var C = 1; return {B: B}}()")
    ));

    return it("should handle nested modules", () => {
      to_js("module M; module N; def f(); end; end; end").must_equal("var M = {N: {f: function() {}}}");
      return to_js("module M; module N; end; module N::O; end; end").must_equal("var M = {N: {}}; M.N.O = {}")
    })
  });

  describe("allocation", () => (
    it("should handle class new", () => {
      to_js("Date.new").must_equal("new Date");
      to_js("Date.new.toString()").must_equal("(new Date).toString()");
      to_js("Date.new()").must_equal("new Date()");
      to_js("Date.new().toString()").must_equal("new Date().toString()");
      to_js("new Date()").must_equal("new Date()");
      to_js("new Date").must_equal("new Date");
      to_js("new Promise do; y(); end").must_equal("new Promise(function() {y()})");
      to_js("new Promise() do; y(); end").must_equal("new Promise(function() {y()})");
      return to_js("new xeogl.Model()").must_equal("new xeogl.Model()")
    })
  ));

  describe("typeof, defined, instance_of", () => {
    it(
      "should handle typeof",
      () => to_js("typeof x").must_equal("typeof x")
    );

    it("should handle negation of typeof comparisons", () => {
      to_js("return unless typeof x == \"number\"").must_equal("if (typeof x != \"number\") return");
      return to_js("return if typeof x != \"number\"").must_equal("if (typeof x != \"number\") return")
    });

    it("should handle defined?", () => {
      to_js("defined? x").must_equal("typeof x !== 'undefined'");
      return to_js("!defined? x").must_equal("typeof x === 'undefined'")
    });

    it(
      "should handle undef",
      () => to_js("undef x").must_equal("delete x")
    );

    it("should handle is_a?, kind_of?, instance_of?", () => {
      to_js("a.is_a? b").must_equal("(a instanceof b)");
      to_js("a.kind_of? b").must_equal("(a instanceof b)");
      to_js("a.instance_of? b").must_equal("(a.constructor == b)");
      to_js("x unless a.is_a? b").must_equal("if (!(a instanceof b)) var x");
      to_js("x unless a.kind_of? b").must_equal("if (!(a instanceof b)) var x");
      return to_js("x unless a.instance_of? b").must_equal("if (!(a.constructor == b)) var x")
    });

    return it(
      "should handle is_a?, kind_of?, instance_of? with safe navigation",

      () => {
        to_js("a&.is_a? b").must_equal("a && (a instanceof b)");
        to_js("a&.kind_of? b").must_equal("a && (a instanceof b)");
        return to_js("a&.instance_of? b").must_equal("a && (a.constructor == b)")
      }
    )
  });

  describe("attribute access", () => {
    it(
      "should support attribute reference",
      () => to_js("x=a.b").must_equal("var x = a.b")
    );

    it(
      "should support attribute assignments",
      () => to_js("x={}; x.a=\"y\"").must_equal("var x = {}; x.a = \"y\"")
    );

    if (RUBY_VERSION.split(".").map(item => parseInt(item)) < [2, 3, 0] ? -1 : RUBY_VERSION.split(".").map(item => (
      parseInt(item)
    )) > [2, 3, 0] ? 1 : 0 != -1) {
      it(
        "should support conditional attribute references",
        () => to_js("x=a&.b").must_equal("var x = a && a.b")
      );

      it(
        "should chain conditional attribute references",
        () => to_js("x=a&.b&.c").must_equal("var x = a && a.b && a.b.c")
      );

      it(
        "should handle method args with conditional chaining",
        () => to_js("x=a&.b(c, d)").must_equal("var x = a && a.b(c, d)")
      )
    };

    if (RUBY_VERSION.split(".").map(item => parseInt(item)) < [3, 0, 0] ? -1 : RUBY_VERSION.split(".").map(item => (
      parseInt(item)
    )) > [3, 0, 0] ? 1 : 0 != -1) {
      it(
        "should support => operator with simple left hand sides",
        () => to_js("0 => x").must_equal("var x = 0")
      );

      return it(
        "should support => operator with simple destructuring",
        () => to_js("hash => {a:, b:}").must_equal("var a = hash.a; var b = hash.b")
      )
    }
  });

  describe("whitespace", () => {
    it(
      "should handle newlines",
      () => to_js("a = 1\na = 2").must_equal("var a = 1;\na = 2")
    );

    it(
      "should handle if statements",
      () => to_js("a() if true").must_equal("if (true) a()")
    );

    it(
      "should handle while statements",
      () => to_js("a() while false\n").must_equal("while (false) {\n  a()\n}")
    );

    it("should parse when and else clauses as statements", () => (
      to_js("case 1\nwhen 1\na()\nelse\nb()\nend").must_equal("switch (1) {\ncase 1:\n  a();\n  break;\n\ndefault:\n  b()\n}")
    ));

    it("should handle function declarations", () => (
      to_js("Proc.new {return null}\n").must_equal("function() {\n  return null\n}")
    ));

    it("should add a blank line before blocks", () => (
      to_js("x()\nif true; a(); b(); end").must_equal("x();\n\nif (true) {\n  a();\n  b()\n}")
    ));

    it("should add a blank line after blocks", () => (
      to_js("if true; a(); b(); end\nx()").must_equal("if (true) {\n  a();\n  b()\n};\n\nx()")
    ));

    return it("should add a single blank line between blocks", () => (
      to_js("if true; a(); b(); end\nif false; c(); d(); end").must_equal("if (true) {\n  a();\n  b()\n};\n\nif (false) {\n  c();\n  d()\n}")
    ))
  });

  describe("procs", () => {
    it("should handle procs", () => {
      if (RUBY2JS_PARSER == "prism") {
        skip("prism walker doesn't support Proc source location")
      };

      let source = () => c + 1;
      return to_js(source).must_equal("c + 1")
    });

    return it("should handle lambdas", () => {
      if (RUBY2JS_PARSER == "prism") {
        skip("prism walker doesn't support Proc source location")
      };

      let source = () => c + 1;
      return to_js(source).must_equal("c + 1")
    })
  });

  describe("regular expressions", () => {
    it(
      "should handle regular expressions with options",
      () => to_js("/a.*b/im").must_equal("/a.*b/im")
    );

    it("should handle %regular expressions", () => {
      to_js("%r{/\\w+}").must_equal("/\\/\\w+/");
      return to_js("%r{/a/b/c/d}").must_equal("new RegExp(\"/a/b/c/d\")")
    });

    it(
      "should handle extended regular expressions",
      () => to_js("/a\nb/x").must_equal("/ab/")
    );

    it(
      "should handle regular expressions with interpolation",
      () => to_js("/a\#{b}c/i").must_equal("new RegExp(\"a\" + b + \"c\", \"i\")")
    );

    it(
      "should map Ruby's Regexp to JavaScript's RegExp",
      () => to_js("Regexp.new(a)").must_equal("new RegExp(a)")
    );

    it(
      "should map static RegExps to regular expression literals",
      () => to_js("RegExp.new(\"a\", \"g\")").must_equal("/a/g")
    );

    it(
      "should allow Regexps to be passed on the Regexp constructor",
      () => to_js("Regexp.new(/a\nb/ix, 'g')").must_equal("/ab/ig")
    );

    it(
      "should handle regular expressions tests",
      () => to_js("'abc' =~ /abc/").must_equal("/abc/.test(\"abc\")")
    );

    it(
      "should handle regular expressions not tests",
      () => to_js("'abc' !~ /abc/").must_equal("!/abc/.test(\"abc\")")
    );

    it("should treat ^ and $ as multiline", () => {
      to_js("/^x/").must_equal("/^x/m");
      to_js("/x$/").must_equal("/x$/m");
      to_js("Regexp.new('^$')").must_equal("/^$/m");
      to_js("/^./m").must_equal("/^./ms");
      to_js("/.$/m").must_equal("/.$/ms");
      return to_js("Regexp.new('^$', 'm')").must_equal("/^$/m")
    });

    return it("should treat A and z as singleline", () => {
      to_js("/\\A./").must_equal("/^./");
      to_js("/.\\z/").must_equal("/.$/");
      return to_js(`Regexp.new(${JSON.stringify("\\A\\z")})`).must_equal("/^$/")
    })
  });

  describe("exceptions", () => {
    it(
      "should handle raise with a string",
      () => to_js("raise \"heck\"").must_equal("throw \"heck\"")
    );

    it("should handle raise with a class and string", () => (
      to_js("raise Exception, \"heck\"").must_equal("throw new Exception(\"heck\")")
    ));

    it("should handle catching any exception", () => (
      to_js("begin a; rescue => e; b; end").must_equal("try {var a} catch (e) {var b}")
    ));

    it("catching exceptions without a variable", () => (
      to_js("begin a; rescue; p $!; end").must_equal("try {var a} catch ($EXCEPTION) {p($EXCEPTION)}")
    ));

    it("should handle catching a specific exception", () => (
      to_js("begin a; rescue StandardError => e; b; end").must_equal("try {var a} catch (e) {if (e instanceof StandardError) {var b} else {throw e}}")
    ));

    it("should handle catching a String", () => (
      to_js("begin a; rescue String => e; b; end").must_equal("try {var a} catch (e) {if (typeof e == \"string\") {var b} else {throw e}}")
    ));

    it("catching exceptions with a type but without a variable", () => (
      to_js("begin a; rescue Foo; end").must_equal("try {var a} catch ($EXCEPTION) {if ($EXCEPTION instanceof Foo) {} else {throw $EXCEPTION}}")
    ));

    it("should handle an ensure clause", () => (
      to_js("begin a; ensure b; end").must_equal("try {var a} finally {var b}")
    ));

    it(
      "should handle catching an exception and an ensure clause",

      () => (
        to_js("begin a; rescue => e; b; ensure; c; end").must_equal("try {var a} catch (e) {var b} finally {var c}")
      )
    );

    it(
      "should handle multiple rescue clauses with different variables",

      () => (
        to_js("begin; a; rescue FooError => foo; b(foo); rescue BarError => bar; c(bar); end").must_equal("try {var a} catch (foo) {if (foo instanceof FooError) {b(foo)} else if (foo instanceof BarError) {var bar = foo; c(bar)} else {throw foo}}")
      )
    );

    it(
      "should handle multiple rescue clauses with mixed variable usage",

      () => (
        to_js("begin; a; rescue FooError => e; b(e); rescue BarError; c; end").must_equal("try {var a} catch (e) {if (e instanceof FooError) {b(e)} else if (e instanceof BarError) {var c} else {throw e}}")
      )
    );

    it("should handle implicit begin in methods", () => (
      to_js("def foo; x(); rescue => e; y(e); end").must_equal("function foo() {try {x()} catch (e) {y(e)}}")
    ));

    it("should handle implicit ensure in methods", () => (
      to_js("def foo; x(); ensure; y(); end").must_equal("function foo() {try {x()} finally {y()}}")
    ));

    it("should handle implicit rescue and ensure in methods", () => (
      to_js("def foo; x(); rescue => e; y(e); ensure; z(); end").must_equal("function foo() {try {x()} catch (e) {y(e)} finally {z()}}")
    ));

    it("should handle retry in rescue block", () => (
      to_js("begin; a; rescue; retry; end").must_equal("while (true) {try {var a; break} catch ($EXCEPTION) {continue}}")
    ));

    it("should handle retry with exception type", () => (
      to_js("begin; a; rescue StandardError; retry; end").must_equal("while (true) {try {var a; break} catch ($EXCEPTION) {if ($EXCEPTION instanceof StandardError) {continue} else {throw $EXCEPTION}}}")
    ));

    it(
      "should handle neither a rescue nor an ensure being present",
      () => to_js("begin a; b; end").must_equal("{var a; var b}")
    );

    it("should handle else clause in begin/rescue", () => (
      to_js("begin; a; rescue => e; b; else; c; end").must_equal("var $no_exception = false; try {var a; $no_exception = true} catch (e) {var b}; if ($no_exception) {var c}")
    ));

    it("should handle else clause with ensure", () => (
      to_js("begin; a; rescue; b; else; c; ensure; d; end").must_equal("var $no_exception = false; try {var a; $no_exception = true} catch ($EXCEPTION) {var b} finally {var d}; if ($no_exception) {var c}")
    ));

    it(
      "should hoist variables declared in try that are used in finally",

      () => (
        to_js("begin; x = 1; rescue; y; ensure; z(x); end", {eslevel: 2_015}).must_equal("{let x; try {x = 1} catch ($EXCEPTION) {let y} finally {z(x)}}")
      )
    );

    it("should not hoist variables already declared", () => (
      to_js("x = 0; begin; x = 1; ensure; z(x); end", {eslevel: 2_015}).must_equal("let x = 0; try {x = 1} finally {z(x)}")
    ));

    it("should not hoist variables not used in finally", () => (
      to_js("begin; x = 1; ensure; z(); end", {eslevel: 2_015}).must_equal("try {let x = 1} finally {z()}")
    ));

    return it("should handle begin as an expression", () => (
      to_js("z = begin; x = 1; x; end").must_equal("var z = function() {var x = 1; return x}()")
    ))
  });

  describe("execution", () => {
    it(
      "should handle tic marks",
      () => to_js("`1+2`", {binding}).must_equal("3")
    );

    it(
      "should handle execute strings",
      () => to_js("%x(3*4)", {binding}).must_equal("12")
    );

    return it("should evaluate variables using the binding", () => {
      let foo = "console.log('hi there')";
      return to_js("%x(foo)", {binding}).must_equal(foo)
    })
  });

  describe("ivars", () => {
    it("should handle ivars", () => {
      to_js("@x", {ivars: {"@x": {a: 1}}}).must_equal("{a: 1}");
      to_js("@x", {ivars: {"@x": ["a", "b", "c"]}}).must_equal("[\"a\", \"b\", \"c\"]");
      to_js("@x", {ivars: {"@x": 5.1}}).must_equal("5.1");
      to_js("@x", {ivars: {"@x": [true, false, null]}}).must_equal("[true, false, null]");
      return to_js("@x", {ivars: {"@x": Rational(5, 4)}}).must_equal("1")
    });

    return it("should not replace ivars in class definitions", () => (
      to_js("class F; def f; @x; end; end", {ivars: {"@x": 1}}).must_equal("function F() {}; Object.defineProperty(F.prototype, \"f\", {enumerable: true, configurable: true, get: function() {return this._x}})")
    ))
  });

  return describe("global scope", () => (
    it(
      "should handle top level constants",
      () => to_js("::A").must_equal("Function(\"return this\")().A")
    )
  ))
})
// Run tests and report results
const success = printResults();
process.exit(success ? 0 : 1);
