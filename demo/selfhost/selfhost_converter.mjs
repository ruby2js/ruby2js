// Auto-generated by Ruby2JS self-hosting
// This module provides a JavaScript implementation of Ruby2JS

// AST Node class
class Node {
  constructor(type, children = []) {
    this.type = type;
    this.children = Object.freeze(children);
    this.loc = null;
  }

  updated(newType, newChildren) {
    const n = new Node(newType || this.type, newChildren || this.children);
    n.loc = this.loc;
    return n;
  }
}

// S-expression helper
function s(type, ...children) {
  return new Node(type, children);
}

// Stub base classes
class NotImplementedError extends Error {
  constructor(message) {
    super(message);
    this.name = 'NotImplementedError';
  }
}

// Ruby Hash class stub (used for type checking in parse_all)
class Hash {}

// Token - wraps a string with AST location info
// Hand-written because Ruby's def empty? doesn't transpile to valid JS
class Token {
  constructor(value, ast) {
    this.value = value != null ? String(value) : '';
    this.ast = ast;
    this.loc = ast?.location || null;
  }
  toString() { return this.value; }
  get length() { return this.value.length; }
  isEmpty() { return this.value.length === 0; }
  startsWith(...args) { return this.value.startsWith(...args); }
  endsWith(...args) { return this.value.endsWith(...args); }
  gsub(pattern, replacement) { return this.value.replace(new RegExp(pattern, 'g'), replacement); }
  charAt(i) { return this.value[i]; }
  plus(other) { return this.value + String(other); }
}

// Line - holds tokens for a single output line
// Hand-written because Ruby's def empty? doesn't transpile to valid JS
class Line {
  constructor(...args) {
    this.tokens = args;
    this.indent = 0;
  }
  get length() { return this.tokens.length; }
  get(i) { return this.tokens[i]; }
  set(i, v) { this.tokens[i] = v; }
  push(...args) { this.tokens.push(...args); return this; }
  pop() { return this.tokens.pop(); }
  shift() { return this.tokens.shift(); }
  unshift(...args) { this.tokens.unshift(...args); return this; }
  get first() { return this.tokens[0]; }
  get last() { return this.tokens[this.tokens.length - 1]; }
  isEmpty() { return this.tokens.every(t => t.isEmpty()); }
  each(fn) { this.tokens.forEach(fn); }
  eachWithIndex(fn) { this.tokens.forEach((t, i) => fn(t, i)); }
  map(fn) { return this.tokens.map(fn); }
  find(fn) { return this.tokens.find(fn); }
  includes(item) { return this.tokens.includes(item); }
  toArray() { return this.tokens.map(t => t.toString()); }
  join(sep = '') { return this.tokens.map(t => t.toString()).join(sep); }
  insert(i, ...items) { this.tokens.splice(i, 0, ...items); }
  splice(start, count, ...items) {
    const removed = this.tokens.splice(start, count, ...items);
    return removed;
  }
  findLastIndex(fn) {
    for (let i = this.tokens.length - 1; i >= 0; i--) {
      if (fn(this.tokens[i])) return i;
    }
    return null;
  }
  isComment() {
    const first = this.find(t => !t.isEmpty());
    return first && first.startsWith('//');
  }
  toString() {
    if (this.isEmpty()) return '';
    const content = this.join();
    const first = this.tokens[0]?.toString();
    if (first === 'case ' || first === 'default:') {
      return ' '.repeat(Math.max(0, this.indent - 2)) + content;
    }
    if (this.indent > 0) return ' '.repeat(this.indent) + content;
    return content;
  }
}

// Serializer - output formatting for the converter
// Hand-written because the Ruby version has operator overloading (def +)
// and other patterns that don't transpile cleanly
class Serializer {
  constructor() {
    this._sep = '; ';
    this._nl = '';
    this._ws = ' ';
    this._width = 80;
    this._indent = 0;
    this._lines = [new Line()];
    this._line = this._lines[this._lines.length - 1];
    this._timestamps = {};
    this._ast = null;
    this.file_name = '';
  }

  enable_vertical_whitespace() {
    this._sep = ";\n";
    this._nl = "\n";
    this._ws = this._nl;
    this._indent = 2;
  }

  // indent multi-line parameter lists, array constants, blocks
  reindent(lines) {
    let indent = 0;
    for (const line of lines) {
      const first = line.find(token => !token.isEmpty());
      if (first) {
        const lastIdx = line.findLastIndex(token => !token.isEmpty());
        const last = line.get(lastIdx);
        if ((first.startsWith('<') && line.includes('>')) ||
            (last && last.endsWith('>') && line.includes('<'))) {
          const node = line.join('').match(/.*?(<.*)/)?.[1] || '';
          if (node.startsWith('</')) indent -= this._indent;
          line.indent = indent;
          const node2 = line.join('').match(/.*(<.*)/)?.[1] || '';
          if (!node2.includes('</') && !node2.includes('/>')) indent += this._indent;
        } else {
          if (')}]'.includes(first.charAt(0)) && indent >= this._indent) indent -= this._indent;
          line.indent = indent;
          if (last && '({['.includes(last.charAt(last.length - 1))) indent += this._indent;
        }
      } else {
        line.indent = indent;
      }
    }
  }

  // add horizontal (indentation) and vertical (blank lines) whitespace
  respace() {
    if (this._indent === 0) return;
    this.reindent(this._lines);

    for (let i = this._lines.length - 3; i >= 0; i--) {
      if (this._lines[i].length === 0) {
        this._lines.splice(i, 1);
      } else if (
        this._lines[i+1].isComment() && !this._lines[i].isComment() &&
        this._lines[i].indent === this._lines[i+1].indent
      ) {
        this._lines.splice(i+1, 0, new Line());
      } else if (
        this._lines[i].indent === this._lines[i+1].indent &&
        this._lines[i+1].indent < this._lines[i+2]?.indent &&
        !this._lines[i].isComment()
      ) {
        this._lines.splice(i+1, 0, new Line());
      } else if (
        this._lines[i].indent > this._lines[i+1].indent &&
        this._lines[i+1].indent === this._lines[i+2]?.indent &&
        !this._lines[i+2]?.isEmpty()
      ) {
        this._lines.splice(i+2, 0, new Line());
      }
    }
  }

  // add a single token to the current line
  put(string) {
    if (!(typeof string === 'string') || !string.includes('\n')) {
      this._line.push(new Token(string, this._ast));
    } else {
      const parts = string.split('\n');
      const first = parts.shift();
      if (first) this._line.push(new Token(first, this._ast));
      // Ruby's split drops trailing empty strings, JS keeps them.
      // Remove the last empty string if the string ends with \n
      // since we'll add a new line explicitly below.
      if (string.endsWith('\n') && parts.length > 0 && parts[parts.length - 1] === '') {
        parts.pop();
      }
      for (const part of parts) {
        this._lines.push(new Line(new Token(part, this._ast)));
      }
      if (string.endsWith('\n')) this._lines.push(new Line());
      this._line = this._lines[this._lines.length - 1];
    }
  }

  // add a single token and advance to next line
  puts(string) {
    if (!(typeof string === 'string') || !string.includes('\n')) {
      this._line.push(new Token(string, this._ast));
    } else {
      this.put(string);
    }
    this._line = new Line();
    this._lines.push(this._line);
  }

  // advance to next line and add a single token
  sput(string) {
    if (!(typeof string === 'string') || !string.includes('\n')) {
      this._line = new Line(new Token(string, this._ast));
      this._lines.push(this._line);
    } else {
      this._line = new Line();
      this._lines.push(this._line);
      this.put(string);
    }
  }

  // current location: [line number, token number]
  output_location() {
    return [this._lines.length - 1, this._line.length];
  }

  // insert a line into the output
  insert(mark, line) {
    if (mark[1] === 0) {
      this._lines.splice(mark[0], 0, new Line(new Token(line.replace(/\n$/, ''), this._ast)));
    } else {
      this._lines[mark[0]].splice(mark[1], 0, new Token(line, this._ast));
    }
  }

  // capture (and remove) tokens from the output stream
  capture(block) {
    const mark = this.output_location();
    block();
    let lines = this._lines.splice(mark[0] + 1);
    this._line = this._lines[this._lines.length - 1];

    if (lines.length === 0) {
      lines = [new Line(...this._line.splice(mark[1]))];
    } else if (this._line.length !== mark[1]) {
      lines.unshift(new Line(...this._line.splice(mark[1])));
    }

    return lines.map(l => l.join()).join(this._ws);
  }

  // wrap long statements in curly braces
  wrap(open = '{', close = '}', block) {
    this.puts(open);
    const mark = this.output_location();
    block();

    if (
      this._lines.length > mark[0] + 1 ||
      this._lines[mark[0] - 1].join().length + this._line.join().length >= this._width
    ) {
      this.sput(close);
    } else {
      this._line = this._lines[mark[0] - 1];
      const lastLine = this._lines.pop();
      this._line.pop();
      lastLine.each(token => this._line.push(token));
    }
  }

  // compact small expressions into a single line
  compact(block) {
    const mark = this.output_location();
    block();
    if (this._lines.length - mark[0] <= 1) return;
    if (this._indent === 0) return;

    let work = [];
    let len = 0;
    let trail = null;
    let split = null;
    const slice = this._lines.slice(mark[0]);
    this.reindent(slice);

    for (let index = 0; index < slice.length; index++) {
      const line = slice[index];
      if (line.length === 0) line.push(new Token('', null));
      if (line.first.startsWith('//')) {
        len += this._width;
      } else {
        if (trail === line.indent && this._indent > 0) { work.push(new Token(' ', null)); len += 1; }
        len += line.map(t => t.length).reduce((a, b) => a + b, 0);
        line.each(token => work.push(token));

        if (trail === this._indent && line.indent === this._indent) {
          split = [len, work.length, index];
          if (len >= this._width - 10) break;
        }
        trail = line.indent;
      }
    }

    if (len < this._width - 10) {
      this._lines.splice(mark[0], this._lines.length - mark[0]);
      this._lines.push(new Line(...work));
      this._line = this._lines[this._lines.length - 1];
    } else if (split && split[0] < this._width - 10) {
      if (slice[split[2]].indent < slice[split[2] + 1]?.indent) {
        const close = slice.pop();
        close.each(token => slice[slice.length - 1].push(token));
        this._lines[mark[0]] = new Line(...work.slice(0, split[1]));
        this._lines.splice(mark[0] + 1, this._lines.length - mark[0] - 1, ...slice.slice(split[2] + 1));
        this._line = this._lines[this._lines.length - 1];
      }
    }
  }

  // return the output as a string
  to_s() {
    if (this._str) return this._str;
    this.respace();
    return this._lines.map(l => l.toString()).join(this._nl);
  }
}

// Forward declaration for module (assigned by transpiled code)
let Ruby2JS;

Ruby2JS = (() => {
  // Token wraps a string with AST location info for sourcemaps
  // Using composition instead of inheritance for JS compatibility
  class Error extends NotImplementedError {
    constructor(message, ast) {
      // Delegate string methods to value
      let loc = ast.loc;

      if (loc) {
        if (typeof loc === "object" && loc !== null && "expression" in loc && loc.expression) {
          // Parser gem location
          message += " at " + loc.expression.source_buffer.name.toString();
          message += ":" + JSON.stringify(loc.expression.line);
          message += ":" + loc.expression.column.toString()
        } else if (Object.prototype.toString.call(loc) === "[object Object]" && loc.start_offset) {
          // Ruby2JS::Node location (prism-direct)
          message += " at offset " + (loc.start_offset || "").toString()
        }
      };

      super(message)
    }
  };

  // Line holds tokens for a single output line
  // Using composition instead of inheritance for JS compatibility
  class Converter extends Serializer {
    #ast;
    #autobind;
    #binding;
    #block_depth;
    #block_this;
    #class_name;
    #class_parent;
    #comments;
    #comparison;
    #eslevel;
    #handlers;
    #inner;
    #instance_method;
    #ivars;
    #jsx;
    #module_type;
    #namespace;
    #next_token;
    #options;
    #or;
    #prop;
    #prototype;
    #rbstack;
    #redoable;
    #scope;
    #state;
    #strict;
    #timestamps;
    #underscored_private;
    #vars;
    #varstack;
    static #$handlers = [];

    get ast() {
      return this.#ast
    };

    set ast(ast) {
      this.#ast = ast
    };

    static LOGICAL = ["and", "not", "or"];

    static OPERATORS = [
      ["[]", "[]="],
      ["not", "!"],
      ["**"],
      ["*", "/", "%"],
      ["+", "-"],
      [">>", "<<"],
      ["&"],
      ["^", "|"],
      ["<=", "<", ">", ">="],
      ["==", "!=", "===", "!==", "=~", "!~"],
      ["and", "or"]
    ];

    static INVERT_OP = {
      "<": ">=",
      "<=": ">",
      "==": "!=",
      "!=": "==",
      ">": "<=",
      ">=": "<",
      "===": "!=="
    };

    static GROUP_OPERATORS = [
      "begin",
      "dstr",
      "dsym",
      "and",
      "or",
      "casgn",
      "if"
    ];

    static VASGN = ["cvasgn", "ivasgn", "gvasgn", "lvasgn"];

    get binding() {
      return this.#binding
    };

    set binding(binding) {
      this.#binding = binding
    };

    get ivars() {
      return this.#ivars
    };

    set ivars(ivars) {
      this.#ivars = ivars
    };

    get namespace() {
      return this.#namespace
    };

    set namespace(namespace) {
      this.#namespace = namespace
    };

    constructor(ast, comments, vars={}) {
      // Array-like interface
      super();

      [this.#ast, this.#comments, this.#vars] = [
        ast,
        comments,
        Object.assign({}, vars)
      ];

      this.#varstack = [];
      this.#scope = ast;
      this.#inner = null;
      this.#rbstack = [];
      this.#next_token = "return";
      this.#handlers = {};

      for (let name of Object.getOwnPropertyNames(Object.getPrototypeOf(this)).filter(k => (
        k.startsWith("on_")
      ))) {
        this.#handlers[name.slice(3)] = this[name]
      };

      this.#state = null;
      this.#block_this = null;
      this.#block_depth = null;
      this.#prop = null;
      this.#instance_method = null;
      this.#prototype = null;
      this.#class_parent = null;
      this.#class_name = null;
      this.#jsx = false;
      this.#autobind = true;
      this.#eslevel = "es5";
      this.#strict = false;
      this.#comparison = "equality";
      this.#or = "logical";
      this.#underscored_private = true;
      this.#redoable = false
    };

    set width(width) {
      // Find last index where block returns true
      // indent multi-line parameter lists, array constants, blocks
      return this._width = width
    };

    // add horizontal (indentation) and vertical (blank lines) whitespace
    convert() {
      // before a comment
      // start of indented block
      // end of indented block
      // add a single token to the current line
      this.scope(this.#ast);

      // add a single token to the current line without checking for newline
      if (this.#strict) {
        // add a single token to the current line and then advance to next line
        // advance to next line and then add a single token to the current line
        return this._sep == "; " ? this._lines[0].unshift(`"use strict"${this._sep}`) : this._lines.unshift(new Line("\"use strict\";"))
      }
    };

    operator_index(op) {
      // current location: [line number, token number]
      // insert a line into the output
      return Converter.OPERATORS.indexOf(Converter.OPERATORS.find(el => (
        el.includes(op)
      ))) || -1
    };

    // define a new scope; primarily determines what variables are visible and deals with hoisting of
    // declarations
    scope(ast, args=null) {
      // capture (and remove) tokens from the output stream
      {
        let scope;
        let inner;

        try {
          // Remove lines from mark.first+1 to end
          // Splice tokens from current line
          scope = this.#scope;

          // Also need to grab tokens from current line
          this.#scope = ast;

          // wrap long statements in curly braces
          // Replace last token of line with popped line's tokens
          inner = this.#inner;

          // Remove the last token
          this.#inner = null;
          let mark = this.output_location();
          this.#varstack.push(this.#vars);
          if (args) this.#vars = args;

          this.#vars = Object.fromEntries(Object.entries(this.#vars).map(([key, value]) => (
            [key, true]
          )));

          // compact small expressions into a single line
          this.parse(ast, "statement");

          let vars = Object.entries(this.#vars).filter(([key, value]) => (
            value == "pending"
          )).map(e => e[0]);

          // survey what we have to work with, keeping track of a possible
          // split of the last argument or value
          if (vars.length != 0) {
            // comments are a deal breaker
            this.insert(
              mark,
              `${this.es2015 ? "let" : "var"} ${vars.join(", ")}${this._sep}`
            );

            for (let var_ of vars) {
              this.#vars[var_] = true
            }
          }
        } finally {
          this.#vars = this.#varstack.pop();
          this.#scope = scope;
          this.#inner = inner
        }
      }
    };

    // retroactively add a declaration for 'pending' variables
    // handle the oddity where javascript considers there to be a scope (e.g. the body of an if statement),
    // whereas Ruby does not.
    jscope(ast, args=null) {
      // full collapse - replace from mark.first to end with single line
      try {
        this.#varstack.push(this.#vars);
        if (args) this.#vars = args;

        this.#vars = Object.fromEntries(Object.entries(this.#vars).map(([key, value]) => (
          [key, true]
        )));

        // collapse all but the last argument (typically a hash or function)
        this.parse(ast, "statement")
      } finally {
        let pending = Object.fromEntries(Object.entries(this.#vars).filter(([key, value]) => (
          value == "pending"
        )));

        this.#vars = this.#varstack.pop();

        // Replace from mark.first+1 to end with remaining slice
        Object.assign(this.#vars, pending)
      }
    };

    s(type, ...args) {
      return null
    };

    get strict() {
      return this.#strict
    };

    set strict(strict) {
      this.#strict = strict
    };

    get eslevel() {
      return this.#eslevel
    };

    set eslevel(eslevel) {
      this.#eslevel = eslevel
    };

    get module_type() {
      return this.#module_type
    };

    set module_type(module_type) {
      this.#module_type = module_type
    };

    get comparison() {
      return this.#comparison
    };

    set comparison(comparison) {
      this.#comparison = comparison
    };

    get or() {
      return this.#or
    };

    set or(or) {
      this.#or = or
    };

    get underscored_private() {
      return this.#underscored_private
    };

    set underscored_private(underscored_private) {
      this.#underscored_private = underscored_private
    };

    get es2015() {
      // return the output as a string
      // https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit
      // http://sokra.github.io/source-map-visualization/
      // Copy mark values
      return this.#eslevel >= 2_015
    };

    get es2016() {
      // workaround https://github.com/opal/opal/issues/575
      return this.#eslevel >= 2_016
    };

    get es2017() {
      return this.#eslevel >= 2_017
    };

    get es2018() {
      return this.#eslevel >= 2_018
    };

    get es2019() {
      return this.#eslevel >= 2_019
    };

    get es2020() {
      return this.#eslevel >= 2_020
    };

    get es2021() {
      return this.#eslevel >= 2_021
    };

    get es2022() {
      return this.#eslevel >= 2_022
    };

    get es2023() {
      return this.#eslevel >= 2_023
    };

    get es2024() {
      return this.#eslevel >= 2_024
    };

    get es2025() {
      return this.#eslevel >= 2_025
    };

    static handle() {
      let types = Array.prototype.slice.call(
        arguments,
        1,
        arguments.length - 1
      );

      let block = arguments[arguments.length - 1];

      if (arguments.length <= 0) {
        block = null
      } else if (typeof block !== "function") {
        types.push(block);
        block = null
      };

      for (let type of types) {
        define_method(`on_${type}`, block);
        Converter.#$handlers.push(type)
      }
    };

    // extract comments that either precede or are included in the node.
    // remove from the list so this node's comments won't appear again later in the tree.
    comments(ast) {
      let list;
      let [comment_list, comment_key] = this.find_comment_entry(ast);

      if (ast.loc && typeof ast.loc === "object" && ast.loc !== null && "expression" in ast.loc) {
        let expression = ast.loc.expression;

        list = comment_list.filter(comment => (
          expression.source_buffer == comment.loc.expression.source_buffer && comment.loc.expression.begin_pos < expression.end_pos
        ))
      } else {
        list = comment_list
      };

      if (this.#comments.has(comment_key) && this.#comments[comment_key]) {
        this.#comments[comment_key] -= list
      };

      return list.map((comment) => {
        if (comment.text.startsWith("=begin")) {
          return comment.text.includes("*/") ? comment.text.replace(
            /^=begin/,
            ""
          ).replace(/^=end\Z/m, "").replaceAll(/^/gm, "//") : comment.text.replace(
            /^=begin/,
            "/*"
          ).replace(/^=end\Z/m, "*/")
        } else {
          return comment.text.replace(/^#/m, "//") + "\n"
        }
      })
    };

    // Find comments for an AST node using multiple lookup strategies:
    // 1. Direct lookup by object identity
    // 2. Location-based lookup (for nodes recreated by filters with same location)
    // 3. First-child location lookup (for synthetic nodes wrapping real content)
    // Returns [comment_list, comment_key] where comment_key is used for removal
    find_comment_entry(ast) {
      // First try direct lookup by object identity
      let comment_list = this.#comments[ast];
      if (comment_list && comment_list.length != 0) return [comment_list, ast];

      // If ast has location info, try location-based lookup
      // This handles cases where filters created new nodes with same location
      if (ast.loc && typeof ast.loc === "object" && ast.loc !== null && "expression" in ast.loc && ast.loc.expression) {
        let expression = ast.loc.expression;

        for (let [key, value] of this.#comments) {
          if (key == "_raw" || value == null || value.length == 0) continue;

          if (typeof key !== "object" || !key !== null || !("loc" in key) || typeof key.loc !== "object" || !key.loc !== null || !("expression" in key.loc)) {
            continue
          };

          let key_expr = key.loc.expression;
          if (!key_expr) continue;

          if (key_expr.source_buffer == expression.source_buffer && key_expr.begin_pos == expression.begin_pos && key_expr.end_pos == expression.end_pos) {
            return [value, key]
          }
        }
      };

      // For synthetic nodes (no location), try to find comments via first child with location
      if (!ast.loc || typeof ast.loc !== "object" || !ast.loc !== null || !("expression" in ast.loc) || !ast.loc.expression) {
        let first_loc = this.find_first_location(ast);

        if (first_loc) {
          for (let [key, value] of this.#comments) {
            if (key == "_raw" || value == null || value.length == 0) continue;

            if (typeof key !== "object" || !key !== null || !("loc" in key) || typeof key.loc !== "object" || !key.loc !== null || !("expression" in key.loc)) {
              continue
            };

            let key_expr = key.loc.expression;
            if (!key_expr || key_expr.source_buffer != first_loc.source_buffer) continue;

            // If the key starts at or near where our content starts, use its comments
            if (key_expr.begin_pos <= first_loc.begin_pos + 1) return [value, key]
          }
        }
      };

      // If no first_loc (empty synthetic node), don't try to find comments
      return [[], ast]
    };

    // Find the first source location in an AST tree (depth-first)
    find_first_location(ast) {
      if (typeof ast !== "object" || !ast !== null || !("children" in ast)) {
        return null
      };

      if (ast.loc && typeof ast.loc === "object" && ast.loc !== null && "expression" in ast.loc && ast.loc.expression) {
        return ast.loc.expression
      };

      for (let child of ast.children) {
        if (typeof child !== "object" || !child !== null || !("type" in child) || typeof child !== "object" || !child !== null || !("children" in child)) {
          continue
        };

        let loc = this.find_first_location(child);
        if (loc) return loc
      };

      return null
    };

    parse(ast, state="expression") {
      {
        let oldast;
        let oldstate;

        try {
          oldstate = this.#state;
          this.#state = state;
          oldast = this.#ast;
          this.#ast = ast;
          if (!ast) return;
          let handler = this.#handlers[ast.type];
          if (!handler) throw new Error(`unknown AST type ${ast.type}`, ast);

          if (state == "statement") {
            for (let comment of this.comments(ast)) {
              this.puts(comment.chomp)
            }
          };

          handler.call(this, ...ast.children)
        } finally {
          this.#ast = oldast;
          this.#state = oldstate
        }
      }
    };

    parse_all(...args) {
      this.#options = typeof args.at(-1) === "object" && args.at(-1) !== null && !args.at(-1).type ? args.pop() : {};
      let sep = (this.#options.join || "").toString();
      let state = this.#options.state || "expression";
      let index = 0;

      for (let arg of args) {
        if (index != 0) this.put(sep);
        this.parse(arg, state);
        if (arg != this.s("begin")) index++
      }
    };

    group(ast) {
      if (["dstr", "dsym"].includes(ast.type) && this.es2015) {
        return this.parse(ast)
      } else {
        this.put("(");
        this.parse(ast);
        return this.put(")")
      }
    };

    redoable(block) {
      {
        let save_redoable;

        try {
          save_redoable = this.#redoable;

          let has_redo = node => (
            node.children.some((child) => {
              if (typeof child !== "object" || !child !== null || !("type" in child) || typeof child !== "object" || !child !== null || !("children" in child)) {
                return false
              };

              if (child.type === "redo") return true;

              if (["for", "while", "while_post", "until", "until_post"].includes(child.type)) {
                return false
              };

              return has_redo[child]
            })
          );

          this.#redoable = has_redo[this.#ast];

          if (this.#redoable) {
            this.put(this.es2015 ? "let " : "var ");
            this.put(`redo$${this._sep}`);
            this.puts("do {");
            this.put(`redo$ = false${this._sep}`);
            this.scope(block);
            this.put(`${this._nl}} while(redo$)`)
          } else {
            this.scope(block)
          }
        } finally {
          this.#redoable = save_redoable
        }
      }
    };

    timestamp(file) {
      super.timestamp(file);
      if (!file) return;

      let walk = (ast) => {
        if (ast.loc && typeof ast.loc === "object" && ast.loc !== null && "expression" in ast.loc && ast.loc.expression) {
          let filename = ast.loc.expression.source_buffer.name;

          if (filename && filename.length != 0) {
            this.#timestamps[filename] ||= (() => {
              try {
                File.mtime(filename)
              } catch {
                null
              }
            })()
          }
        };

        for (let child of ast.children) {
          if (typeof child === "object" && child !== null && "type" in child && typeof child === "object" && child !== null && "children" in child) {
            walk[child]
          }
        }
      };

      if (this.#ast) return walk[this.#ast]
    };

    // Add is_method? to Parser::AST::Node for distinguishing method calls from property access
    // Only do this if the Parser gem has been loaded
    on_str(value) {
      // see https://github.com/whitequark/parser/blob/master/doc/AST_FORMAT.md
      this.put(JSON.stringify(value))
    };

    // (int 1)
    // (float 1.1)
    // (str "1"))
    on_int(value) {
      this.put(this.number_format(value))
    };

    on_float(value) {
      this.put(this.number_format(value))
    };

    on_octal(value) {
      this.put("0" + this.number_format(value.toString(8)))
    };

    number_format(number) {
      if (!this.es2021) return number.toString();
      let parts = number.toString().split(".");
      parts[0] = parts[0].replaceAll(/(\d)(?=(\d\d\d)+(?!\d))/g, "$1_");
      if (parts[1]) parts[1] = parts[1].replaceAll(/(\d\d\d)(?=\d)/g, "$1_");
      return parts.join(".")
    };

    // (nil)
    on_nil() {
      this.put("null")
    };

    // (true)
    // (false)
    on_true() {
      this.put(this.#ast.type.toString())
    };

    on_false() {
      this.put(this.#ast.type.toString())
    };

    // (self)
    on_self() {
      if (this.#block_depth && this.#block_depth > 1) {
        this.#block_this = true;
        this.put("self")
      } else {
        this.put("this")
      }
    };

    // (sym :sym))
    on_sym(sym) {
      this.put(JSON.stringify(sym.toString()))
    };

    // (lvar :a)
    // (gvar :$a)
    on_lvar(var_) {
      if (var_ == "$!") {
        this.put("$EXCEPTION")
      } else {
        this.put(var_)
      }
    };

    on_gvar(var_) {
      if (var_ == "$!") {
        this.put("$EXCEPTION")
      } else {
        this.put(var_)
      }
    };

    // (lvasgn :a
    //   (int 1))
    // (gvasgn :$a
    //   (int 1))
    on_lvasgn(name, value=null) {
      let receiver;

      if (this.#ast.type === "lvasgn" && value) {
        // Only treat as setter if name is NOT already a local variable
        // and not marked as :masgn (from parallel assignment like `scope, @scope = ...`)
        // This handles cases where `scope` should be a new local var, not a call to self.scope=
        // Skip setter lookup if: already a real local var, or marked from parallel assignment
        if (this.#vars[name] != true && this.#vars[name] != "masgn") {
          receiver = this.#rbstack.map(rb => rb[name]).filter(x => x != null).at(-1);
          if (receiver) return this.parse(this.s("attr", receiver, `${name}=`, value))
        }
      };

      let state = this.#state;

      {
        let var_;

        if (value && value.type === "lvasgn" && this.#state == "statement") {
          let undecls = [];
          if (!(name in this.#vars)) undecls.push(name);
          let child = value;

          while (child && child.type === "lvasgn") {
            if (!(child.children[0] in this.#vars)) undecls.push(child.children[0]);
            child = child.children[1]
          };

          if (undecls.length != 0) {
            if (this.es2015) {
              this.put("let ")
            } else {
              this.put("var ")
            };

            this.put(undecls.map(item => item.toString()).join(", ") + this._sep);

            for (let var_ of undecls) {
              this.#vars[var_] = true
            }
          }
        };

        let hoist = false;

        // Treat :masgn marker as "not yet declared" for purposes of adding let/var
        let is_declared = name in this.#vars && this.#vars[name] != "masgn";

        if (state == "statement" && !is_declared) {
          if (this.#inner && this.#scope != this.#inner) {
            hoist = this.is_hoist(this.#scope, this.#inner, name)
          };

          if (!hoist) {
            if (this.es2015) {
              var_ = "let "
            } else {
              var_ = "var "
            }
          }
        };

        if (value) {
          this.put(`${var_}${name} = `);
          this.parse(value)
        } else {
          this.put(`${var_}${name}`)
        };

        if (!hoist) {
          this.#vars[name] ||= true
        } else if (state == "statement") {
          this.#vars[name] ||= "pending"
        } else {
          this.#vars[name] ||= "implicit"
        }
      }
    };

    on_gvasgn(name, value=null) {
      let receiver;

      if (this.#ast.type === "lvasgn" && value) {
        if (this.#vars[name] != true && this.#vars[name] != "masgn") {
          receiver = this.#rbstack.map(rb => rb[name]).filter(x => x != null).at(-1);
          if (receiver) return this.parse(this.s("attr", receiver, `${name}=`, value))
        }
      };

      let state = this.#state;

      {
        let var_;

        if (value && value.type === "lvasgn" && this.#state == "statement") {
          let undecls = [];
          if (!(name in this.#vars)) undecls.push(name);
          let child = value;

          while (child && child.type === "lvasgn") {
            if (!(child.children[0] in this.#vars)) undecls.push(child.children[0]);
            child = child.children[1]
          };

          if (undecls.length != 0) {
            if (this.es2015) {
              this.put("let ")
            } else {
              this.put("var ")
            };

            this.put(undecls.map(item => item.toString()).join(", ") + this._sep);

            for (let var_ of undecls) {
              this.#vars[var_] = true
            }
          }
        };

        let hoist = false;
        let is_declared = name in this.#vars && this.#vars[name] != "masgn";

        if (state == "statement" && !is_declared) {
          if (this.#inner && this.#scope != this.#inner) {
            hoist = this.is_hoist(this.#scope, this.#inner, name)
          };

          if (!hoist) {
            if (this.es2015) {
              var_ = "let "
            } else {
              var_ = "var "
            }
          }
        };

        if (value) {
          this.put(`${var_}${name} = `);
          this.parse(value)
        } else {
          this.put(`${var_}${name}`)
        };

        if (!hoist) {
          this.#vars[name] ||= true
        } else if (state == "statement") {
          this.#vars[name] ||= "pending"
        } else {
          this.#vars[name] ||= "implicit"
        }
      }
    };

    // console, document, ...
    // is 'name' referenced outside of inner scope?
    is_hoist(outer, inner, name) {
      for (let var_ of outer.children) {
        if (var_ == inner) continue;
        if (var_ == name && ["lvar", "gvar"].includes(outer.type)) return true;

        if (typeof var_ === "object" && var_ !== null && "type" in var_ && typeof var_ === "object" && var_ !== null && "children" in var_ && this.is_hoist(
          var_,
          inner,
          name
        )) return true
      };

      return false
    };

    get multi_assign_declarations() {
      let undecls = [];
      let child = this.#ast;

      while (true) {
        let subchild;

        if (["send", "casgn"].include(child.type)) {
          subchild = child.children[2]
        } else {
          subchild = child.children[1]
        };

        if (subchild.type == "send") {
          if (!/=$/m.test(subchild.children[1])) break
        } else if (!["send", "cvasgn", "ivasgn", "gvasgn", "lvasgn"].include(subchild.type)) {
          break
        };

        child = subchild;

        if (child.type == "lvasgn" && !this.#vars.include(child.children[0])) {
          undecls.push(child.children[0])
        }
      };

      if (undecls.length != 0) {
        if (this.es2015) {
          this.put("let ")
        } else {
          this.put("var ")
        };

        return this.put(`${undecls.map(item => item.toString()).join(", ")}${this._sep}`)
      }
    };

    // (ivar :@a)
    on_ivar(var_) {
      if (this.ivars?.includes(var_)) {
        this.parse(this.s("hostvalue", this.ivars[var_]))
      } else if (this.underscored_private) {
        this.parse(this.s(
          "attr",
          this.s("self"),
          var_.toString().replace("@", "_")
        ))
      } else {
        this.parse(this.s(
          "attr",
          this.s("self"),
          var_.toString().replace("@", "#")
        ))
      }
    };

    on_hostvalue(value) {
      switch (value) {
      case Hash:

        this.parse(this.s("hash", ...value.map((key, hvalue) => {
          switch (key) {
          case String:

            return this.s(
              "pair",
              this.s("str", key),
              this.s("hostvalue", hvalue)
            );

          case Symbol:

            return this.s(
              "pair",
              this.s("sym", key),
              this.s("hostvalue", hvalue)
            );

          default:

            return this.s(
              "pair",
              this.s("hostvalue", key),
              this.s("hostvalue", hvalue)
            )
          }
        })));

        break;

      case Array:

        this.parse(this.s(
          "array",
          ...value.map(hvalue => this.s("hostvalue", hvalue))
        ));

        break;

      case String:
        this.parse(this.s("str", value));
        break;

      case Integer:
        this.parse(this.s("int", value));
        break;

      case Float:
        this.parse(this.s("float", value));
        break;

      case true:
        this.parse(this.s("true"));
        break;

      case false:
        this.parse(this.s("false"));
        break;

      case null:
        this.parse(this.s("nil"));
        break;

      case Symbol:
        this.parse(this.s("sym", value));
        break;

      default:

        if (typeof value === "object" && value !== null && "as_json" in value) {
          value = value.as_json
        };

        if (typeof value === "object" && value !== null && "to_hash" in value && typeof value.to_hash === "object" && value.to_hash !== null && !value.to_hash.type) {
          this.parse(this.s("hostvalue", value.to_hash))
        } else if (typeof value === "object" && value !== null && "to_ary" in value && Array === value.to_ary) {
          this.parse(this.s("hostvalue", value.to_ary))
        } else if (typeof value === "object" && value !== null && "to_str" in value && String === value.to_str) {
          this.parse(this.s("str", value.to_str))
        } else if (typeof value === "object" && value !== null && "to_int" in value && Integer === value.to_int) {
          this.parse(this.s("int", value.to_int))
        } else if (typeof value === "object" && value !== null && "to_sym" in value && Symbol === value.to_sym) {
          this.parse(this.s("sym", value.to_sym))
        } else {
          this.parse(this.s("str", JSON.stringify(value)))
        }
      }
    };

    // (ivasgn :@a
    //   (int 1))
    on_ivasgn(var_, expression=null) {
      if (this.#state == "statement") this.multi_assign_declarations;

      this.put(`${var_.toString().replace(
        "@",
        "this." + (this.underscored_private ? "_" : "#")
      )}`);

      if (expression) {
        this.put(" = ");
        this.parse(expression)
      }
    };

    // (array
    //   (int 1)
    //   (int 2))
    on_array(...items) {
      let splat = (() => {
        let _i = items.findLastIndex(a => a.type === "splat");
        return _i >= 0 ? _i : null
      })();

      if (splat && items.length == 1 || !this.es2015) {
        let item = items[splat].children[0];

        if (items.length == 1) {
          this.parse(item)
        } else if (splat == items.length - 1) {
          this.parse(this.s(
            "send",
            this.s("array", ...items.slice(0, -1)),
            "concat",
            item
          ))
        } else if (splat == 0) {
          this.parse(this.s(
            "send",
            item,
            "concat",
            this.s("array", ...items.slice(1))
          ))
        } else {
          this.parse(this.s(
            "send",

            this.s(
              "send",
              this.s("array", ...items.slice(0, splat - 1 + 1)),
              "concat",
              item
            ),

            "concat",
            this.s("array", ...items.slice(splat + 1))
          ))
        }
      } else if (items.length <= 1) {
        this.put("[");
        this.parse_all(...items, {join: ", "});
        this.put("]")
      } else {
        this.compact(() => {
          this.puts("[");
          this.parse_all(...items, {join: `,${this._ws}`});
          return this.sput("]")
        })
      }
    };

    // (hash
    //   (pair
    //     (sym :name)
    //     (str "value")))
    on_hash(...pairs) {
      if (!this.es2018 && pairs.some(pair => pair.type === "kwsplat")) {
        let groups = [];
        let pending = [];

        while (pairs.length != 0) {
          let pair = pairs.shift();

          if (pair.type != "kwsplat") {
            pending.push(pair)
          } else {
            if (pending.length != 0) groups.push(this.s("hash", ...pending));
            groups.push(pair.children[0]);
            pending = []
          }
        };

        if (pending.length != 0) groups.push(this.s("hash", ...pending));
        this.parse(this.s("assign", this.s("hash"), ...groups));
        return
      };

      this.compact(() => {
        let singleton = pairs.length <= 1;

        if (singleton) {
          this.put("{")
        } else {
          this.puts("{")
        };

        let index = 0;

        while (pairs.length > 0) {
          let node = pairs.shift();

          if (index != 0) {
            if (singleton) {
              this.put(", ")
            } else {
              this.put(`,${this._ws}`)
            }
          };

          index++;

          if (node.type === "kwsplat") {
            if (this.es2018) {
              if (node.children[0].type === "hash") {
                pairs.unshift(...node.children[0].children);
                index = 0
              } else {
                this.put("...");
                this.parse(node.children[0])
              };

              continue
            } else {
              throw new Error("kwsplat", this.#ast)
            }
          };

          let node_comments = this.#comments[node];

          if (node_comments && node_comments.length != 0) {
            if (singleton) {
              this.puts("");
              singleton = false
            };

            for (let comment of this.comments(node)) {
              this.put(comment)
            }
          };

          {
            let block_hash;
            let block_depth;

            try {
              let receiver, method;
              [block_depth, block_hash] = [this.#block_depth, false];
              let [left, right] = node.children;

              if (typeof right === "object" && right !== null && !right.type || right.type === "block") {
                block_hash = true;
                if (!this.#block_depth) this.#block_depth = 0
              };

              if (left.type === "prop") {
                if (right.get) {
                  let get_comments = this.#comments[right.get];

                  if (get_comments != null && get_comments.length != 0) {
                    if (singleton) {
                      this.puts("");
                      singleton = false
                    };

                    for (let comment of this.comments(right.get)) {
                      this.put(comment)
                    }
                  };

                  this.#prop = `get ${left.children[0]}`;
                  this.parse(right.get);

                  if (right.set) {
                    if (singleton) {
                      this.put(", ")
                    } else {
                      this.put(`,${this._ws}`)
                    }
                  }
                };

                if (right.set) {
                  let set_comments = this.#comments[right.set];

                  if (set_comments != null && set_comments.length != 0) {
                    if (singleton) {
                      this.puts("");
                      singleton = false
                    };

                    for (let comment of this.comments(right.set)) {
                      this.put(comment)
                    }
                  };

                  this.#prop = `set ${left.children[0]}`;
                  this.parse(right.set)
                }
              } else {
                if (right.type === "hash") {
                  for (let pair of right.children) {
                    let pair_child = pair.children.at(-1);

                    if (typeof pair_child !== "object" || !pair_child !== null || !("type" in pair_child) || typeof pair_child !== "object" || !pair_child !== null || !("children" in pair_child)) {
                      continue
                    };

                    if (["block", "def", "defm", "async"].includes(pair_child.type)) {
                      if (this.#comments[pair_child]) {
                        if (singleton) {
                          this.puts("");
                          singleton = false
                        };

                        for (let comment of this.comments(pair_child)) {
                          this.put(comment)
                        }
                      }
                    }
                  }
                };

                let anonfn = this.es2015 && right && right.type === "block";

                if (anonfn) {
                  let [receiver, method] = right.children[0].children;

                  if (receiver) {
                    if (method != "new" || receiver.children != [null, "Proc"]) anonfn = false
                  } else if (!["lambda", "proc"].includes(method)) {
                    anonfn = false
                  };

                  if (anonfn && this.#class_name) {
                    let walk = (ast) => {
                      if (ast == this.s("self")) {
                        anonfn = false
                      } else if (["ivar", "ivasgn"].includes(ast.type)) {
                        anonfn = false
                      } else if (ast.type === "send" && ast.children[0] == null) {
                        if (ast.children.length == 2) method = ast.children.at(-1);
                        if (this.#rbstack.some(rb => rb[method]) || method == "this") anonfn = false
                      };

                      for (let child of ast.children) {
                        if (typeof child === "object" && child !== null && "type" in child && typeof child === "object" && child !== null && "children" in child) {
                          walk[child]
                        }
                      }
                    };

                    walk[right]
                  }
                };

                if (anonfn && /^[a-zA-Z_$][a-zA-Z_$0-9]*$/.test(left.children[0].toString())) {
                  this.#prop = left.children[0];
                  this.parse(right, "method")
                } else if (this.es2015 && left.type === "sym" && right.type === "lvar" || right.type === "send" && right.children[0] == null && left.children.at(-1) == right.children.at(-1)) {
                  this.parse(right)
                } else if (right.type === "defm" && ["sym", "str"].includes(left.type) && this.es2015) {
                  this.#prop = left.children[0].toString();
                  this.parse(right)
                } else {
                  if (!["str", "sym"].includes(left.type) && this.es2015) {
                    this.put("[");
                    this.parse(left);
                    this.put("]")
                  } else if (/^[a-zA-Z_$][a-zA-Z_$0-9]*$/.test(left.children[0].toString())) {
                    this.put(left.children[0])
                  } else {
                    this.parse(left)
                  };

                  this.put(": ");
                  this.parse(right)
                }
              }
            } finally {
              if (block_hash) this.#block_depth = block_depth
            }
          }
        };

        // hoist get/set comments to definition of property
        // check to see if es2015 anonymous function syntax can be used
        // use fat arrow syntax if block contains a reference to 'this'
        return singleton ? this.put("}") : this.sput("}")
      })
    };

    // (args
    //   (arg :a)
    //   (restarg :b)
    //   (blockarg :c))
    on_args(...args) {
      let kwargs = [];

      while (args.at(-1) && ["kwarg", "kwoptarg", "kwrestarg"].includes(args.at(-1).type)) {
        kwargs.unshift(args.pop())
      };

      if (kwargs.length == 1 && kwargs.at(-1).type === "kwrestarg") {
        args.push(this.s("arg", ...kwargs.at(-1).children))
      };

      if (kwargs.length != 0 && !this.es2015) {
        throw new NotImplementedError("Keyword args require ES2015")
      };

      this.parse_all(...args, {join: ", "});

      if (kwargs.length != 0) {
        if (args.length != 0) this.put(", ");
        this.put("{ ");

        kwargs.forEach((kw, index) => {
          if (index != 0) this.put(", ");

          if (kw.type === "kwarg") {
            return this.put(kw.children[0])
          } else if (kw.type === "kwoptarg") {
            this.put(kw.children[0]);

            if (kw.children.at(-1) != this.s("send", null, "undefined")) {
              this.put("=");
              return this.parse(kw.children.at(-1))
            }
          } else if (kw.type === "kwrestarg") {
            if (!this.es2018) throw "Rest arg requires ES2018";
            this.put("...");
            return this.put(kw.children[0])
          }
        });

        this.put(" }");
        if (!kwargs.some(kw => kw.type === "kwarg")) this.put(" = {}")
      }
    };

    on_mlhs(...args) {
      if (this.es2015 || this.#jsx) {
        this.put("[");
        this.parse_all(...args, {join: ", "});
        this.put("]")
      } else {
        throw new Error("destructuring requires ES2015", this.#ast)
      }
    };

    // Ruby 2.7+ argument forwarding: def foo(...) / bar(...)
    on_forward_args() {
      this.put("...args")
    };

    on_forwarded_args() {
      this.put("...args")
    };

    // (arg :a)
    // (blockarg :b)
    // NOTE: process_all appends a nil child for unknown reasons
    on_arg(arg, unknown=null) {
      if (unknown) throw new Error(`argument ${JSON.stringify(unknown)}`, this.#ast);
      this.put(arg)
    };

    on_blockarg(arg, unknown=null) {
      if (unknown) throw new Error(`argument ${JSON.stringify(unknown)}`, this.#ast);
      this.put(arg)
    };

    // (shadowarg :a)
    on_shadowarg(arg, unknown=null) {
      if (unknown) throw new Error(`argument ${JSON.stringify(unknown)}`, this.#ast);
      null
    };

    // (send nil :puts
    //   (int 1))
    // (attr nil :puts)
    // (sendw nil :puts
    //   (int 1))
    // Note: attr, sendw, send!, and await are only generated by filters.  Attr forces
    // interpretation as an attribute vs a function call with zero parameters.
    // send! forces interpretation as a method call even with zero parameters.
    // Sendw forces parameters to be placed on separate lines.
    on_send(receiver, method, ...args) {
      let t2, m2, args2, block, target, group_receiver, group_target, opts;
      this.ast = this.#ast;

      if (args.length == 1 && method == "+") {
        let node = this.collapse_strings(ast);
        if (node != ast) return this.parse(node)
      };

      // :irange support
      // - currently only .to_a
      if (receiver && receiver.type === "begin" && ["irange", "erange"].includes(receiver.children[0].type)) {
        if (method == "to_a") {
          return this.range_to_array(receiver.children[0])
        } else {
          throw new Error(`${receiver.children[0].type} can only be converted to array currently`, receiver.children[0])
        }
      };

      // strip '!' and '?' decorations
      if (/\w[!?]$/m.test(method)) method = method.toString().slice(0, -1);

      // anonymous class
      if (method == "new" && receiver && receiver.children == [
        null,
        "Class"
      ] && args.at(-1).type === "def" && args.at(-1).children[0] == null) {
        let parent = args.length > 1 ? args[0] : null;

        if (this.es2015) {
          return this.parse(this.s(
            "class2",
            null,
            parent,
            ...args.at(-1).children.slice(2)
          ))
        } else {
          return this.parse(this.s(
            "kwbegin",

            this.s(
              "class",
              this.s("const", null, "$$"),
              parent,
              ...args.at(-1).children.slice(2)
            ),

            this.s("const", null, "$$")
          ))
        }
      };

      // three ways to define anonymous functions
      if (method == "new" && receiver && receiver.children == [
        null,
        "Proc"
      ]) {
        return this.parse(args[0], this.#state)
      } else if (!receiver && ["lambda", "proc"].includes(method)) {
        if (method == "lambda" && this.#state != "statement") {
          return this.parse(
            this.s(
              args[0].type,
              ...args[0].children.slice(0, -1),
              this.s("autoreturn", args[0].children.at(-1))
            ),

            this.#state
          )
        } else {
          return this.parse(args[0], this.#state)
        }
      };

      // call anonymous function
      if (["call", "[]"].includes(method) && receiver && receiver.type === "block") {
        let [t2, m2, ...args2] = receiver.children[0].children;

        if (!t2 && ["lambda", "proc"].includes(m2) && args2.length == 0) {
          if (this.es2015 || this.#state == "statement") {
            this.group(receiver)
          } else {
            this.parse(receiver)
          };

          this.put("(");
          this.parse_all(...args, {join: ", "});
          this.put(")");
          return
        } else if (!t2 && m2 == "async" && args2.length == 0) {
          this.put("(");
          this.parse(receiver);
          this.put(")()");
          return
        }
      };

      // async/await support
      // map "await x do...end" to "await x {...}" due to precedence rules
      if (method == "await" && this.es2017 && receiver == null && args.length == 2 && args[1].type === "def") {
        args = [this.s("block", args[0], ...args.at(-1).children.slice(1))]
      };

      if (this.es2017 && receiver == null && args.length == 1) {
        if (method == "async") {
          if (args[0].type === "def") {
            // async def f(x) {...}
            return this.parse(args[0].updated("async"))
          } else if (args[0].type === "defs") {
            // async def o.m(x) {...}
            return this.parse(args[0].updated("asyncs"))
          } else if (args[0].type === "send" && args[0].children[0].type === "block" && args[0].children.at(-1) == "[]") {
            this.put("(async ");
            this.parse(args[0].children[0], "statement");
            this.put(")()");
            return
          } else if (args[0].type === "block") {
            block = args[0];

            if (block.children[0].children.at(-1) == "lambda") {
              // async lambda {|x| ... }
              // async -> (x) { ... }
              return this.parse(block.updated(
                "async",
                [null, block.children[1], this.s("autoreturn", block.children[2])]
              ))
            } else if (block.children[0].children.at(-1) == "proc") {
              // async proc {|x| ... }
              return this.parse(block.updated(
                "async",
                [null, ...block.children.slice(1)]
              ))
            } else if (block.children[0].children[1] == "new" && block.children[0].children[0] == this.s(
              "const",
              null,
              "Proc"
            )) {
              return this.parse(block.updated(
                "async",
                [null, ...block.children.slice(1)]
              ))
            }
          }
        } else if (method == "await") {
          if (args[0].type === "send") {
            // await f(x)
            return this.parse(args[0].updated("await"))
          } else if (args[0].type === "block") {
            // await f(x) { ... }
            block = args[0];

            return this.parse(block.updated(
              null,
              [block.children[0].updated("await"), ...block.children.slice(1)]
            ))
          }
        }
      };

      let op_index = this.operator_index(method);
      if (op_index != -1) target = args[0];

      // resolve anonymous receivers against rbstack
      receiver ||= this.#rbstack.map(rb => rb[method]).filter(x => x != null).at(-1);
      let autobind = null;

      if (receiver) {
        if (receiver.type === "autobind") {
          autobind = receiver = receiver.children[0];

          // async Proc.new {|x| ... }
          if (!this.#autobind) autobind = null
        };

        if (receiver) {
          group_receiver = receiver.type === "send" && op_index < this.operator_index(receiver.children[1])
        };

        group_receiver ||= Converter.GROUP_OPERATORS.includes(receiver.type);
        if (receiver.children[1] == "[]") group_receiver = false;

        if (receiver.type === "int" && !Converter.OPERATORS.flat(Infinity).includes(method)) {
          group_receiver = true
        };

        if (!receiver.is_is_method() && receiver.children.at(-1) == "new") {
          group_receiver = true
        }
      };

      if (target) {
        group_target = target.type === "send" && op_index < this.operator_index(target.children[1]);
        group_target ||= Converter.GROUP_OPERATORS.includes(target.type)
      };

      if (this.#ast.type === "await") this.put("await ");

      if (method == "!") {
        this.parse(this.s("not", receiver))
      } else if (method == "[]") {
        if (group_receiver) {
          this.group(receiver)
        } else {
          this.parse(receiver)
        };

        if (args.length == 1 && ["str", "sym"].includes(args[0].type) && /^[a-zA-Z]\w*$/m.test(args[0].children[0].toString())) {
          this.put(`.${args[0].children[0]}`)
        } else {
          this.put("[");
          this.parse_all(...args, {join: ", "});
          this.put("]")
        }
      } else if (method == "[]=") {
        if (group_receiver) {
          this.group(receiver)
        } else {
          this.parse(receiver)
        };

        if (args.length == 2 && ["str", "sym"].includes(args[0].type) && /^[a-zA-Z]\w*$/m.test(args[0].children[0].toString())) {
          this.put(`.${args[0].children[0]} = `)
        } else {
          this.put("[");
          this.parse_all(...args.slice(0, -1), {join: ", "});
          this.put("] = ")
        };

        this.parse(args.at(-1))
      } else if (method == "**" && !this.es2016) {
        this.put("Math.pow(");
        this.parse(receiver);
        this.put(", ");
        this.parse(args[0]);
        this.put(")")
      } else if (["-@", "+@", "~", "~"].includes(method)) {
        let child0 = receiver.children[0];

        if (receiver.type === "send" && receiver.children[1] == "+@" && typeof child0 === "object" && child0 !== null && "type" in child0 && typeof child0 === "object" && child0 !== null && "children" in child0 && [
          "class",
          "module"
        ].includes(child0.type)) {
          if (receiver.children[0].type === "class") {
            this.parse(receiver.children[0].updated("class_extend"))
          } else {
            let mod = receiver.children[0];

            this.parse(this.s(
              "assign",
              mod.children[0],
              mod.updated(null, [null, ...mod.children.slice(1)])
            ))
          }
        } else {
          this.put(method.toString()[0]);
          this.parse(receiver)
        }
      } else if (method == "=~") {
        this.parse(args[0]);
        this.put(".test(");
        this.parse(receiver);
        this.put(")")
      } else if (method == "!~") {
        this.put("!");
        this.parse(args[0]);
        this.put(".test(");
        this.parse(receiver);
        this.put(")")
      } else if (method == "<<") {
        if (this.#state == "statement") {
          // Handle chained << operations by converting to a single push() call
          let current = receiver;
          let operations = [args[0]];

          // Traverse the AST to collect all chained << operations
          while (current.type === "send" && current.children[1] == "<<") {
            operations.unshift(current.children[2]);
            current = current.children[0]
          };

          // Generate a single push() call with multiple arguments
          this.parse(current);
          this.put(".push(");

          operations.forEach((arg, index) => {
            if (index > 0) this.put(", ");
            return this.parse(arg)
          });

          this.put(")")
        } else {
          // If not in statement context, fall back to original behavior
          if (group_receiver) {
            this.group(receiver)
          } else {
            this.parse(receiver)
          };

          this.put(" << ");

          if (group_target) {
            this.group(args[0])
          } else {
            this.parse(args[0])
          }
        }
      } else if (method == "<=>") {
        this.parse(receiver);
        this.put(" < ");
        this.parse(args[0]);
        this.put(" ? -1 : ");
        this.parse(receiver);
        this.put(" > ");
        this.parse(args[0]);
        this.put(" ? 1 : 0")
      } else if (Converter.OPERATORS.flat(Infinity).includes(method) && !Converter.LOGICAL.includes(method)) {
        if (group_receiver) {
          this.group(receiver)
        } else {
          this.parse(receiver)
        };

        if (this.#comparison == "identity" && ["==", "!="].includes(method)) {
          this.put(` ${method}= `)
        } else {
          this.put(` ${method} `)
        };

        if (group_target) {
          this.group(target)
        } else {
          this.parse(target)
        }
      } else if (/=$/m.test(method)) {
        if (this.#state == "statement") this.multi_assign_declarations;

        if (group_receiver) {
          this.group(receiver)
        } else {
          this.parse(receiver)
        };

        this.put(`${receiver ? "." : null}${method.toString().replace(
          /=$/m,
          " ="
        )} `);

        this.parse(
          args[0],
          this.#state == "method" ? "method" : "expression"
        )
      } else if (method == "new") {
        if (receiver) {
          // map Ruby's "Regexp" to JavaScript's "Regexp"
          if (receiver == this.s("const", null, "Regexp")) {
            receiver = this.s("const", null, "RegExp")
          };

          // allow a RegExp to be constructed from another RegExp
          if (receiver == this.s("const", null, "RegExp")) {
            if (args[0].type === "regexp") {
              let opts = "";

              if (args[0].children.at(-1).children.length > 0) {
                opts = args[0].children.at(-1).children.join
              };

              if (args.length > 1) opts += args.at(-1).children.at(-1);

              return this.parse(this.s(
                "regexp",
                ...args[0].children.slice(0, -1),
                this.s("regopt", ...opts.split("").map(item => item.to_sym))
              ))
            } else if (args[0].type === "str") {
              if (args.length == 2 && args[1].type === "str") {
                opts = args[1].children[0]
              } else {
                opts = ""
              };

              return this.parse(this.s(
                "regexp",
                args[0],
                this.s("regopt", ...opts.each_char.map(c => c))
              ))
            }
          };

          this.put("new ");

          if (group_receiver) {
            this.group(receiver)
          } else {
            this.parse(receiver)
          };

          if (ast.is_is_method()) {
            this.put("(");
            this.parse_all(...args, {join: ", "});
            this.put(")")
          }
        } else if (args.length == 1 && args[0].type === "send") {
          // accommodation for JavaScript like new syntax w/argument list
          // Preserve is_method? from the original Date() call by using updated
          let new_node = args[0].updated("send", [
            this.s("const", ...args[0].children.slice(0, 2)),
            "new",
            ...args[0].children.slice(2)
          ]);

          this.parse(new_node, this.#state)
        } else if (args.length == 1 && args[0].type === "const") {
          // accommodation for JavaScript like new syntax w/o argument list
          this.parse(this.s("attr", args[0], "new"), this.#state)
        } else if (args.length == 2 && ["send", "const"].includes(args[0].type) && args.at(-1).type === "def" && args.at(-1).children[0] == null) {
          // accommodation for JavaScript like new syntax with block
          this.parse(
            this.s(
              "send",
              this.s("const", null, args[0].children[1]),
              "new",
              ...args[0].children.slice(2),
              args.at(-1)
            ),

            this.#state
          )
        } else {
          throw new Error("use of JavaScript keyword new", this.#ast)
        }
      } else if (method == "raise" && receiver == null) {
        if (args.length == 1) {
          this.put("throw ");
          this.parse(args[0])
        } else {
          this.put("throw new ");
          this.parse(args[0]);
          this.put("(");
          this.parse(args[1]);
          this.put(")")
        }
      } else if (method == "typeof" && receiver == null) {
        this.put("typeof ");
        this.parse(args[0])
      } else if (ast.children[1] == "is_a?" && receiver && args.length == 1) {
        this.put("(");
        this.parse(receiver);
        this.put(" instanceof ");
        this.parse(args[0]);
        this.put(")")
      } else if (ast.children[1] == "kind_of?" && receiver && args.length == 1) {
        this.put("(");
        this.parse(receiver);
        this.put(" instanceof ");
        this.parse(args[0]);
        this.put(")")
      } else if (ast.children[1] == "instance_of?" && receiver && args.length == 1) {
        this.put("(");

        this.parse(this.s(
          "send",
          this.s("attr", receiver, "constructor"),
          "==",
          args[0]
        ));

        this.put(")")
      } else {
        if (method == "bind" && receiver?.type == "send") {
          if (receiver.children.length == 2 && receiver.children[0] == null) {
            receiver = receiver.updated("attr")
          }
        };

        // prevent autobind
        // :send!, :call, and :await force method call output (with parens)
        if (!ast.is_is_method() && !["send!", "call", "await"].includes(ast.type)) {
          if (receiver) {
            if (group_receiver) {
              this.group(receiver)
            } else {
              this.parse(receiver)
            };

            this.put(`.${method}`)
          } else if (ast.type === "attr") {
            this.put(method)
          } else {
            this.parse(ast.updated("lvasgn", [method]), this.#state)
          }
        } else if (args.some(arg => arg.type === "splat") && !this.es2015) {
          this.parse(this.s(
            "send",
            this.s("attr", receiver, method),
            "apply",
            receiver || this.s("nil"),
            this.s("array", ...args)
          ))
        } else {
          if (group_receiver) {
            this.group(receiver)
          } else {
            this.parse(receiver)
          };

          this.put(`${receiver && method ? "." : null}${method}`);

          if (args.length <= 1) {
            this.put("(");
            this.parse_all(...args, {join: ", "});
            this.put(")")
          } else {
            this.compact(() => {
              this.puts("(");
              this.parse_all(...args, {join: `,${this._ws}`});
              return this.sput(")")
            })
          }
        };

        if (autobind && !ast.is_is_method() && ast.type != "attr") {
          if (this.#state == "statement") {
            this.put("()")
          } else {
            this.put(".bind(");
            this.parse(autobind);
            this.put(")")
          }
        }
      }
    };

    on_sendw(receiver, method, ...args) {
      let t2, m2, args2, block, target, group_receiver, group_target, opts;
      this.ast = this.#ast;

      if (args.length == 1 && method == "+") {
        let node = this.collapse_strings(ast);
        if (node != ast) return this.parse(node)
      };

      if (receiver && receiver.type === "begin" && ["irange", "erange"].includes(receiver.children[0].type)) {
        if (method == "to_a") {
          return this.range_to_array(receiver.children[0])
        } else {
          throw new Error(`${receiver.children[0].type} can only be converted to array currently`, receiver.children[0])
        }
      };

      if (/\w[!?]$/m.test(method)) method = method.toString().slice(0, -1);

      if (method == "new" && receiver && receiver.children == [
        null,
        "Class"
      ] && args.at(-1).type === "def" && args.at(-1).children[0] == null) {
        let parent = args.length > 1 ? args[0] : null;

        if (this.es2015) {
          return this.parse(this.s(
            "class2",
            null,
            parent,
            ...args.at(-1).children.slice(2)
          ))
        } else {
          return this.parse(this.s(
            "kwbegin",

            this.s(
              "class",
              this.s("const", null, "$$"),
              parent,
              ...args.at(-1).children.slice(2)
            ),

            this.s("const", null, "$$")
          ))
        }
      };

      if (method == "new" && receiver && receiver.children == [
        null,
        "Proc"
      ]) {
        return this.parse(args[0], this.#state)
      } else if (!receiver && ["lambda", "proc"].includes(method)) {
        if (method == "lambda" && this.#state != "statement") {
          return this.parse(
            this.s(
              args[0].type,
              ...args[0].children.slice(0, -1),
              this.s("autoreturn", args[0].children.at(-1))
            ),

            this.#state
          )
        } else {
          return this.parse(args[0], this.#state)
        }
      };

      if (["call", "[]"].includes(method) && receiver && receiver.type === "block") {
        let [t2, m2, ...args2] = receiver.children[0].children;

        if (!t2 && ["lambda", "proc"].includes(m2) && args2.length == 0) {
          if (this.es2015 || this.#state == "statement") {
            this.group(receiver)
          } else {
            this.parse(receiver)
          };

          this.put("(");
          this.parse_all(...args, {join: ", "});
          this.put(")");
          return
        } else if (!t2 && m2 == "async" && args2.length == 0) {
          this.put("(");
          this.parse(receiver);
          this.put(")()");
          return
        }
      };

      if (method == "await" && this.es2017 && receiver == null && args.length == 2 && args[1].type === "def") {
        args = [this.s("block", args[0], ...args.at(-1).children.slice(1))]
      };

      if (this.es2017 && receiver == null && args.length == 1) {
        if (method == "async") {
          if (args[0].type === "def") {
            return this.parse(args[0].updated("async"))
          } else if (args[0].type === "defs") {
            return this.parse(args[0].updated("asyncs"))
          } else if (args[0].type === "send" && args[0].children[0].type === "block" && args[0].children.at(-1) == "[]") {
            this.put("(async ");
            this.parse(args[0].children[0], "statement");
            this.put(")()");
            return
          } else if (args[0].type === "block") {
            block = args[0];

            if (block.children[0].children.at(-1) == "lambda") {
              return this.parse(block.updated(
                "async",
                [null, block.children[1], this.s("autoreturn", block.children[2])]
              ))
            } else if (block.children[0].children.at(-1) == "proc") {
              return this.parse(block.updated(
                "async",
                [null, ...block.children.slice(1)]
              ))
            } else if (block.children[0].children[1] == "new" && block.children[0].children[0] == this.s(
              "const",
              null,
              "Proc"
            )) {
              return this.parse(block.updated(
                "async",
                [null, ...block.children.slice(1)]
              ))
            }
          }
        } else if (method == "await") {
          if (args[0].type === "send") {
            return this.parse(args[0].updated("await"))
          } else if (args[0].type === "block") {
            block = args[0];

            return this.parse(block.updated(
              null,
              [block.children[0].updated("await"), ...block.children.slice(1)]
            ))
          }
        }
      };

      let op_index = this.operator_index(method);
      if (op_index != -1) target = args[0];
      receiver ||= this.#rbstack.map(rb => rb[method]).filter(x => x != null).at(-1);
      let autobind = null;

      if (receiver) {
        if (receiver.type === "autobind") {
          autobind = receiver = receiver.children[0];
          if (!this.#autobind) autobind = null
        };

        if (receiver) {
          group_receiver = receiver.type === "send" && op_index < this.operator_index(receiver.children[1])
        };

        group_receiver ||= Converter.GROUP_OPERATORS.includes(receiver.type);
        if (receiver.children[1] == "[]") group_receiver = false;

        if (receiver.type === "int" && !Converter.OPERATORS.flat(Infinity).includes(method)) {
          group_receiver = true
        };

        if (!receiver.is_is_method() && receiver.children.at(-1) == "new") {
          group_receiver = true
        }
      };

      if (target) {
        group_target = target.type === "send" && op_index < this.operator_index(target.children[1]);
        group_target ||= Converter.GROUP_OPERATORS.includes(target.type)
      };

      if (this.#ast.type === "await") this.put("await ");

      if (method == "!") {
        this.parse(this.s("not", receiver))
      } else if (method == "[]") {
        if (group_receiver) {
          this.group(receiver)
        } else {
          this.parse(receiver)
        };

        if (args.length == 1 && ["str", "sym"].includes(args[0].type) && /^[a-zA-Z]\w*$/m.test(args[0].children[0].toString())) {
          this.put(`.${args[0].children[0]}`)
        } else {
          this.put("[");
          this.parse_all(...args, {join: ", "});
          this.put("]")
        }
      } else if (method == "[]=") {
        if (group_receiver) {
          this.group(receiver)
        } else {
          this.parse(receiver)
        };

        if (args.length == 2 && ["str", "sym"].includes(args[0].type) && /^[a-zA-Z]\w*$/m.test(args[0].children[0].toString())) {
          this.put(`.${args[0].children[0]} = `)
        } else {
          this.put("[");
          this.parse_all(...args.slice(0, -1), {join: ", "});
          this.put("] = ")
        };

        this.parse(args.at(-1))
      } else if (method == "**" && !this.es2016) {
        this.put("Math.pow(");
        this.parse(receiver);
        this.put(", ");
        this.parse(args[0]);
        this.put(")")
      } else if (["-@", "+@", "~", "~"].includes(method)) {
        let child0 = receiver.children[0];

        if (receiver.type === "send" && receiver.children[1] == "+@" && typeof child0 === "object" && child0 !== null && "type" in child0 && typeof child0 === "object" && child0 !== null && "children" in child0 && [
          "class",
          "module"
        ].includes(child0.type)) {
          if (receiver.children[0].type === "class") {
            this.parse(receiver.children[0].updated("class_extend"))
          } else {
            let mod = receiver.children[0];

            this.parse(this.s(
              "assign",
              mod.children[0],
              mod.updated(null, [null, ...mod.children.slice(1)])
            ))
          }
        } else {
          this.put(method.toString()[0]);
          this.parse(receiver)
        }
      } else if (method == "=~") {
        this.parse(args[0]);
        this.put(".test(");
        this.parse(receiver);
        this.put(")")
      } else if (method == "!~") {
        this.put("!");
        this.parse(args[0]);
        this.put(".test(");
        this.parse(receiver);
        this.put(")")
      } else if (method == "<<") {
        if (this.#state == "statement") {
          let current = receiver;
          let operations = [args[0]];

          while (current.type === "send" && current.children[1] == "<<") {
            operations.unshift(current.children[2]);
            current = current.children[0]
          };

          this.parse(current);
          this.put(".push(");

          operations.forEach((arg, index) => {
            if (index > 0) this.put(", ");
            return this.parse(arg)
          });

          this.put(")")
        } else {
          if (group_receiver) {
            this.group(receiver)
          } else {
            this.parse(receiver)
          };

          this.put(" << ");

          if (group_target) {
            this.group(args[0])
          } else {
            this.parse(args[0])
          }
        }
      } else if (method == "<=>") {
        this.parse(receiver);
        this.put(" < ");
        this.parse(args[0]);
        this.put(" ? -1 : ");
        this.parse(receiver);
        this.put(" > ");
        this.parse(args[0]);
        this.put(" ? 1 : 0")
      } else if (Converter.OPERATORS.flat(Infinity).includes(method) && !Converter.LOGICAL.includes(method)) {
        if (group_receiver) {
          this.group(receiver)
        } else {
          this.parse(receiver)
        };

        if (this.#comparison == "identity" && ["==", "!="].includes(method)) {
          this.put(` ${method}= `)
        } else {
          this.put(` ${method} `)
        };

        if (group_target) {
          this.group(target)
        } else {
          this.parse(target)
        }
      } else if (/=$/m.test(method)) {
        if (this.#state == "statement") this.multi_assign_declarations;

        if (group_receiver) {
          this.group(receiver)
        } else {
          this.parse(receiver)
        };

        this.put(`${receiver ? "." : null}${method.toString().replace(
          /=$/m,
          " ="
        )} `);

        this.parse(
          args[0],
          this.#state == "method" ? "method" : "expression"
        )
      } else if (method == "new") {
        if (receiver) {
          if (receiver == this.s("const", null, "Regexp")) {
            receiver = this.s("const", null, "RegExp")
          };

          if (receiver == this.s("const", null, "RegExp")) {
            if (args[0].type === "regexp") {
              let opts = "";

              if (args[0].children.at(-1).children.length > 0) {
                opts = args[0].children.at(-1).children.join
              };

              if (args.length > 1) opts += args.at(-1).children.at(-1);

              return this.parse(this.s(
                "regexp",
                ...args[0].children.slice(0, -1),
                this.s("regopt", ...opts.split("").map(item => item.to_sym))
              ))
            } else if (args[0].type === "str") {
              if (args.length == 2 && args[1].type === "str") {
                opts = args[1].children[0]
              } else {
                opts = ""
              };

              return this.parse(this.s(
                "regexp",
                args[0],
                this.s("regopt", ...opts.each_char.map(c => c))
              ))
            }
          };

          this.put("new ");

          if (group_receiver) {
            this.group(receiver)
          } else {
            this.parse(receiver)
          };

          if (ast.is_is_method()) {
            this.put("(");
            this.parse_all(...args, {join: ", "});
            this.put(")")
          }
        } else if (args.length == 1 && args[0].type === "send") {
          let new_node = args[0].updated("send", [
            this.s("const", ...args[0].children.slice(0, 2)),
            "new",
            ...args[0].children.slice(2)
          ]);

          this.parse(new_node, this.#state)
        } else if (args.length == 1 && args[0].type === "const") {
          this.parse(this.s("attr", args[0], "new"), this.#state)
        } else if (args.length == 2 && ["send", "const"].includes(args[0].type) && args.at(-1).type === "def" && args.at(-1).children[0] == null) {
          this.parse(
            this.s(
              "send",
              this.s("const", null, args[0].children[1]),
              "new",
              ...args[0].children.slice(2),
              args.at(-1)
            ),

            this.#state
          )
        } else {
          throw new Error("use of JavaScript keyword new", this.#ast)
        }
      } else if (method == "raise" && receiver == null) {
        if (args.length == 1) {
          this.put("throw ");
          this.parse(args[0])
        } else {
          this.put("throw new ");
          this.parse(args[0]);
          this.put("(");
          this.parse(args[1]);
          this.put(")")
        }
      } else if (method == "typeof" && receiver == null) {
        this.put("typeof ");
        this.parse(args[0])
      } else if (ast.children[1] == "is_a?" && receiver && args.length == 1) {
        this.put("(");
        this.parse(receiver);
        this.put(" instanceof ");
        this.parse(args[0]);
        this.put(")")
      } else if (ast.children[1] == "kind_of?" && receiver && args.length == 1) {
        this.put("(");
        this.parse(receiver);
        this.put(" instanceof ");
        this.parse(args[0]);
        this.put(")")
      } else if (ast.children[1] == "instance_of?" && receiver && args.length == 1) {
        this.put("(");

        this.parse(this.s(
          "send",
          this.s("attr", receiver, "constructor"),
          "==",
          args[0]
        ));

        this.put(")")
      } else {
        if (method == "bind" && receiver?.type == "send") {
          if (receiver.children.length == 2 && receiver.children[0] == null) {
            receiver = receiver.updated("attr")
          }
        };

        if (!ast.is_is_method() && !["send!", "call", "await"].includes(ast.type)) {
          if (receiver) {
            if (group_receiver) {
              this.group(receiver)
            } else {
              this.parse(receiver)
            };

            this.put(`.${method}`)
          } else if (ast.type === "attr") {
            this.put(method)
          } else {
            this.parse(ast.updated("lvasgn", [method]), this.#state)
          }
        } else if (args.some(arg => arg.type === "splat") && !this.es2015) {
          this.parse(this.s(
            "send",
            this.s("attr", receiver, method),
            "apply",
            receiver || this.s("nil"),
            this.s("array", ...args)
          ))
        } else {
          if (group_receiver) {
            this.group(receiver)
          } else {
            this.parse(receiver)
          };

          this.put(`${receiver && method ? "." : null}${method}`);

          if (args.length <= 1) {
            this.put("(");
            this.parse_all(...args, {join: ", "});
            this.put(")")
          } else {
            this.compact(() => {
              this.puts("(");
              this.parse_all(...args, {join: `,${this._ws}`});
              return this.sput(")")
            })
          }
        };

        if (autobind && !ast.is_is_method() && ast.type != "attr") {
          if (this.#state == "statement") {
            this.put("()")
          } else {
            this.put(".bind(");
            this.parse(autobind);
            this.put(")")
          }
        }
      }
    };

    on_send(receiver, method, ...args) {
      let t2, m2, args2, block, target, group_receiver, group_target, opts;
      this.ast = this.#ast;

      if (args.length == 1 && method == "+") {
        let node = this.collapse_strings(ast);
        if (node != ast) return this.parse(node)
      };

      if (receiver && receiver.type === "begin" && ["irange", "erange"].includes(receiver.children[0].type)) {
        if (method == "to_a") {
          return this.range_to_array(receiver.children[0])
        } else {
          throw new Error(`${receiver.children[0].type} can only be converted to array currently`, receiver.children[0])
        }
      };

      if (/\w[!?]$/m.test(method)) method = method.toString().slice(0, -1);

      if (method == "new" && receiver && receiver.children == [
        null,
        "Class"
      ] && args.at(-1).type === "def" && args.at(-1).children[0] == null) {
        let parent = args.length > 1 ? args[0] : null;

        if (this.es2015) {
          return this.parse(this.s(
            "class2",
            null,
            parent,
            ...args.at(-1).children.slice(2)
          ))
        } else {
          return this.parse(this.s(
            "kwbegin",

            this.s(
              "class",
              this.s("const", null, "$$"),
              parent,
              ...args.at(-1).children.slice(2)
            ),

            this.s("const", null, "$$")
          ))
        }
      };

      if (method == "new" && receiver && receiver.children == [
        null,
        "Proc"
      ]) {
        return this.parse(args[0], this.#state)
      } else if (!receiver && ["lambda", "proc"].includes(method)) {
        if (method == "lambda" && this.#state != "statement") {
          return this.parse(
            this.s(
              args[0].type,
              ...args[0].children.slice(0, -1),
              this.s("autoreturn", args[0].children.at(-1))
            ),

            this.#state
          )
        } else {
          return this.parse(args[0], this.#state)
        }
      };

      if (["call", "[]"].includes(method) && receiver && receiver.type === "block") {
        let [t2, m2, ...args2] = receiver.children[0].children;

        if (!t2 && ["lambda", "proc"].includes(m2) && args2.length == 0) {
          if (this.es2015 || this.#state == "statement") {
            this.group(receiver)
          } else {
            this.parse(receiver)
          };

          this.put("(");
          this.parse_all(...args, {join: ", "});
          this.put(")");
          return
        } else if (!t2 && m2 == "async" && args2.length == 0) {
          this.put("(");
          this.parse(receiver);
          this.put(")()");
          return
        }
      };

      if (method == "await" && this.es2017 && receiver == null && args.length == 2 && args[1].type === "def") {
        args = [this.s("block", args[0], ...args.at(-1).children.slice(1))]
      };

      if (this.es2017 && receiver == null && args.length == 1) {
        if (method == "async") {
          if (args[0].type === "def") {
            return this.parse(args[0].updated("async"))
          } else if (args[0].type === "defs") {
            return this.parse(args[0].updated("asyncs"))
          } else if (args[0].type === "send" && args[0].children[0].type === "block" && args[0].children.at(-1) == "[]") {
            this.put("(async ");
            this.parse(args[0].children[0], "statement");
            this.put(")()");
            return
          } else if (args[0].type === "block") {
            block = args[0];

            if (block.children[0].children.at(-1) == "lambda") {
              return this.parse(block.updated(
                "async",
                [null, block.children[1], this.s("autoreturn", block.children[2])]
              ))
            } else if (block.children[0].children.at(-1) == "proc") {
              return this.parse(block.updated(
                "async",
                [null, ...block.children.slice(1)]
              ))
            } else if (block.children[0].children[1] == "new" && block.children[0].children[0] == this.s(
              "const",
              null,
              "Proc"
            )) {
              return this.parse(block.updated(
                "async",
                [null, ...block.children.slice(1)]
              ))
            }
          }
        } else if (method == "await") {
          if (args[0].type === "send") {
            return this.parse(args[0].updated("await"))
          } else if (args[0].type === "block") {
            block = args[0];

            return this.parse(block.updated(
              null,
              [block.children[0].updated("await"), ...block.children.slice(1)]
            ))
          }
        }
      };

      let op_index = this.operator_index(method);
      if (op_index != -1) target = args[0];
      receiver ||= this.#rbstack.map(rb => rb[method]).filter(x => x != null).at(-1);
      let autobind = null;

      if (receiver) {
        if (receiver.type === "autobind") {
          autobind = receiver = receiver.children[0];
          if (!this.#autobind) autobind = null
        };

        if (receiver) {
          group_receiver = receiver.type === "send" && op_index < this.operator_index(receiver.children[1])
        };

        group_receiver ||= Converter.GROUP_OPERATORS.includes(receiver.type);
        if (receiver.children[1] == "[]") group_receiver = false;

        if (receiver.type === "int" && !Converter.OPERATORS.flat(Infinity).includes(method)) {
          group_receiver = true
        };

        if (!receiver.is_is_method() && receiver.children.at(-1) == "new") {
          group_receiver = true
        }
      };

      if (target) {
        group_target = target.type === "send" && op_index < this.operator_index(target.children[1]);
        group_target ||= Converter.GROUP_OPERATORS.includes(target.type)
      };

      if (this.#ast.type === "await") this.put("await ");

      if (method == "!") {
        this.parse(this.s("not", receiver))
      } else if (method == "[]") {
        if (group_receiver) {
          this.group(receiver)
        } else {
          this.parse(receiver)
        };

        if (args.length == 1 && ["str", "sym"].includes(args[0].type) && /^[a-zA-Z]\w*$/m.test(args[0].children[0].toString())) {
          this.put(`.${args[0].children[0]}`)
        } else {
          this.put("[");
          this.parse_all(...args, {join: ", "});
          this.put("]")
        }
      } else if (method == "[]=") {
        if (group_receiver) {
          this.group(receiver)
        } else {
          this.parse(receiver)
        };

        if (args.length == 2 && ["str", "sym"].includes(args[0].type) && /^[a-zA-Z]\w*$/m.test(args[0].children[0].toString())) {
          this.put(`.${args[0].children[0]} = `)
        } else {
          this.put("[");
          this.parse_all(...args.slice(0, -1), {join: ", "});
          this.put("] = ")
        };

        this.parse(args.at(-1))
      } else if (method == "**" && !this.es2016) {
        this.put("Math.pow(");
        this.parse(receiver);
        this.put(", ");
        this.parse(args[0]);
        this.put(")")
      } else if (["-@", "+@", "~", "~"].includes(method)) {
        let child0 = receiver.children[0];

        if (receiver.type === "send" && receiver.children[1] == "+@" && typeof child0 === "object" && child0 !== null && "type" in child0 && typeof child0 === "object" && child0 !== null && "children" in child0 && [
          "class",
          "module"
        ].includes(child0.type)) {
          if (receiver.children[0].type === "class") {
            this.parse(receiver.children[0].updated("class_extend"))
          } else {
            let mod = receiver.children[0];

            this.parse(this.s(
              "assign",
              mod.children[0],
              mod.updated(null, [null, ...mod.children.slice(1)])
            ))
          }
        } else {
          this.put(method.toString()[0]);
          this.parse(receiver)
        }
      } else if (method == "=~") {
        this.parse(args[0]);
        this.put(".test(");
        this.parse(receiver);
        this.put(")")
      } else if (method == "!~") {
        this.put("!");
        this.parse(args[0]);
        this.put(".test(");
        this.parse(receiver);
        this.put(")")
      } else if (method == "<<") {
        if (this.#state == "statement") {
          let current = receiver;
          let operations = [args[0]];

          while (current.type === "send" && current.children[1] == "<<") {
            operations.unshift(current.children[2]);
            current = current.children[0]
          };

          this.parse(current);
          this.put(".push(");

          operations.forEach((arg, index) => {
            if (index > 0) this.put(", ");
            return this.parse(arg)
          });

          this.put(")")
        } else {
          if (group_receiver) {
            this.group(receiver)
          } else {
            this.parse(receiver)
          };

          this.put(" << ");

          if (group_target) {
            this.group(args[0])
          } else {
            this.parse(args[0])
          }
        }
      } else if (method == "<=>") {
        this.parse(receiver);
        this.put(" < ");
        this.parse(args[0]);
        this.put(" ? -1 : ");
        this.parse(receiver);
        this.put(" > ");
        this.parse(args[0]);
        this.put(" ? 1 : 0")
      } else if (Converter.OPERATORS.flat(Infinity).includes(method) && !Converter.LOGICAL.includes(method)) {
        if (group_receiver) {
          this.group(receiver)
        } else {
          this.parse(receiver)
        };

        if (this.#comparison == "identity" && ["==", "!="].includes(method)) {
          this.put(` ${method}= `)
        } else {
          this.put(` ${method} `)
        };

        if (group_target) {
          this.group(target)
        } else {
          this.parse(target)
        }
      } else if (/=$/m.test(method)) {
        if (this.#state == "statement") this.multi_assign_declarations;

        if (group_receiver) {
          this.group(receiver)
        } else {
          this.parse(receiver)
        };

        this.put(`${receiver ? "." : null}${method.toString().replace(
          /=$/m,
          " ="
        )} `);

        this.parse(
          args[0],
          this.#state == "method" ? "method" : "expression"
        )
      } else if (method == "new") {
        if (receiver) {
          if (receiver == this.s("const", null, "Regexp")) {
            receiver = this.s("const", null, "RegExp")
          };

          if (receiver == this.s("const", null, "RegExp")) {
            if (args[0].type === "regexp") {
              let opts = "";

              if (args[0].children.at(-1).children.length > 0) {
                opts = args[0].children.at(-1).children.join
              };

              if (args.length > 1) opts += args.at(-1).children.at(-1);

              return this.parse(this.s(
                "regexp",
                ...args[0].children.slice(0, -1),
                this.s("regopt", ...opts.split("").map(item => item.to_sym))
              ))
            } else if (args[0].type === "str") {
              if (args.length == 2 && args[1].type === "str") {
                opts = args[1].children[0]
              } else {
                opts = ""
              };

              return this.parse(this.s(
                "regexp",
                args[0],
                this.s("regopt", ...opts.each_char.map(c => c))
              ))
            }
          };

          this.put("new ");

          if (group_receiver) {
            this.group(receiver)
          } else {
            this.parse(receiver)
          };

          if (ast.is_is_method()) {
            this.put("(");
            this.parse_all(...args, {join: ", "});
            this.put(")")
          }
        } else if (args.length == 1 && args[0].type === "send") {
          let new_node = args[0].updated("send", [
            this.s("const", ...args[0].children.slice(0, 2)),
            "new",
            ...args[0].children.slice(2)
          ]);

          this.parse(new_node, this.#state)
        } else if (args.length == 1 && args[0].type === "const") {
          this.parse(this.s("attr", args[0], "new"), this.#state)
        } else if (args.length == 2 && ["send", "const"].includes(args[0].type) && args.at(-1).type === "def" && args.at(-1).children[0] == null) {
          this.parse(
            this.s(
              "send",
              this.s("const", null, args[0].children[1]),
              "new",
              ...args[0].children.slice(2),
              args.at(-1)
            ),

            this.#state
          )
        } else {
          throw new Error("use of JavaScript keyword new", this.#ast)
        }
      } else if (method == "raise" && receiver == null) {
        if (args.length == 1) {
          this.put("throw ");
          this.parse(args[0])
        } else {
          this.put("throw new ");
          this.parse(args[0]);
          this.put("(");
          this.parse(args[1]);
          this.put(")")
        }
      } else if (method == "typeof" && receiver == null) {
        this.put("typeof ");
        this.parse(args[0])
      } else if (ast.children[1] == "is_a?" && receiver && args.length == 1) {
        this.put("(");
        this.parse(receiver);
        this.put(" instanceof ");
        this.parse(args[0]);
        this.put(")")
      } else if (ast.children[1] == "kind_of?" && receiver && args.length == 1) {
        this.put("(");
        this.parse(receiver);
        this.put(" instanceof ");
        this.parse(args[0]);
        this.put(")")
      } else if (ast.children[1] == "instance_of?" && receiver && args.length == 1) {
        this.put("(");

        this.parse(this.s(
          "send",
          this.s("attr", receiver, "constructor"),
          "==",
          args[0]
        ));

        this.put(")")
      } else {
        if (method == "bind" && receiver?.type == "send") {
          if (receiver.children.length == 2 && receiver.children[0] == null) {
            receiver = receiver.updated("attr")
          }
        };

        if (!ast.is_is_method() && !["send!", "call", "await"].includes(ast.type)) {
          if (receiver) {
            if (group_receiver) {
              this.group(receiver)
            } else {
              this.parse(receiver)
            };

            this.put(`.${method}`)
          } else if (ast.type === "attr") {
            this.put(method)
          } else {
            this.parse(ast.updated("lvasgn", [method]), this.#state)
          }
        } else if (args.some(arg => arg.type === "splat") && !this.es2015) {
          this.parse(this.s(
            "send",
            this.s("attr", receiver, method),
            "apply",
            receiver || this.s("nil"),
            this.s("array", ...args)
          ))
        } else {
          if (group_receiver) {
            this.group(receiver)
          } else {
            this.parse(receiver)
          };

          this.put(`${receiver && method ? "." : null}${method}`);

          if (args.length <= 1) {
            this.put("(");
            this.parse_all(...args, {join: ", "});
            this.put(")")
          } else {
            this.compact(() => {
              this.puts("(");
              this.parse_all(...args, {join: `,${this._ws}`});
              return this.sput(")")
            })
          }
        };

        if (autobind && !ast.is_is_method() && ast.type != "attr") {
          if (this.#state == "statement") {
            this.put("()")
          } else {
            this.put(".bind(");
            this.parse(autobind);
            this.put(")")
          }
        }
      }
    };

    on_await(receiver, method, ...args) {
      let t2, m2, args2, block, target, group_receiver, group_target, opts;
      this.ast = this.#ast;

      if (args.length == 1 && method == "+") {
        let node = this.collapse_strings(ast);
        if (node != ast) return this.parse(node)
      };

      if (receiver && receiver.type === "begin" && ["irange", "erange"].includes(receiver.children[0].type)) {
        if (method == "to_a") {
          return this.range_to_array(receiver.children[0])
        } else {
          throw new Error(`${receiver.children[0].type} can only be converted to array currently`, receiver.children[0])
        }
      };

      if (/\w[!?]$/m.test(method)) method = method.toString().slice(0, -1);

      if (method == "new" && receiver && receiver.children == [
        null,
        "Class"
      ] && args.at(-1).type === "def" && args.at(-1).children[0] == null) {
        let parent = args.length > 1 ? args[0] : null;

        if (this.es2015) {
          return this.parse(this.s(
            "class2",
            null,
            parent,
            ...args.at(-1).children.slice(2)
          ))
        } else {
          return this.parse(this.s(
            "kwbegin",

            this.s(
              "class",
              this.s("const", null, "$$"),
              parent,
              ...args.at(-1).children.slice(2)
            ),

            this.s("const", null, "$$")
          ))
        }
      };

      if (method == "new" && receiver && receiver.children == [
        null,
        "Proc"
      ]) {
        return this.parse(args[0], this.#state)
      } else if (!receiver && ["lambda", "proc"].includes(method)) {
        if (method == "lambda" && this.#state != "statement") {
          return this.parse(
            this.s(
              args[0].type,
              ...args[0].children.slice(0, -1),
              this.s("autoreturn", args[0].children.at(-1))
            ),

            this.#state
          )
        } else {
          return this.parse(args[0], this.#state)
        }
      };

      if (["call", "[]"].includes(method) && receiver && receiver.type === "block") {
        let [t2, m2, ...args2] = receiver.children[0].children;

        if (!t2 && ["lambda", "proc"].includes(m2) && args2.length == 0) {
          if (this.es2015 || this.#state == "statement") {
            this.group(receiver)
          } else {
            this.parse(receiver)
          };

          this.put("(");
          this.parse_all(...args, {join: ", "});
          this.put(")");
          return
        } else if (!t2 && m2 == "async" && args2.length == 0) {
          this.put("(");
          this.parse(receiver);
          this.put(")()");
          return
        }
      };

      if (method == "await" && this.es2017 && receiver == null && args.length == 2 && args[1].type === "def") {
        args = [this.s("block", args[0], ...args.at(-1).children.slice(1))]
      };

      if (this.es2017 && receiver == null && args.length == 1) {
        if (method == "async") {
          if (args[0].type === "def") {
            return this.parse(args[0].updated("async"))
          } else if (args[0].type === "defs") {
            return this.parse(args[0].updated("asyncs"))
          } else if (args[0].type === "send" && args[0].children[0].type === "block" && args[0].children.at(-1) == "[]") {
            this.put("(async ");
            this.parse(args[0].children[0], "statement");
            this.put(")()");
            return
          } else if (args[0].type === "block") {
            block = args[0];

            if (block.children[0].children.at(-1) == "lambda") {
              return this.parse(block.updated(
                "async",
                [null, block.children[1], this.s("autoreturn", block.children[2])]
              ))
            } else if (block.children[0].children.at(-1) == "proc") {
              return this.parse(block.updated(
                "async",
                [null, ...block.children.slice(1)]
              ))
            } else if (block.children[0].children[1] == "new" && block.children[0].children[0] == this.s(
              "const",
              null,
              "Proc"
            )) {
              return this.parse(block.updated(
                "async",
                [null, ...block.children.slice(1)]
              ))
            }
          }
        } else if (method == "await") {
          if (args[0].type === "send") {
            return this.parse(args[0].updated("await"))
          } else if (args[0].type === "block") {
            block = args[0];

            return this.parse(block.updated(
              null,
              [block.children[0].updated("await"), ...block.children.slice(1)]
            ))
          }
        }
      };

      let op_index = this.operator_index(method);
      if (op_index != -1) target = args[0];
      receiver ||= this.#rbstack.map(rb => rb[method]).filter(x => x != null).at(-1);
      let autobind = null;

      if (receiver) {
        if (receiver.type === "autobind") {
          autobind = receiver = receiver.children[0];
          if (!this.#autobind) autobind = null
        };

        if (receiver) {
          group_receiver = receiver.type === "send" && op_index < this.operator_index(receiver.children[1])
        };

        group_receiver ||= Converter.GROUP_OPERATORS.includes(receiver.type);
        if (receiver.children[1] == "[]") group_receiver = false;

        if (receiver.type === "int" && !Converter.OPERATORS.flat(Infinity).includes(method)) {
          group_receiver = true
        };

        if (!receiver.is_is_method() && receiver.children.at(-1) == "new") {
          group_receiver = true
        }
      };

      if (target) {
        group_target = target.type === "send" && op_index < this.operator_index(target.children[1]);
        group_target ||= Converter.GROUP_OPERATORS.includes(target.type)
      };

      if (this.#ast.type === "await") this.put("await ");

      if (method == "!") {
        this.parse(this.s("not", receiver))
      } else if (method == "[]") {
        if (group_receiver) {
          this.group(receiver)
        } else {
          this.parse(receiver)
        };

        if (args.length == 1 && ["str", "sym"].includes(args[0].type) && /^[a-zA-Z]\w*$/m.test(args[0].children[0].toString())) {
          this.put(`.${args[0].children[0]}`)
        } else {
          this.put("[");
          this.parse_all(...args, {join: ", "});
          this.put("]")
        }
      } else if (method == "[]=") {
        if (group_receiver) {
          this.group(receiver)
        } else {
          this.parse(receiver)
        };

        if (args.length == 2 && ["str", "sym"].includes(args[0].type) && /^[a-zA-Z]\w*$/m.test(args[0].children[0].toString())) {
          this.put(`.${args[0].children[0]} = `)
        } else {
          this.put("[");
          this.parse_all(...args.slice(0, -1), {join: ", "});
          this.put("] = ")
        };

        this.parse(args.at(-1))
      } else if (method == "**" && !this.es2016) {
        this.put("Math.pow(");
        this.parse(receiver);
        this.put(", ");
        this.parse(args[0]);
        this.put(")")
      } else if (["-@", "+@", "~", "~"].includes(method)) {
        let child0 = receiver.children[0];

        if (receiver.type === "send" && receiver.children[1] == "+@" && typeof child0 === "object" && child0 !== null && "type" in child0 && typeof child0 === "object" && child0 !== null && "children" in child0 && [
          "class",
          "module"
        ].includes(child0.type)) {
          if (receiver.children[0].type === "class") {
            this.parse(receiver.children[0].updated("class_extend"))
          } else {
            let mod = receiver.children[0];

            this.parse(this.s(
              "assign",
              mod.children[0],
              mod.updated(null, [null, ...mod.children.slice(1)])
            ))
          }
        } else {
          this.put(method.toString()[0]);
          this.parse(receiver)
        }
      } else if (method == "=~") {
        this.parse(args[0]);
        this.put(".test(");
        this.parse(receiver);
        this.put(")")
      } else if (method == "!~") {
        this.put("!");
        this.parse(args[0]);
        this.put(".test(");
        this.parse(receiver);
        this.put(")")
      } else if (method == "<<") {
        if (this.#state == "statement") {
          let current = receiver;
          let operations = [args[0]];

          while (current.type === "send" && current.children[1] == "<<") {
            operations.unshift(current.children[2]);
            current = current.children[0]
          };

          this.parse(current);
          this.put(".push(");

          operations.forEach((arg, index) => {
            if (index > 0) this.put(", ");
            return this.parse(arg)
          });

          this.put(")")
        } else {
          if (group_receiver) {
            this.group(receiver)
          } else {
            this.parse(receiver)
          };

          this.put(" << ");

          if (group_target) {
            this.group(args[0])
          } else {
            this.parse(args[0])
          }
        }
      } else if (method == "<=>") {
        this.parse(receiver);
        this.put(" < ");
        this.parse(args[0]);
        this.put(" ? -1 : ");
        this.parse(receiver);
        this.put(" > ");
        this.parse(args[0]);
        this.put(" ? 1 : 0")
      } else if (Converter.OPERATORS.flat(Infinity).includes(method) && !Converter.LOGICAL.includes(method)) {
        if (group_receiver) {
          this.group(receiver)
        } else {
          this.parse(receiver)
        };

        if (this.#comparison == "identity" && ["==", "!="].includes(method)) {
          this.put(` ${method}= `)
        } else {
          this.put(` ${method} `)
        };

        if (group_target) {
          this.group(target)
        } else {
          this.parse(target)
        }
      } else if (/=$/m.test(method)) {
        if (this.#state == "statement") this.multi_assign_declarations;

        if (group_receiver) {
          this.group(receiver)
        } else {
          this.parse(receiver)
        };

        this.put(`${receiver ? "." : null}${method.toString().replace(
          /=$/m,
          " ="
        )} `);

        this.parse(
          args[0],
          this.#state == "method" ? "method" : "expression"
        )
      } else if (method == "new") {
        if (receiver) {
          if (receiver == this.s("const", null, "Regexp")) {
            receiver = this.s("const", null, "RegExp")
          };

          if (receiver == this.s("const", null, "RegExp")) {
            if (args[0].type === "regexp") {
              let opts = "";

              if (args[0].children.at(-1).children.length > 0) {
                opts = args[0].children.at(-1).children.join
              };

              if (args.length > 1) opts += args.at(-1).children.at(-1);

              return this.parse(this.s(
                "regexp",
                ...args[0].children.slice(0, -1),
                this.s("regopt", ...opts.split("").map(item => item.to_sym))
              ))
            } else if (args[0].type === "str") {
              if (args.length == 2 && args[1].type === "str") {
                opts = args[1].children[0]
              } else {
                opts = ""
              };

              return this.parse(this.s(
                "regexp",
                args[0],
                this.s("regopt", ...opts.each_char.map(c => c))
              ))
            }
          };

          this.put("new ");

          if (group_receiver) {
            this.group(receiver)
          } else {
            this.parse(receiver)
          };

          if (ast.is_is_method()) {
            this.put("(");
            this.parse_all(...args, {join: ", "});
            this.put(")")
          }
        } else if (args.length == 1 && args[0].type === "send") {
          let new_node = args[0].updated("send", [
            this.s("const", ...args[0].children.slice(0, 2)),
            "new",
            ...args[0].children.slice(2)
          ]);

          this.parse(new_node, this.#state)
        } else if (args.length == 1 && args[0].type === "const") {
          this.parse(this.s("attr", args[0], "new"), this.#state)
        } else if (args.length == 2 && ["send", "const"].includes(args[0].type) && args.at(-1).type === "def" && args.at(-1).children[0] == null) {
          this.parse(
            this.s(
              "send",
              this.s("const", null, args[0].children[1]),
              "new",
              ...args[0].children.slice(2),
              args.at(-1)
            ),

            this.#state
          )
        } else {
          throw new Error("use of JavaScript keyword new", this.#ast)
        }
      } else if (method == "raise" && receiver == null) {
        if (args.length == 1) {
          this.put("throw ");
          this.parse(args[0])
        } else {
          this.put("throw new ");
          this.parse(args[0]);
          this.put("(");
          this.parse(args[1]);
          this.put(")")
        }
      } else if (method == "typeof" && receiver == null) {
        this.put("typeof ");
        this.parse(args[0])
      } else if (ast.children[1] == "is_a?" && receiver && args.length == 1) {
        this.put("(");
        this.parse(receiver);
        this.put(" instanceof ");
        this.parse(args[0]);
        this.put(")")
      } else if (ast.children[1] == "kind_of?" && receiver && args.length == 1) {
        this.put("(");
        this.parse(receiver);
        this.put(" instanceof ");
        this.parse(args[0]);
        this.put(")")
      } else if (ast.children[1] == "instance_of?" && receiver && args.length == 1) {
        this.put("(");

        this.parse(this.s(
          "send",
          this.s("attr", receiver, "constructor"),
          "==",
          args[0]
        ));

        this.put(")")
      } else {
        if (method == "bind" && receiver?.type == "send") {
          if (receiver.children.length == 2 && receiver.children[0] == null) {
            receiver = receiver.updated("attr")
          }
        };

        if (!ast.is_is_method() && !["send!", "call", "await"].includes(ast.type)) {
          if (receiver) {
            if (group_receiver) {
              this.group(receiver)
            } else {
              this.parse(receiver)
            };

            this.put(`.${method}`)
          } else if (ast.type === "attr") {
            this.put(method)
          } else {
            this.parse(ast.updated("lvasgn", [method]), this.#state)
          }
        } else if (args.some(arg => arg.type === "splat") && !this.es2015) {
          this.parse(this.s(
            "send",
            this.s("attr", receiver, method),
            "apply",
            receiver || this.s("nil"),
            this.s("array", ...args)
          ))
        } else {
          if (group_receiver) {
            this.group(receiver)
          } else {
            this.parse(receiver)
          };

          this.put(`${receiver && method ? "." : null}${method}`);

          if (args.length <= 1) {
            this.put("(");
            this.parse_all(...args, {join: ", "});
            this.put(")")
          } else {
            this.compact(() => {
              this.puts("(");
              this.parse_all(...args, {join: `,${this._ws}`});
              return this.sput(")")
            })
          }
        };

        if (autobind && !ast.is_is_method() && ast.type != "attr") {
          if (this.#state == "statement") {
            this.put("()")
          } else {
            this.put(".bind(");
            this.parse(autobind);
            this.put(")")
          }
        }
      }
    };

    on_attr(receiver, method, ...args) {
      let t2, m2, args2, block, target, group_receiver, group_target, opts;
      this.ast = this.#ast;

      if (args.length == 1 && method == "+") {
        let node = this.collapse_strings(ast);
        if (node != ast) return this.parse(node)
      };

      if (receiver && receiver.type === "begin" && ["irange", "erange"].includes(receiver.children[0].type)) {
        if (method == "to_a") {
          return this.range_to_array(receiver.children[0])
        } else {
          throw new Error(`${receiver.children[0].type} can only be converted to array currently`, receiver.children[0])
        }
      };

      if (/\w[!?]$/m.test(method)) method = method.toString().slice(0, -1);

      if (method == "new" && receiver && receiver.children == [
        null,
        "Class"
      ] && args.at(-1).type === "def" && args.at(-1).children[0] == null) {
        let parent = args.length > 1 ? args[0] : null;

        if (this.es2015) {
          return this.parse(this.s(
            "class2",
            null,
            parent,
            ...args.at(-1).children.slice(2)
          ))
        } else {
          return this.parse(this.s(
            "kwbegin",

            this.s(
              "class",
              this.s("const", null, "$$"),
              parent,
              ...args.at(-1).children.slice(2)
            ),

            this.s("const", null, "$$")
          ))
        }
      };

      if (method == "new" && receiver && receiver.children == [
        null,
        "Proc"
      ]) {
        return this.parse(args[0], this.#state)
      } else if (!receiver && ["lambda", "proc"].includes(method)) {
        if (method == "lambda" && this.#state != "statement") {
          return this.parse(
            this.s(
              args[0].type,
              ...args[0].children.slice(0, -1),
              this.s("autoreturn", args[0].children.at(-1))
            ),

            this.#state
          )
        } else {
          return this.parse(args[0], this.#state)
        }
      };

      if (["call", "[]"].includes(method) && receiver && receiver.type === "block") {
        let [t2, m2, ...args2] = receiver.children[0].children;

        if (!t2 && ["lambda", "proc"].includes(m2) && args2.length == 0) {
          if (this.es2015 || this.#state == "statement") {
            this.group(receiver)
          } else {
            this.parse(receiver)
          };

          this.put("(");
          this.parse_all(...args, {join: ", "});
          this.put(")");
          return
        } else if (!t2 && m2 == "async" && args2.length == 0) {
          this.put("(");
          this.parse(receiver);
          this.put(")()");
          return
        }
      };

      if (method == "await" && this.es2017 && receiver == null && args.length == 2 && args[1].type === "def") {
        args = [this.s("block", args[0], ...args.at(-1).children.slice(1))]
      };

      if (this.es2017 && receiver == null && args.length == 1) {
        if (method == "async") {
          if (args[0].type === "def") {
            return this.parse(args[0].updated("async"))
          } else if (args[0].type === "defs") {
            return this.parse(args[0].updated("asyncs"))
          } else if (args[0].type === "send" && args[0].children[0].type === "block" && args[0].children.at(-1) == "[]") {
            this.put("(async ");
            this.parse(args[0].children[0], "statement");
            this.put(")()");
            return
          } else if (args[0].type === "block") {
            block = args[0];

            if (block.children[0].children.at(-1) == "lambda") {
              return this.parse(block.updated(
                "async",
                [null, block.children[1], this.s("autoreturn", block.children[2])]
              ))
            } else if (block.children[0].children.at(-1) == "proc") {
              return this.parse(block.updated(
                "async",
                [null, ...block.children.slice(1)]
              ))
            } else if (block.children[0].children[1] == "new" && block.children[0].children[0] == this.s(
              "const",
              null,
              "Proc"
            )) {
              return this.parse(block.updated(
                "async",
                [null, ...block.children.slice(1)]
              ))
            }
          }
        } else if (method == "await") {
          if (args[0].type === "send") {
            return this.parse(args[0].updated("await"))
          } else if (args[0].type === "block") {
            block = args[0];

            return this.parse(block.updated(
              null,
              [block.children[0].updated("await"), ...block.children.slice(1)]
            ))
          }
        }
      };

      let op_index = this.operator_index(method);
      if (op_index != -1) target = args[0];
      receiver ||= this.#rbstack.map(rb => rb[method]).filter(x => x != null).at(-1);
      let autobind = null;

      if (receiver) {
        if (receiver.type === "autobind") {
          autobind = receiver = receiver.children[0];
          if (!this.#autobind) autobind = null
        };

        if (receiver) {
          group_receiver = receiver.type === "send" && op_index < this.operator_index(receiver.children[1])
        };

        group_receiver ||= Converter.GROUP_OPERATORS.includes(receiver.type);
        if (receiver.children[1] == "[]") group_receiver = false;

        if (receiver.type === "int" && !Converter.OPERATORS.flat(Infinity).includes(method)) {
          group_receiver = true
        };

        if (!receiver.is_is_method() && receiver.children.at(-1) == "new") {
          group_receiver = true
        }
      };

      if (target) {
        group_target = target.type === "send" && op_index < this.operator_index(target.children[1]);
        group_target ||= Converter.GROUP_OPERATORS.includes(target.type)
      };

      if (this.#ast.type === "await") this.put("await ");

      if (method == "!") {
        this.parse(this.s("not", receiver))
      } else if (method == "[]") {
        if (group_receiver) {
          this.group(receiver)
        } else {
          this.parse(receiver)
        };

        if (args.length == 1 && ["str", "sym"].includes(args[0].type) && /^[a-zA-Z]\w*$/m.test(args[0].children[0].toString())) {
          this.put(`.${args[0].children[0]}`)
        } else {
          this.put("[");
          this.parse_all(...args, {join: ", "});
          this.put("]")
        }
      } else if (method == "[]=") {
        if (group_receiver) {
          this.group(receiver)
        } else {
          this.parse(receiver)
        };

        if (args.length == 2 && ["str", "sym"].includes(args[0].type) && /^[a-zA-Z]\w*$/m.test(args[0].children[0].toString())) {
          this.put(`.${args[0].children[0]} = `)
        } else {
          this.put("[");
          this.parse_all(...args.slice(0, -1), {join: ", "});
          this.put("] = ")
        };

        this.parse(args.at(-1))
      } else if (method == "**" && !this.es2016) {
        this.put("Math.pow(");
        this.parse(receiver);
        this.put(", ");
        this.parse(args[0]);
        this.put(")")
      } else if (["-@", "+@", "~", "~"].includes(method)) {
        let child0 = receiver.children[0];

        if (receiver.type === "send" && receiver.children[1] == "+@" && typeof child0 === "object" && child0 !== null && "type" in child0 && typeof child0 === "object" && child0 !== null && "children" in child0 && [
          "class",
          "module"
        ].includes(child0.type)) {
          if (receiver.children[0].type === "class") {
            this.parse(receiver.children[0].updated("class_extend"))
          } else {
            let mod = receiver.children[0];

            this.parse(this.s(
              "assign",
              mod.children[0],
              mod.updated(null, [null, ...mod.children.slice(1)])
            ))
          }
        } else {
          this.put(method.toString()[0]);
          this.parse(receiver)
        }
      } else if (method == "=~") {
        this.parse(args[0]);
        this.put(".test(");
        this.parse(receiver);
        this.put(")")
      } else if (method == "!~") {
        this.put("!");
        this.parse(args[0]);
        this.put(".test(");
        this.parse(receiver);
        this.put(")")
      } else if (method == "<<") {
        if (this.#state == "statement") {
          let current = receiver;
          let operations = [args[0]];

          while (current.type === "send" && current.children[1] == "<<") {
            operations.unshift(current.children[2]);
            current = current.children[0]
          };

          this.parse(current);
          this.put(".push(");

          operations.forEach((arg, index) => {
            if (index > 0) this.put(", ");
            return this.parse(arg)
          });

          this.put(")")
        } else {
          if (group_receiver) {
            this.group(receiver)
          } else {
            this.parse(receiver)
          };

          this.put(" << ");

          if (group_target) {
            this.group(args[0])
          } else {
            this.parse(args[0])
          }
        }
      } else if (method == "<=>") {
        this.parse(receiver);
        this.put(" < ");
        this.parse(args[0]);
        this.put(" ? -1 : ");
        this.parse(receiver);
        this.put(" > ");
        this.parse(args[0]);
        this.put(" ? 1 : 0")
      } else if (Converter.OPERATORS.flat(Infinity).includes(method) && !Converter.LOGICAL.includes(method)) {
        if (group_receiver) {
          this.group(receiver)
        } else {
          this.parse(receiver)
        };

        if (this.#comparison == "identity" && ["==", "!="].includes(method)) {
          this.put(` ${method}= `)
        } else {
          this.put(` ${method} `)
        };

        if (group_target) {
          this.group(target)
        } else {
          this.parse(target)
        }
      } else if (/=$/m.test(method)) {
        if (this.#state == "statement") this.multi_assign_declarations;

        if (group_receiver) {
          this.group(receiver)
        } else {
          this.parse(receiver)
        };

        this.put(`${receiver ? "." : null}${method.toString().replace(
          /=$/m,
          " ="
        )} `);

        this.parse(
          args[0],
          this.#state == "method" ? "method" : "expression"
        )
      } else if (method == "new") {
        if (receiver) {
          if (receiver == this.s("const", null, "Regexp")) {
            receiver = this.s("const", null, "RegExp")
          };

          if (receiver == this.s("const", null, "RegExp")) {
            if (args[0].type === "regexp") {
              let opts = "";

              if (args[0].children.at(-1).children.length > 0) {
                opts = args[0].children.at(-1).children.join
              };

              if (args.length > 1) opts += args.at(-1).children.at(-1);

              return this.parse(this.s(
                "regexp",
                ...args[0].children.slice(0, -1),
                this.s("regopt", ...opts.split("").map(item => item.to_sym))
              ))
            } else if (args[0].type === "str") {
              if (args.length == 2 && args[1].type === "str") {
                opts = args[1].children[0]
              } else {
                opts = ""
              };

              return this.parse(this.s(
                "regexp",
                args[0],
                this.s("regopt", ...opts.each_char.map(c => c))
              ))
            }
          };

          this.put("new ");

          if (group_receiver) {
            this.group(receiver)
          } else {
            this.parse(receiver)
          };

          if (ast.is_is_method()) {
            this.put("(");
            this.parse_all(...args, {join: ", "});
            this.put(")")
          }
        } else if (args.length == 1 && args[0].type === "send") {
          let new_node = args[0].updated("send", [
            this.s("const", ...args[0].children.slice(0, 2)),
            "new",
            ...args[0].children.slice(2)
          ]);

          this.parse(new_node, this.#state)
        } else if (args.length == 1 && args[0].type === "const") {
          this.parse(this.s("attr", args[0], "new"), this.#state)
        } else if (args.length == 2 && ["send", "const"].includes(args[0].type) && args.at(-1).type === "def" && args.at(-1).children[0] == null) {
          this.parse(
            this.s(
              "send",
              this.s("const", null, args[0].children[1]),
              "new",
              ...args[0].children.slice(2),
              args.at(-1)
            ),

            this.#state
          )
        } else {
          throw new Error("use of JavaScript keyword new", this.#ast)
        }
      } else if (method == "raise" && receiver == null) {
        if (args.length == 1) {
          this.put("throw ");
          this.parse(args[0])
        } else {
          this.put("throw new ");
          this.parse(args[0]);
          this.put("(");
          this.parse(args[1]);
          this.put(")")
        }
      } else if (method == "typeof" && receiver == null) {
        this.put("typeof ");
        this.parse(args[0])
      } else if (ast.children[1] == "is_a?" && receiver && args.length == 1) {
        this.put("(");
        this.parse(receiver);
        this.put(" instanceof ");
        this.parse(args[0]);
        this.put(")")
      } else if (ast.children[1] == "kind_of?" && receiver && args.length == 1) {
        this.put("(");
        this.parse(receiver);
        this.put(" instanceof ");
        this.parse(args[0]);
        this.put(")")
      } else if (ast.children[1] == "instance_of?" && receiver && args.length == 1) {
        this.put("(");

        this.parse(this.s(
          "send",
          this.s("attr", receiver, "constructor"),
          "==",
          args[0]
        ));

        this.put(")")
      } else {
        if (method == "bind" && receiver?.type == "send") {
          if (receiver.children.length == 2 && receiver.children[0] == null) {
            receiver = receiver.updated("attr")
          }
        };

        if (!ast.is_is_method() && !["send!", "call", "await"].includes(ast.type)) {
          if (receiver) {
            if (group_receiver) {
              this.group(receiver)
            } else {
              this.parse(receiver)
            };

            this.put(`.${method}`)
          } else if (ast.type === "attr") {
            this.put(method)
          } else {
            this.parse(ast.updated("lvasgn", [method]), this.#state)
          }
        } else if (args.some(arg => arg.type === "splat") && !this.es2015) {
          this.parse(this.s(
            "send",
            this.s("attr", receiver, method),
            "apply",
            receiver || this.s("nil"),
            this.s("array", ...args)
          ))
        } else {
          if (group_receiver) {
            this.group(receiver)
          } else {
            this.parse(receiver)
          };

          this.put(`${receiver && method ? "." : null}${method}`);

          if (args.length <= 1) {
            this.put("(");
            this.parse_all(...args, {join: ", "});
            this.put(")")
          } else {
            this.compact(() => {
              this.puts("(");
              this.parse_all(...args, {join: `,${this._ws}`});
              return this.sput(")")
            })
          }
        };

        if (autobind && !ast.is_is_method() && ast.type != "attr") {
          if (this.#state == "statement") {
            this.put("()")
          } else {
            this.put(".bind(");
            this.parse(autobind);
            this.put(")")
          }
        }
      }
    };

    on_call(receiver, method, ...args) {
      let t2, m2, args2, block, target, group_receiver, group_target, opts;
      this.ast = this.#ast;

      if (args.length == 1 && method == "+") {
        let node = this.collapse_strings(ast);
        if (node != ast) return this.parse(node)
      };

      if (receiver && receiver.type === "begin" && ["irange", "erange"].includes(receiver.children[0].type)) {
        if (method == "to_a") {
          return this.range_to_array(receiver.children[0])
        } else {
          throw new Error(`${receiver.children[0].type} can only be converted to array currently`, receiver.children[0])
        }
      };

      if (/\w[!?]$/m.test(method)) method = method.toString().slice(0, -1);

      if (method == "new" && receiver && receiver.children == [
        null,
        "Class"
      ] && args.at(-1).type === "def" && args.at(-1).children[0] == null) {
        let parent = args.length > 1 ? args[0] : null;

        if (this.es2015) {
          return this.parse(this.s(
            "class2",
            null,
            parent,
            ...args.at(-1).children.slice(2)
          ))
        } else {
          return this.parse(this.s(
            "kwbegin",

            this.s(
              "class",
              this.s("const", null, "$$"),
              parent,
              ...args.at(-1).children.slice(2)
            ),

            this.s("const", null, "$$")
          ))
        }
      };

      if (method == "new" && receiver && receiver.children == [
        null,
        "Proc"
      ]) {
        return this.parse(args[0], this.#state)
      } else if (!receiver && ["lambda", "proc"].includes(method)) {
        if (method == "lambda" && this.#state != "statement") {
          return this.parse(
            this.s(
              args[0].type,
              ...args[0].children.slice(0, -1),
              this.s("autoreturn", args[0].children.at(-1))
            ),

            this.#state
          )
        } else {
          return this.parse(args[0], this.#state)
        }
      };

      if (["call", "[]"].includes(method) && receiver && receiver.type === "block") {
        let [t2, m2, ...args2] = receiver.children[0].children;

        if (!t2 && ["lambda", "proc"].includes(m2) && args2.length == 0) {
          if (this.es2015 || this.#state == "statement") {
            this.group(receiver)
          } else {
            this.parse(receiver)
          };

          this.put("(");
          this.parse_all(...args, {join: ", "});
          this.put(")");
          return
        } else if (!t2 && m2 == "async" && args2.length == 0) {
          this.put("(");
          this.parse(receiver);
          this.put(")()");
          return
        }
      };

      if (method == "await" && this.es2017 && receiver == null && args.length == 2 && args[1].type === "def") {
        args = [this.s("block", args[0], ...args.at(-1).children.slice(1))]
      };

      if (this.es2017 && receiver == null && args.length == 1) {
        if (method == "async") {
          if (args[0].type === "def") {
            return this.parse(args[0].updated("async"))
          } else if (args[0].type === "defs") {
            return this.parse(args[0].updated("asyncs"))
          } else if (args[0].type === "send" && args[0].children[0].type === "block" && args[0].children.at(-1) == "[]") {
            this.put("(async ");
            this.parse(args[0].children[0], "statement");
            this.put(")()");
            return
          } else if (args[0].type === "block") {
            block = args[0];

            if (block.children[0].children.at(-1) == "lambda") {
              return this.parse(block.updated(
                "async",
                [null, block.children[1], this.s("autoreturn", block.children[2])]
              ))
            } else if (block.children[0].children.at(-1) == "proc") {
              return this.parse(block.updated(
                "async",
                [null, ...block.children.slice(1)]
              ))
            } else if (block.children[0].children[1] == "new" && block.children[0].children[0] == this.s(
              "const",
              null,
              "Proc"
            )) {
              return this.parse(block.updated(
                "async",
                [null, ...block.children.slice(1)]
              ))
            }
          }
        } else if (method == "await") {
          if (args[0].type === "send") {
            return this.parse(args[0].updated("await"))
          } else if (args[0].type === "block") {
            block = args[0];

            return this.parse(block.updated(
              null,
              [block.children[0].updated("await"), ...block.children.slice(1)]
            ))
          }
        }
      };

      let op_index = this.operator_index(method);
      if (op_index != -1) target = args[0];
      receiver ||= this.#rbstack.map(rb => rb[method]).filter(x => x != null).at(-1);
      let autobind = null;

      if (receiver) {
        if (receiver.type === "autobind") {
          autobind = receiver = receiver.children[0];
          if (!this.#autobind) autobind = null
        };

        if (receiver) {
          group_receiver = receiver.type === "send" && op_index < this.operator_index(receiver.children[1])
        };

        group_receiver ||= Converter.GROUP_OPERATORS.includes(receiver.type);
        if (receiver.children[1] == "[]") group_receiver = false;

        if (receiver.type === "int" && !Converter.OPERATORS.flat(Infinity).includes(method)) {
          group_receiver = true
        };

        if (!receiver.is_is_method() && receiver.children.at(-1) == "new") {
          group_receiver = true
        }
      };

      if (target) {
        group_target = target.type === "send" && op_index < this.operator_index(target.children[1]);
        group_target ||= Converter.GROUP_OPERATORS.includes(target.type)
      };

      if (this.#ast.type === "await") this.put("await ");

      if (method == "!") {
        this.parse(this.s("not", receiver))
      } else if (method == "[]") {
        if (group_receiver) {
          this.group(receiver)
        } else {
          this.parse(receiver)
        };

        if (args.length == 1 && ["str", "sym"].includes(args[0].type) && /^[a-zA-Z]\w*$/m.test(args[0].children[0].toString())) {
          this.put(`.${args[0].children[0]}`)
        } else {
          this.put("[");
          this.parse_all(...args, {join: ", "});
          this.put("]")
        }
      } else if (method == "[]=") {
        if (group_receiver) {
          this.group(receiver)
        } else {
          this.parse(receiver)
        };

        if (args.length == 2 && ["str", "sym"].includes(args[0].type) && /^[a-zA-Z]\w*$/m.test(args[0].children[0].toString())) {
          this.put(`.${args[0].children[0]} = `)
        } else {
          this.put("[");
          this.parse_all(...args.slice(0, -1), {join: ", "});
          this.put("] = ")
        };

        this.parse(args.at(-1))
      } else if (method == "**" && !this.es2016) {
        this.put("Math.pow(");
        this.parse(receiver);
        this.put(", ");
        this.parse(args[0]);
        this.put(")")
      } else if (["-@", "+@", "~", "~"].includes(method)) {
        let child0 = receiver.children[0];

        if (receiver.type === "send" && receiver.children[1] == "+@" && typeof child0 === "object" && child0 !== null && "type" in child0 && typeof child0 === "object" && child0 !== null && "children" in child0 && [
          "class",
          "module"
        ].includes(child0.type)) {
          if (receiver.children[0].type === "class") {
            this.parse(receiver.children[0].updated("class_extend"))
          } else {
            let mod = receiver.children[0];

            this.parse(this.s(
              "assign",
              mod.children[0],
              mod.updated(null, [null, ...mod.children.slice(1)])
            ))
          }
        } else {
          this.put(method.toString()[0]);
          this.parse(receiver)
        }
      } else if (method == "=~") {
        this.parse(args[0]);
        this.put(".test(");
        this.parse(receiver);
        this.put(")")
      } else if (method == "!~") {
        this.put("!");
        this.parse(args[0]);
        this.put(".test(");
        this.parse(receiver);
        this.put(")")
      } else if (method == "<<") {
        if (this.#state == "statement") {
          let current = receiver;
          let operations = [args[0]];

          while (current.type === "send" && current.children[1] == "<<") {
            operations.unshift(current.children[2]);
            current = current.children[0]
          };

          this.parse(current);
          this.put(".push(");

          operations.forEach((arg, index) => {
            if (index > 0) this.put(", ");
            return this.parse(arg)
          });

          this.put(")")
        } else {
          if (group_receiver) {
            this.group(receiver)
          } else {
            this.parse(receiver)
          };

          this.put(" << ");

          if (group_target) {
            this.group(args[0])
          } else {
            this.parse(args[0])
          }
        }
      } else if (method == "<=>") {
        this.parse(receiver);
        this.put(" < ");
        this.parse(args[0]);
        this.put(" ? -1 : ");
        this.parse(receiver);
        this.put(" > ");
        this.parse(args[0]);
        this.put(" ? 1 : 0")
      } else if (Converter.OPERATORS.flat(Infinity).includes(method) && !Converter.LOGICAL.includes(method)) {
        if (group_receiver) {
          this.group(receiver)
        } else {
          this.parse(receiver)
        };

        if (this.#comparison == "identity" && ["==", "!="].includes(method)) {
          this.put(` ${method}= `)
        } else {
          this.put(` ${method} `)
        };

        if (group_target) {
          this.group(target)
        } else {
          this.parse(target)
        }
      } else if (/=$/m.test(method)) {
        if (this.#state == "statement") this.multi_assign_declarations;

        if (group_receiver) {
          this.group(receiver)
        } else {
          this.parse(receiver)
        };

        this.put(`${receiver ? "." : null}${method.toString().replace(
          /=$/m,
          " ="
        )} `);

        this.parse(
          args[0],
          this.#state == "method" ? "method" : "expression"
        )
      } else if (method == "new") {
        if (receiver) {
          if (receiver == this.s("const", null, "Regexp")) {
            receiver = this.s("const", null, "RegExp")
          };

          if (receiver == this.s("const", null, "RegExp")) {
            if (args[0].type === "regexp") {
              let opts = "";

              if (args[0].children.at(-1).children.length > 0) {
                opts = args[0].children.at(-1).children.join
              };

              if (args.length > 1) opts += args.at(-1).children.at(-1);

              return this.parse(this.s(
                "regexp",
                ...args[0].children.slice(0, -1),
                this.s("regopt", ...opts.split("").map(item => item.to_sym))
              ))
            } else if (args[0].type === "str") {
              if (args.length == 2 && args[1].type === "str") {
                opts = args[1].children[0]
              } else {
                opts = ""
              };

              return this.parse(this.s(
                "regexp",
                args[0],
                this.s("regopt", ...opts.each_char.map(c => c))
              ))
            }
          };

          this.put("new ");

          if (group_receiver) {
            this.group(receiver)
          } else {
            this.parse(receiver)
          };

          if (ast.is_is_method()) {
            this.put("(");
            this.parse_all(...args, {join: ", "});
            this.put(")")
          }
        } else if (args.length == 1 && args[0].type === "send") {
          let new_node = args[0].updated("send", [
            this.s("const", ...args[0].children.slice(0, 2)),
            "new",
            ...args[0].children.slice(2)
          ]);

          this.parse(new_node, this.#state)
        } else if (args.length == 1 && args[0].type === "const") {
          this.parse(this.s("attr", args[0], "new"), this.#state)
        } else if (args.length == 2 && ["send", "const"].includes(args[0].type) && args.at(-1).type === "def" && args.at(-1).children[0] == null) {
          this.parse(
            this.s(
              "send",
              this.s("const", null, args[0].children[1]),
              "new",
              ...args[0].children.slice(2),
              args.at(-1)
            ),

            this.#state
          )
        } else {
          throw new Error("use of JavaScript keyword new", this.#ast)
        }
      } else if (method == "raise" && receiver == null) {
        if (args.length == 1) {
          this.put("throw ");
          this.parse(args[0])
        } else {
          this.put("throw new ");
          this.parse(args[0]);
          this.put("(");
          this.parse(args[1]);
          this.put(")")
        }
      } else if (method == "typeof" && receiver == null) {
        this.put("typeof ");
        this.parse(args[0])
      } else if (ast.children[1] == "is_a?" && receiver && args.length == 1) {
        this.put("(");
        this.parse(receiver);
        this.put(" instanceof ");
        this.parse(args[0]);
        this.put(")")
      } else if (ast.children[1] == "kind_of?" && receiver && args.length == 1) {
        this.put("(");
        this.parse(receiver);
        this.put(" instanceof ");
        this.parse(args[0]);
        this.put(")")
      } else if (ast.children[1] == "instance_of?" && receiver && args.length == 1) {
        this.put("(");

        this.parse(this.s(
          "send",
          this.s("attr", receiver, "constructor"),
          "==",
          args[0]
        ));

        this.put(")")
      } else {
        if (method == "bind" && receiver?.type == "send") {
          if (receiver.children.length == 2 && receiver.children[0] == null) {
            receiver = receiver.updated("attr")
          }
        };

        if (!ast.is_is_method() && !["send!", "call", "await"].includes(ast.type)) {
          if (receiver) {
            if (group_receiver) {
              this.group(receiver)
            } else {
              this.parse(receiver)
            };

            this.put(`.${method}`)
          } else if (ast.type === "attr") {
            this.put(method)
          } else {
            this.parse(ast.updated("lvasgn", [method]), this.#state)
          }
        } else if (args.some(arg => arg.type === "splat") && !this.es2015) {
          this.parse(this.s(
            "send",
            this.s("attr", receiver, method),
            "apply",
            receiver || this.s("nil"),
            this.s("array", ...args)
          ))
        } else {
          if (group_receiver) {
            this.group(receiver)
          } else {
            this.parse(receiver)
          };

          this.put(`${receiver && method ? "." : null}${method}`);

          if (args.length <= 1) {
            this.put("(");
            this.parse_all(...args, {join: ", "});
            this.put(")")
          } else {
            this.compact(() => {
              this.puts("(");
              this.parse_all(...args, {join: `,${this._ws}`});
              return this.sput(")")
            })
          }
        };

        if (autobind && !ast.is_is_method() && ast.type != "attr") {
          if (this.#state == "statement") {
            this.put("()")
          } else {
            this.put(".bind(");
            this.parse(autobind);
            this.put(")")
          }
        }
      }
    };

    on_csend(receiver, method, ...args) {
      // is_a?, kind_of?, instance_of? cannot use optional chaining because
      // they need to be converted to instanceof/constructor checks
      if (["is_a?", "kind_of?", "instance_of?"].includes(method) && args.length == 1) {
        // Convert to: receiver && (receiver instanceof/constructor check)
        // Output directly to avoid rewrite() converting back to csend
        // optional chaining
        this.parse(receiver);
        this.put(" && ");
        this.parse(this.#ast.updated("send"));
        return
      };

      if (this.es2020) {
        this.parse(receiver);
        this.put("?.");

        if (method == "[]") {
          this.put("[");
          this.parse_all(...args, {join: ", "});
          this.put("]")
        } else {
          this.put(method.toString());
          if (this.#ast.is_is_method()) this.put("(");
          this.parse_all(...args, {join: ", "});
          if (this.#ast.is_is_method()) this.put(")")
        }
      } else {
        let node = this.#ast;

        // collect up chain of conditional sends
        let stack = [];

        while (node.children[0].type === "csend") {
          stack.push(node);
          node = node.children[0]
        };

        // conditionally evaluate most nested expression
        let expr = node.updated("send");
        let result = this.s("and", node.children[0], expr);

        // build up chain of conditional evaluations
        while (stack.length != 0) {
          node = stack.pop();
          expr = node.updated("send", [expr, ...node.children.slice(1)]);
          result = this.s("and", result, expr)
        };

        this.parse(result)
      }
    };

    on_splat(expr) {
      this.put("...");
      this.parse(expr)
    };

    // do string concatenation when possible
    collapse_strings(node) {
      let left = node.children[0];
      if (!left) return node;
      let right = node.children[2];

      // recursively evaluate left hand side
      if (left.type === "send" && left.children.length == 3 && left.children[1] == "+") {
        left = this.collapse_strings(left)
      };

      // recursively evaluate right hand side
      if (right.type === "send" && right.children.length == 3 && right.children[1] == "+") {
        right = this.collapse_strings(right)
      };

      // if left and right are both strings, perform concatenation
      if (["dstr", "str"].includes(left.type) && ["dstr", "str"].includes(right.type)) {
        if (left.type === "str" && right.type === "str") {
          return left.updated(null, [left.children[0] + right.children[0]])
        } else {
          if (left.type === "str") left = this.s("dstr", left);
          if (right.type === "str") right = this.s("dstr", right);
          return left.updated(null, left.children + right.children)
        }
      };

      // if left and right are unchanged, return original node; otherwise
      // return node modified to include new left and/or right hand sides.
      if (left == node.children[0] && right == node.children[2]) {
        return node
      } else {
        return node.updated(null, [left, "+", right])
      }
    };

    range_to_array(node) {
      let length, start_value, finish_value, index_var, blank;
      let [start, finish] = node.children;

      if (start.type === "int" && start.children[0] == 0) {
        // Ranges which start from 0 can be achieved with more simpler code
        if (finish.type === "int") {
          // output cleaner code if we know the value already
          length = finish.children[0] + (node.type === "irange" ? 1 : 0)
        } else {
          // If this is variable we need to fix indexing by 1 in js
          length = `${finish.children.at(-1)}` + (node.type === "irange" ? "+1" : "")
        };

        if (this.es2015) {
          return this.put(`[...Array(${length}).keys()]`)
        } else {
          return this.put(`Array.apply(null, {length: ${length}}).map(Function.call, Number)`)
        }
      } else {
        // Use .compact because the first argument is nil with variables
        // This way the first value is always set
        start_value = start.children.filter(x => x != null)[0];
        finish_value = finish.children.filter(x => x != null)[0];

        if (start.type === "int" && finish.type === "int") {
          length = finish_value - start_value + (node.type === "irange" ? 1 : 0)
        } else {
          length = `(${finish_value}-${start_value}` + (node.type === "irange" ? "+1" : "") + ")"
        };

        // Avoid of using same variables in the map as used in the irange or elsewhere in this code
        // Ruby2js only allows dollar sign in beginning of variable so i$ is safe
        if ("idx" in this.#vars || start_value == "idx" || finish_value == "idx") {
          index_var = "i$"
        } else {
          index_var = "idx"
        };

        // Use _ because it's normal convention in JS for variable which is not used at all
        if (this.es2015) {
          if ("_" in this.#vars || start_value == "_" || finish_value == "_") {
            blank = "_$"
          } else {
            blank = "_"
          };

          return this.put(`Array.from({length: ${length}}, (${blank}, ${index_var}) => ${index_var}+${start_value})`)
        } else {
          return this.put(`Array.apply(null, {length: ${length}}).map(Function.call, Number).map(function (${index_var}) { return ${index_var}+${start_value} })`)
        }
      }
    };

    // (def :f
    //   (args
    //     (arg :x)
    //   (...)
    on_def(name, args, body=null) {
      let children, style, nl;
      body ||= this.s("begin");

      // Detect endless method (def foo(x) = expr) and wrap body in autoreturn
      // Endless methods have loc.assignment (the =) but no loc.end
      if (this.#ast.loc && typeof this.#ast.loc === "object" && this.#ast.loc !== null && "assignment" in this.#ast.loc && this.#ast.loc.assignment && typeof this.#ast.loc === "object" && this.#ast.loc !== null && "end" in this.#ast.loc && this.#ast.loc.end == null) {
        body = this.s("autoreturn", body)
      };

      let add_implicit_block = false;

      let walk = (node) => {
        if (node.type === "yield" || node.type === "send" && node.children[1] == "_implicitBlockYield") {
          add_implicit_block = true
        };

        for (let child of node.children) {
          if (typeof child === "object" && child !== null && "type" in child && typeof child === "object" && child !== null && "children" in child) {
            walk[child]
          }
        }
      };

      walk[body];

      if (add_implicit_block) {
        children = Object.assign({}, args.children);
        children.push(this.s("optarg", "_implicitBlockYield", this.s("nil")));
        args = this.s("args", ...children)
      };

      let vars = {};
      if (!name) Object.assign(vars, this.#vars);

      if (args && args.children.length != 0) {
        // splats
        if (args.children.at(-1).type === "restarg" && !this.es2015) {
          if (args.children.at(-1).children[0]) {
            if (body.type !== "begin") body = this.s("begin", body);

            let assign = this.s(
              "lvasgn",
              args.children.at(-1).children[0],

              this.s(
                "send",

                this.s(
                  "attr",
                  this.s("attr", this.s("const", null, "Array"), "prototype"),
                  "slice"
                ),

                "call",
                this.s("lvar", "arguments"),
                this.s("int", args.children.length - 1)
              )
            );

            body = this.s("begin", assign, ...body.children)
          };

          args = this.s("args", ...args.children.slice(0, -1))
        } else if (args.children.at(-1).type === "blockarg" && args.children.length > 1 && args.children.at(-2).type === "restarg") {
          if (body.type !== "begin") body = this.s("begin", body);
          let blk = args.children.at(-1).children[0];
          let vararg = args.children.at(-2).children[0];

          let last = this.s(
            "send",
            this.s("attr", this.s("lvar", "arguments"), "length"),
            "-",
            this.s("int", 1)
          );

          // set block argument to the last argument passed
          let assign2 = this.s(
            "lvasgn",
            blk,
            this.s("send", this.s("lvar", "arguments"), "[]", last)
          );

          if (vararg) {
            // extract arguments between those defined and the last
            let assign1 = this.s("lvasgn", vararg, this.s(
              "send",

              this.s(
                "attr",
                this.s("attr", this.s("const", null, "Array"), "prototype"),
                "slice"
              ),

              "call",
              this.s("lvar", "arguments"),
              this.s("int", args.children.length - 1),
              last
            ));

            // push block argument back onto args if not a function
            let pushback = this.s(
              "if",

              this.s(
                "send",
                this.s("send", null, "typeof", this.s("lvar", blk)),
                "!==",
                this.s("str", "function")
              ),

              this.s(
                "begin",
                this.s("send", this.s("lvar", vararg), "push", this.s("lvar", blk)),
                this.s("lvasgn", blk, this.s("nil"))
              ),

              null
            );

            // set block argument to null if all arguments were defined
            pushback = this.s(
              "if",

              this.s(
                "send",
                this.s("attr", this.s("lvar", "arguments"), "length"),
                "<=",
                this.s("int", args.children.length - 2)
              ),

              this.s("lvasgn", blk, this.s("nil")),
              pushback
            );

            // combine statements
            body = this.s("begin", assign1, assign2, pushback, ...body.children)
          } else {
            // set block argument to null if all arguments were defined
            let ignore = this.s(
              "if",

              this.s(
                "send",
                this.s("attr", this.s("lvar", "arguments"), "length"),
                "<=",
                this.s("int", args.children.length - 2)
              ),

              this.s("lvasgn", blk, this.s("nil")),
              null
            );

            body = this.s("begin", assign2, ignore, ...body.children)
          };

          args = this.s("args", ...args.children.slice(0, -2))
        };

        // optional arguments
        args.children.forEach((arg, i) => {
          let argname, value;

          if (arg.type === "optarg" && !this.es2015) {
            if (body.type !== "begin") body = this.s("begin", body);
            let [argname, value] = arg.children;
            children = Object.assign({}, args.children);
            children[i] = this.s("arg", argname);
            args = this.s("args", ...children);
            if (body.type !== "begin") body = this.s("begin", body);

            let default_ = this.s(
              "if",
              this.s("send", this.s("defined?", this.s("lvar", argname)), "!"),
              this.s("lvasgn", argname, value),
              null
            );

            body = this.s("begin", default_, ...body.children)
          };

          if (arg.type === "shadowarg") {
            delete vars[arg.children[0]]
          } else {
            return vars[arg.children[0]] = true
          }
        })
      };

      if (this.#ast.type === "async") this.put("async ");

      // es2015 fat arrow support
      if (!name && this.es2015 && this.#state != "method" && this.#ast.type != "defm" && this.#ast.type != "deff" && !this.#prop) {
        let expr = body;

        while (expr.type === "autoreturn") {
          expr = expr.children[0]
        };

        while (expr.type === "begin" && expr.children.length == 1) {
          expr = expr.children[0]
        };

        if (expr.type === "return") expr = expr.children[0];

        if (EXPRESSIONS.includes(expr.type)) {
          if (expr.type === "send" && expr.children.slice(0, 2) == [
            null,
            "raise"
          ]) {
            style = "statement"
          } else if (expr.type === "send" && expr.children.length == 2 && expr.children[0] == null && this.#rbstack.at(-1) && this.#rbstack.at(-1)[expr.children[1]]?.type == "autobind") {
            style = "statement"
          } else {
            style = "expression"
          }
        } else if (expr.type === "if" && expr.children[1] && expr.children[2] && EXPRESSIONS.includes(expr.children[1].type) && EXPRESSIONS.includes(expr.children[2].type)) {
          style = "expression"
        } else {
          style = "statement"
        };

        if (args.children.length == 1 && args.children[0].type === "arg" && style == "expression") {
          this.parse(args);
          this.put(" => ")
        } else {
          this.put("(");
          this.parse(args);
          this.put(") => ")
        };

        if (style == "expression") {
          if (expr.type === "taglit") {
            this.parse(expr)
          } else if (expr.type === "hash") {
            this.group(expr)
          } else {
            this.wrap("(", ")", () => this.parse(expr))
          }
        } else if (body.type === "begin" && body.children.length == 0) {
          this.put("{}")
        } else {
          this.put(`{${this._nl}`);
          this.scope(body, vars);
          this.put(`${this._nl}}`)
        };

        return
      };

      if (body != this.s("begin")) nl = this._nl;

      {
        let next_token;

        try {
          if (this.#prop) {
            this.put(this.#prop);
            this.#prop = null
          } else if (name) {
            this.put(`function ${name.toString().replace(/[?!]$/m, "")}`)
          } else {
            this.put("function")
          };

          this.put("(");

          if (args.type === "forward_args") {
            this.parse(args)
          } else {
            this.parse(this.s(
              "args",
              ...args.children.filter(arg => arg.type != "shadowarg")
            ))
          };

          this.put(`) {${nl}`);
          next_token = this.#next_token;
          this.#next_token = "return";
          if (this.#block_depth) this.#block_depth++;
          let mark = this.output_location();
          this.scope(body, vars);

          if (this.#block_this && this.#block_depth == 1) {
            this.insert(
              mark,
              `${this.es2015 ? "let" : "var"} self = this${this._sep}`
            );

            this.#block_this = false
          };

          this.put(`${nl}}`)
        } finally {
          this.#next_token = next_token;
          if (this.#block_depth) this.#block_depth--
        }
      }
    };

    on_defm(name, args, body=null) {
      let children, style, nl;
      body ||= this.s("begin");

      if (this.#ast.loc && typeof this.#ast.loc === "object" && this.#ast.loc !== null && "assignment" in this.#ast.loc && this.#ast.loc.assignment && typeof this.#ast.loc === "object" && this.#ast.loc !== null && "end" in this.#ast.loc && this.#ast.loc.end == null) {
        body = this.s("autoreturn", body)
      };

      let add_implicit_block = false;

      let walk = (node) => {
        if (node.type === "yield" || node.type === "send" && node.children[1] == "_implicitBlockYield") {
          add_implicit_block = true
        };

        for (let child of node.children) {
          if (typeof child === "object" && child !== null && "type" in child && typeof child === "object" && child !== null && "children" in child) {
            walk[child]
          }
        }
      };

      walk[body];

      if (add_implicit_block) {
        children = Object.assign({}, args.children);
        children.push(this.s("optarg", "_implicitBlockYield", this.s("nil")));
        args = this.s("args", ...children)
      };

      let vars = {};
      if (!name) Object.assign(vars, this.#vars);

      if (args && args.children.length != 0) {
        if (args.children.at(-1).type === "restarg" && !this.es2015) {
          if (args.children.at(-1).children[0]) {
            if (body.type !== "begin") body = this.s("begin", body);

            let assign = this.s(
              "lvasgn",
              args.children.at(-1).children[0],

              this.s(
                "send",

                this.s(
                  "attr",
                  this.s("attr", this.s("const", null, "Array"), "prototype"),
                  "slice"
                ),

                "call",
                this.s("lvar", "arguments"),
                this.s("int", args.children.length - 1)
              )
            );

            body = this.s("begin", assign, ...body.children)
          };

          args = this.s("args", ...args.children.slice(0, -1))
        } else if (args.children.at(-1).type === "blockarg" && args.children.length > 1 && args.children.at(-2).type === "restarg") {
          if (body.type !== "begin") body = this.s("begin", body);
          let blk = args.children.at(-1).children[0];
          let vararg = args.children.at(-2).children[0];

          let last = this.s(
            "send",
            this.s("attr", this.s("lvar", "arguments"), "length"),
            "-",
            this.s("int", 1)
          );

          let assign2 = this.s(
            "lvasgn",
            blk,
            this.s("send", this.s("lvar", "arguments"), "[]", last)
          );

          if (vararg) {
            let assign1 = this.s("lvasgn", vararg, this.s(
              "send",

              this.s(
                "attr",
                this.s("attr", this.s("const", null, "Array"), "prototype"),
                "slice"
              ),

              "call",
              this.s("lvar", "arguments"),
              this.s("int", args.children.length - 1),
              last
            ));

            let pushback = this.s(
              "if",

              this.s(
                "send",
                this.s("send", null, "typeof", this.s("lvar", blk)),
                "!==",
                this.s("str", "function")
              ),

              this.s(
                "begin",
                this.s("send", this.s("lvar", vararg), "push", this.s("lvar", blk)),
                this.s("lvasgn", blk, this.s("nil"))
              ),

              null
            );

            pushback = this.s(
              "if",

              this.s(
                "send",
                this.s("attr", this.s("lvar", "arguments"), "length"),
                "<=",
                this.s("int", args.children.length - 2)
              ),

              this.s("lvasgn", blk, this.s("nil")),
              pushback
            );

            body = this.s("begin", assign1, assign2, pushback, ...body.children)
          } else {
            let ignore = this.s(
              "if",

              this.s(
                "send",
                this.s("attr", this.s("lvar", "arguments"), "length"),
                "<=",
                this.s("int", args.children.length - 2)
              ),

              this.s("lvasgn", blk, this.s("nil")),
              null
            );

            body = this.s("begin", assign2, ignore, ...body.children)
          };

          args = this.s("args", ...args.children.slice(0, -2))
        };

        args.children.forEach((arg, i) => {
          let argname, value;

          if (arg.type === "optarg" && !this.es2015) {
            if (body.type !== "begin") body = this.s("begin", body);
            let [argname, value] = arg.children;
            children = Object.assign({}, args.children);
            children[i] = this.s("arg", argname);
            args = this.s("args", ...children);
            if (body.type !== "begin") body = this.s("begin", body);

            let default_ = this.s(
              "if",
              this.s("send", this.s("defined?", this.s("lvar", argname)), "!"),
              this.s("lvasgn", argname, value),
              null
            );

            body = this.s("begin", default_, ...body.children)
          };

          if (arg.type === "shadowarg") {
            delete vars[arg.children[0]]
          } else {
            return vars[arg.children[0]] = true
          }
        })
      };

      if (this.#ast.type === "async") this.put("async ");

      if (!name && this.es2015 && this.#state != "method" && this.#ast.type != "defm" && this.#ast.type != "deff" && !this.#prop) {
        let expr = body;

        while (expr.type === "autoreturn") {
          expr = expr.children[0]
        };

        while (expr.type === "begin" && expr.children.length == 1) {
          expr = expr.children[0]
        };

        if (expr.type === "return") expr = expr.children[0];

        if (EXPRESSIONS.includes(expr.type)) {
          if (expr.type === "send" && expr.children.slice(0, 2) == [
            null,
            "raise"
          ]) {
            style = "statement"
          } else if (expr.type === "send" && expr.children.length == 2 && expr.children[0] == null && this.#rbstack.at(-1) && this.#rbstack.at(-1)[expr.children[1]]?.type == "autobind") {
            style = "statement"
          } else {
            style = "expression"
          }
        } else if (expr.type === "if" && expr.children[1] && expr.children[2] && EXPRESSIONS.includes(expr.children[1].type) && EXPRESSIONS.includes(expr.children[2].type)) {
          style = "expression"
        } else {
          style = "statement"
        };

        if (args.children.length == 1 && args.children[0].type === "arg" && style == "expression") {
          this.parse(args);
          this.put(" => ")
        } else {
          this.put("(");
          this.parse(args);
          this.put(") => ")
        };

        if (style == "expression") {
          if (expr.type === "taglit") {
            this.parse(expr)
          } else if (expr.type === "hash") {
            this.group(expr)
          } else {
            this.wrap("(", ")", () => this.parse(expr))
          }
        } else if (body.type === "begin" && body.children.length == 0) {
          this.put("{}")
        } else {
          this.put(`{${this._nl}`);
          this.scope(body, vars);
          this.put(`${this._nl}}`)
        };

        return
      };

      if (body != this.s("begin")) nl = this._nl;

      {
        let next_token;

        try {
          if (this.#prop) {
            this.put(this.#prop);
            this.#prop = null
          } else if (name) {
            this.put(`function ${name.toString().replace(/[?!]$/m, "")}`)
          } else {
            this.put("function")
          };

          this.put("(");

          if (args.type === "forward_args") {
            this.parse(args)
          } else {
            this.parse(this.s(
              "args",
              ...args.children.filter(arg => arg.type != "shadowarg")
            ))
          };

          this.put(`) {${nl}`);
          next_token = this.#next_token;
          this.#next_token = "return";
          if (this.#block_depth) this.#block_depth++;
          let mark = this.output_location();
          this.scope(body, vars);

          if (this.#block_this && this.#block_depth == 1) {
            this.insert(
              mark,
              `${this.es2015 ? "let" : "var"} self = this${this._sep}`
            );

            this.#block_this = false
          };

          this.put(`${nl}}`)
        } finally {
          this.#next_token = next_token;
          if (this.#block_depth) this.#block_depth--
        }
      }
    };

    on_async(name, args, body=null) {
      let children, style, nl;
      body ||= this.s("begin");

      if (this.#ast.loc && typeof this.#ast.loc === "object" && this.#ast.loc !== null && "assignment" in this.#ast.loc && this.#ast.loc.assignment && typeof this.#ast.loc === "object" && this.#ast.loc !== null && "end" in this.#ast.loc && this.#ast.loc.end == null) {
        body = this.s("autoreturn", body)
      };

      let add_implicit_block = false;

      let walk = (node) => {
        if (node.type === "yield" || node.type === "send" && node.children[1] == "_implicitBlockYield") {
          add_implicit_block = true
        };

        for (let child of node.children) {
          if (typeof child === "object" && child !== null && "type" in child && typeof child === "object" && child !== null && "children" in child) {
            walk[child]
          }
        }
      };

      walk[body];

      if (add_implicit_block) {
        children = Object.assign({}, args.children);
        children.push(this.s("optarg", "_implicitBlockYield", this.s("nil")));
        args = this.s("args", ...children)
      };

      let vars = {};
      if (!name) Object.assign(vars, this.#vars);

      if (args && args.children.length != 0) {
        if (args.children.at(-1).type === "restarg" && !this.es2015) {
          if (args.children.at(-1).children[0]) {
            if (body.type !== "begin") body = this.s("begin", body);

            let assign = this.s(
              "lvasgn",
              args.children.at(-1).children[0],

              this.s(
                "send",

                this.s(
                  "attr",
                  this.s("attr", this.s("const", null, "Array"), "prototype"),
                  "slice"
                ),

                "call",
                this.s("lvar", "arguments"),
                this.s("int", args.children.length - 1)
              )
            );

            body = this.s("begin", assign, ...body.children)
          };

          args = this.s("args", ...args.children.slice(0, -1))
        } else if (args.children.at(-1).type === "blockarg" && args.children.length > 1 && args.children.at(-2).type === "restarg") {
          if (body.type !== "begin") body = this.s("begin", body);
          let blk = args.children.at(-1).children[0];
          let vararg = args.children.at(-2).children[0];

          let last = this.s(
            "send",
            this.s("attr", this.s("lvar", "arguments"), "length"),
            "-",
            this.s("int", 1)
          );

          let assign2 = this.s(
            "lvasgn",
            blk,
            this.s("send", this.s("lvar", "arguments"), "[]", last)
          );

          if (vararg) {
            let assign1 = this.s("lvasgn", vararg, this.s(
              "send",

              this.s(
                "attr",
                this.s("attr", this.s("const", null, "Array"), "prototype"),
                "slice"
              ),

              "call",
              this.s("lvar", "arguments"),
              this.s("int", args.children.length - 1),
              last
            ));

            let pushback = this.s(
              "if",

              this.s(
                "send",
                this.s("send", null, "typeof", this.s("lvar", blk)),
                "!==",
                this.s("str", "function")
              ),

              this.s(
                "begin",
                this.s("send", this.s("lvar", vararg), "push", this.s("lvar", blk)),
                this.s("lvasgn", blk, this.s("nil"))
              ),

              null
            );

            pushback = this.s(
              "if",

              this.s(
                "send",
                this.s("attr", this.s("lvar", "arguments"), "length"),
                "<=",
                this.s("int", args.children.length - 2)
              ),

              this.s("lvasgn", blk, this.s("nil")),
              pushback
            );

            body = this.s("begin", assign1, assign2, pushback, ...body.children)
          } else {
            let ignore = this.s(
              "if",

              this.s(
                "send",
                this.s("attr", this.s("lvar", "arguments"), "length"),
                "<=",
                this.s("int", args.children.length - 2)
              ),

              this.s("lvasgn", blk, this.s("nil")),
              null
            );

            body = this.s("begin", assign2, ignore, ...body.children)
          };

          args = this.s("args", ...args.children.slice(0, -2))
        };

        args.children.forEach((arg, i) => {
          let argname, value;

          if (arg.type === "optarg" && !this.es2015) {
            if (body.type !== "begin") body = this.s("begin", body);
            let [argname, value] = arg.children;
            children = Object.assign({}, args.children);
            children[i] = this.s("arg", argname);
            args = this.s("args", ...children);
            if (body.type !== "begin") body = this.s("begin", body);

            let default_ = this.s(
              "if",
              this.s("send", this.s("defined?", this.s("lvar", argname)), "!"),
              this.s("lvasgn", argname, value),
              null
            );

            body = this.s("begin", default_, ...body.children)
          };

          if (arg.type === "shadowarg") {
            delete vars[arg.children[0]]
          } else {
            return vars[arg.children[0]] = true
          }
        })
      };

      if (this.#ast.type === "async") this.put("async ");

      if (!name && this.es2015 && this.#state != "method" && this.#ast.type != "defm" && this.#ast.type != "deff" && !this.#prop) {
        let expr = body;

        while (expr.type === "autoreturn") {
          expr = expr.children[0]
        };

        while (expr.type === "begin" && expr.children.length == 1) {
          expr = expr.children[0]
        };

        if (expr.type === "return") expr = expr.children[0];

        if (EXPRESSIONS.includes(expr.type)) {
          if (expr.type === "send" && expr.children.slice(0, 2) == [
            null,
            "raise"
          ]) {
            style = "statement"
          } else if (expr.type === "send" && expr.children.length == 2 && expr.children[0] == null && this.#rbstack.at(-1) && this.#rbstack.at(-1)[expr.children[1]]?.type == "autobind") {
            style = "statement"
          } else {
            style = "expression"
          }
        } else if (expr.type === "if" && expr.children[1] && expr.children[2] && EXPRESSIONS.includes(expr.children[1].type) && EXPRESSIONS.includes(expr.children[2].type)) {
          style = "expression"
        } else {
          style = "statement"
        };

        if (args.children.length == 1 && args.children[0].type === "arg" && style == "expression") {
          this.parse(args);
          this.put(" => ")
        } else {
          this.put("(");
          this.parse(args);
          this.put(") => ")
        };

        if (style == "expression") {
          if (expr.type === "taglit") {
            this.parse(expr)
          } else if (expr.type === "hash") {
            this.group(expr)
          } else {
            this.wrap("(", ")", () => this.parse(expr))
          }
        } else if (body.type === "begin" && body.children.length == 0) {
          this.put("{}")
        } else {
          this.put(`{${this._nl}`);
          this.scope(body, vars);
          this.put(`${this._nl}}`)
        };

        return
      };

      if (body != this.s("begin")) nl = this._nl;

      {
        let next_token;

        try {
          if (this.#prop) {
            this.put(this.#prop);
            this.#prop = null
          } else if (name) {
            this.put(`function ${name.toString().replace(/[?!]$/m, "")}`)
          } else {
            this.put("function")
          };

          this.put("(");

          if (args.type === "forward_args") {
            this.parse(args)
          } else {
            this.parse(this.s(
              "args",
              ...args.children.filter(arg => arg.type != "shadowarg")
            ))
          };

          this.put(`) {${nl}`);
          next_token = this.#next_token;
          this.#next_token = "return";
          if (this.#block_depth) this.#block_depth++;
          let mark = this.output_location();
          this.scope(body, vars);

          if (this.#block_this && this.#block_depth == 1) {
            this.insert(
              mark,
              `${this.es2015 ? "let" : "var"} self = this${this._sep}`
            );

            this.#block_this = false
          };

          this.put(`${nl}}`)
        } finally {
          this.#next_token = next_token;
          if (this.#block_depth) this.#block_depth--
        }
      }
    };

    on_deff(name, args, body=null) {
      let children, style, nl;
      body ||= this.s("begin");

      if (this.#ast.loc && typeof this.#ast.loc === "object" && this.#ast.loc !== null && "assignment" in this.#ast.loc && this.#ast.loc.assignment && typeof this.#ast.loc === "object" && this.#ast.loc !== null && "end" in this.#ast.loc && this.#ast.loc.end == null) {
        body = this.s("autoreturn", body)
      };

      let add_implicit_block = false;

      let walk = (node) => {
        if (node.type === "yield" || node.type === "send" && node.children[1] == "_implicitBlockYield") {
          add_implicit_block = true
        };

        for (let child of node.children) {
          if (typeof child === "object" && child !== null && "type" in child && typeof child === "object" && child !== null && "children" in child) {
            walk[child]
          }
        }
      };

      walk[body];

      if (add_implicit_block) {
        children = Object.assign({}, args.children);
        children.push(this.s("optarg", "_implicitBlockYield", this.s("nil")));
        args = this.s("args", ...children)
      };

      let vars = {};
      if (!name) Object.assign(vars, this.#vars);

      if (args && args.children.length != 0) {
        if (args.children.at(-1).type === "restarg" && !this.es2015) {
          if (args.children.at(-1).children[0]) {
            if (body.type !== "begin") body = this.s("begin", body);

            let assign = this.s(
              "lvasgn",
              args.children.at(-1).children[0],

              this.s(
                "send",

                this.s(
                  "attr",
                  this.s("attr", this.s("const", null, "Array"), "prototype"),
                  "slice"
                ),

                "call",
                this.s("lvar", "arguments"),
                this.s("int", args.children.length - 1)
              )
            );

            body = this.s("begin", assign, ...body.children)
          };

          args = this.s("args", ...args.children.slice(0, -1))
        } else if (args.children.at(-1).type === "blockarg" && args.children.length > 1 && args.children.at(-2).type === "restarg") {
          if (body.type !== "begin") body = this.s("begin", body);
          let blk = args.children.at(-1).children[0];
          let vararg = args.children.at(-2).children[0];

          let last = this.s(
            "send",
            this.s("attr", this.s("lvar", "arguments"), "length"),
            "-",
            this.s("int", 1)
          );

          let assign2 = this.s(
            "lvasgn",
            blk,
            this.s("send", this.s("lvar", "arguments"), "[]", last)
          );

          if (vararg) {
            let assign1 = this.s("lvasgn", vararg, this.s(
              "send",

              this.s(
                "attr",
                this.s("attr", this.s("const", null, "Array"), "prototype"),
                "slice"
              ),

              "call",
              this.s("lvar", "arguments"),
              this.s("int", args.children.length - 1),
              last
            ));

            let pushback = this.s(
              "if",

              this.s(
                "send",
                this.s("send", null, "typeof", this.s("lvar", blk)),
                "!==",
                this.s("str", "function")
              ),

              this.s(
                "begin",
                this.s("send", this.s("lvar", vararg), "push", this.s("lvar", blk)),
                this.s("lvasgn", blk, this.s("nil"))
              ),

              null
            );

            pushback = this.s(
              "if",

              this.s(
                "send",
                this.s("attr", this.s("lvar", "arguments"), "length"),
                "<=",
                this.s("int", args.children.length - 2)
              ),

              this.s("lvasgn", blk, this.s("nil")),
              pushback
            );

            body = this.s("begin", assign1, assign2, pushback, ...body.children)
          } else {
            let ignore = this.s(
              "if",

              this.s(
                "send",
                this.s("attr", this.s("lvar", "arguments"), "length"),
                "<=",
                this.s("int", args.children.length - 2)
              ),

              this.s("lvasgn", blk, this.s("nil")),
              null
            );

            body = this.s("begin", assign2, ignore, ...body.children)
          };

          args = this.s("args", ...args.children.slice(0, -2))
        };

        args.children.forEach((arg, i) => {
          let argname, value;

          if (arg.type === "optarg" && !this.es2015) {
            if (body.type !== "begin") body = this.s("begin", body);
            let [argname, value] = arg.children;
            children = Object.assign({}, args.children);
            children[i] = this.s("arg", argname);
            args = this.s("args", ...children);
            if (body.type !== "begin") body = this.s("begin", body);

            let default_ = this.s(
              "if",
              this.s("send", this.s("defined?", this.s("lvar", argname)), "!"),
              this.s("lvasgn", argname, value),
              null
            );

            body = this.s("begin", default_, ...body.children)
          };

          if (arg.type === "shadowarg") {
            delete vars[arg.children[0]]
          } else {
            return vars[arg.children[0]] = true
          }
        })
      };

      if (this.#ast.type === "async") this.put("async ");

      if (!name && this.es2015 && this.#state != "method" && this.#ast.type != "defm" && this.#ast.type != "deff" && !this.#prop) {
        let expr = body;

        while (expr.type === "autoreturn") {
          expr = expr.children[0]
        };

        while (expr.type === "begin" && expr.children.length == 1) {
          expr = expr.children[0]
        };

        if (expr.type === "return") expr = expr.children[0];

        if (EXPRESSIONS.includes(expr.type)) {
          if (expr.type === "send" && expr.children.slice(0, 2) == [
            null,
            "raise"
          ]) {
            style = "statement"
          } else if (expr.type === "send" && expr.children.length == 2 && expr.children[0] == null && this.#rbstack.at(-1) && this.#rbstack.at(-1)[expr.children[1]]?.type == "autobind") {
            style = "statement"
          } else {
            style = "expression"
          }
        } else if (expr.type === "if" && expr.children[1] && expr.children[2] && EXPRESSIONS.includes(expr.children[1].type) && EXPRESSIONS.includes(expr.children[2].type)) {
          style = "expression"
        } else {
          style = "statement"
        };

        if (args.children.length == 1 && args.children[0].type === "arg" && style == "expression") {
          this.parse(args);
          this.put(" => ")
        } else {
          this.put("(");
          this.parse(args);
          this.put(") => ")
        };

        if (style == "expression") {
          if (expr.type === "taglit") {
            this.parse(expr)
          } else if (expr.type === "hash") {
            this.group(expr)
          } else {
            this.wrap("(", ")", () => this.parse(expr))
          }
        } else if (body.type === "begin" && body.children.length == 0) {
          this.put("{}")
        } else {
          this.put(`{${this._nl}`);
          this.scope(body, vars);
          this.put(`${this._nl}}`)
        };

        return
      };

      if (body != this.s("begin")) nl = this._nl;

      {
        let next_token;

        try {
          if (this.#prop) {
            this.put(this.#prop);
            this.#prop = null
          } else if (name) {
            this.put(`function ${name.toString().replace(/[?!]$/m, "")}`)
          } else {
            this.put("function")
          };

          this.put("(");

          if (args.type === "forward_args") {
            this.parse(args)
          } else {
            this.parse(this.s(
              "args",
              ...args.children.filter(arg => arg.type != "shadowarg")
            ))
          };

          this.put(`) {${nl}`);
          next_token = this.#next_token;
          this.#next_token = "return";
          if (this.#block_depth) this.#block_depth++;
          let mark = this.output_location();
          this.scope(body, vars);

          if (this.#block_this && this.#block_depth == 1) {
            this.insert(
              mark,
              `${this.es2015 ? "let" : "var"} self = this${this._sep}`
            );

            this.#block_this = false
          };

          this.put(`${nl}}`)
        } finally {
          this.#next_token = next_token;
          if (this.#block_depth) this.#block_depth--
        }
      }
    };

    on_optarg(name, value) {
      this.put(name);
      this.put("=");
      this.parse(value)
    };

    on_restarg(name) {
      this.put("...");
      this.put(name)
    };

    // (begin
    //   (...)
    //   (...))
    on_begin(...statements) {
      let state = this.#state;
      let props = false;

      if (state == "expression" && statements.length == 0) {
        this.puts("null");
        return
      };

      statements.splice(...[0, statements.length].concat(statements.map((statement) => {
        switch (statement?.type) {
        case "defs":
        case "defp":
          props = true;
          this.#ast = statement;
          transform_defs(...statement.children);
          break;

        case "prop":
          props = true;
          statement;
          break;

        default:
          return statement
        }
      })));

      if (props) {
        if (props) this.combine_properties(statements);

        statements.splice(
          0,
          statements.length,
          ...statements.filter(_x => _x != null)
        )
      };

      this.parse_all(...statements, {state, join: this._sep})
    };

    combine_properties(body) {
      for (let i = 0; i < body.length - 1; i++) {
        if (!body[i] || body[i].type !== "prop") continue;

        for (let j = i + 1; j < body.length; j++) {
          if (!body[j] || body[j].type !== "prop") break;

          if (body[i].children[0] == body[j].children[0]) {
            // relocate property comment to first method
            for (let node of [body[i], body[j]]) {
              let node_comments = this.#comments[node];

              if (node_comments && node_comments.length != 0) {
                for (let [key, value] of node.children[1].values[0]) {
                  if (["get", "set"].includes(key) && typeof value === "object" && value !== null && "type" in value && typeof value === "object" && value !== null && "children" in value) {
                    this.#comments[value] = this.#comments[node];
                    break
                  }
                }
              }
            };

            // merge properties
            let merge = Object.fromEntries(Object.entries((body[i].children[1].to_a + body[j].children[1].to_a).reduce(
              ($acc, name) => {
                let $key = name.toString();
                ($acc[$key] = $acc[$key] || []).push(name);
                return $acc
              },

              {}
            )).map(([name, values]) => (
              [name, values.map(item => item.at(-1)).reduce("merge")]
            )));

            body[j] = this.s("prop", body[j].children[0], merge);
            body[i] = null;
            break
          }
        }
      }
    };

    // (if
    //   (true)
    //   (...)
    //   (...))
    on_if(condition, then_block, else_block) {
      // Pattern: a = b if a.nil?  =>  a ??= b (ES2021+)
      // Pattern: a.nil? ? b : a   =>  a ?? b  (ES2020+)
      if (condition.type === "send" && condition.children[1] == "nil?" && condition.children.slice(2).length == 0) {
        let tested = condition.children[0];

        // Pattern: a = b if a.nil?  =>  a ??= b
        if (this.es2021 && then_block && !else_block) {
          let asgn = then_block;

          if (asgn.type === "lvasgn" && tested.type === "lvar" && asgn.children[0] == tested.children[0]) {
            // a = b if a.nil?  =>  a ??= b
            return this.parse(this.s(
              "op_asgn",
              this.s("lvasgn", tested.children[0]),
              "??",
              asgn.children[1]
            ))
          } else if (asgn.type === "ivasgn" && tested.type === "ivar" && asgn.children[0] == tested.children[0]) {
            // @a = b if @a.nil?  =>  @a ??= b
            return this.parse(this.s(
              "op_asgn",
              this.s("ivasgn", tested.children[0]),
              "??",
              asgn.children[1]
            ))
          } else if (asgn.type === "cvasgn" && tested.type === "cvar" && asgn.children[0] == tested.children[0]) {
            // @@a = b if @@a.nil?  =>  @@a ??= b
            return this.parse(this.s(
              "op_asgn",
              this.s("cvasgn", tested.children[0]),
              "??",
              asgn.children[1]
            ))
          } else if (asgn.type === "send" && (asgn.children[1] || "").toString().endsWith("=") && asgn.children[1] != "[]=" && tested.type === "send" && asgn.children[0] == tested.children[0] && (asgn.children[1] || "").toString().chomp("=") == (tested.children[1] || "").toString()) {
            // self.a = b if self.a.nil?  =>  self.a ??= b
            // a[i] = b if a[i].nil?  =>  a[i] ??= b
            this.parse(tested);
            this.put(" ??= ");
            this.parse(asgn.children[2]);
            return
          } else if (asgn.type === "send" && asgn.children[1] == "[]=" && tested.type === "send" && tested.children[1] == "[]" && asgn.children[0] == tested.children[0] && asgn.children[2] == tested.children[2]) {
            this.parse(tested);
            this.put(" ??= ");
            this.parse(asgn.children[3]);
            return
          }
        };

        // Pattern: a.nil? ? b : a  =>  a ?? b
        if (this.es2020 && then_block && else_block && else_block == tested) {
          this.parse(tested);
          this.put(" ?? ");
          this.parse(then_block);
          return
        }
      };

      // return parse not condition if else_block and no then_block
      if (else_block && !then_block) {
        return this.parse(
          this.s("if", this.s("not", condition), else_block, null),
          this.#state
        )
      };

      then_block ||= this.s("nil");

      if (this.#state == "statement") {
        {
          let inner;

          try {
            inner = this.#inner;
            this.#inner = this.#ast;

            if (else_block || then_block.type === "begin") {
              this.put("if (");
              this.parse(condition);
              this.puts(") {");
              this.jscope(then_block);
              this.sput("}");

              while (else_block && else_block.type === "if") {
                [condition, then_block, else_block] = else_block.children;

                if (then_block) {
                  this.put(" else if (");
                  this.parse(condition);
                  this.puts(") {");
                  this.jscope(then_block);
                  this.sput("}")
                } else {
                  this.put(" else if (");
                  this.parse(this.s("not", condition));
                  this.puts(") {");
                  this.jscope(else_block);
                  this.sput("}");
                  else_block = null
                }
              };

              if (else_block) {
                this.puts(" else {");
                this.jscope(else_block);
                this.sput("}")
              }
            } else {
              if (["lvasgn", "gvasgn"].includes(then_block.type)) {
                this.#vars[then_block.children[0]] ||= "pending"
              };

              this.put("if (");
              this.parse(condition);
              this.put(") ");
              this.wrap(() => this.jscope(then_block))
            }
          } finally {
            this.#inner = inner
          }
        }
      } else {
        // use short form when appropriate
        // "Lexical declaration cannot appear in a single-statement context"
        else_block ||= this.s("nil");

        if (this.#jsx) {
          if (then_block.type === "begin") {
            then_block = this.s("xnode", "", ...then_block.children)
          };

          if (else_block.type === "begin") {
            else_block = this.s("xnode", "", ...else_block.children)
          }
        } else {
          if (then_block.type === "begin") then_block = this.s("kwbegin", then_block);
          if (else_block.type === "begin") else_block = this.s("kwbegin", else_block)
        };

        this.parse(condition);
        this.put(" ? ");
        this.parse(then_block, this.#state);
        this.put(" : ");
        this.parse(else_block, this.#state)
      }
    };

    // (xstr
    //   (str 'a'))
    // (for
    //   (lvasgn :i)
    //   (array
    //     (int 1))
    //   (...)
    on_for(var_, expression, block) {
      if (this.#jsx && this.#ast.type === "for_of") {
        this.parse(this.s(
          "block",
          this.s("send", expression, "map"),
          this.s("args", this.s("arg", var_.children[0])),
          this.s("autoreturn", block)
        ));

        return
      };

      {
        let next_token;
        let vars;

        try {
          vars = Object.assign({}, this.#vars);
          next_token = this.#next_token;
          this.#next_token = "continue";
          this.put(`for (${this.es2015 ? "let" : "var"} `);
          this.parse(var_);

          if (expression && ["irange", "erange"].includes(expression.type)) {
            this.put(" = ");
            this.parse(expression.children[0]);
            this.put("; ");
            this.parse(var_);

            if (expression.type === "erange") {
              this.put(" < ")
            } else {
              this.put(" <= ")
            };

            this.parse(expression.children.at(-1));
            this.put("; ");
            this.parse(var_);
            this.put("++")
          } else {
            this.put(this.#ast.type === "for_of" ? " of " : " in ");
            this.parse(expression)
          };

          this.puts(") {");
          this.redoable(block);
          this.sput("}")
        } finally {
          this.#next_token = next_token;
          if (this.es2015) this.#vars = vars
        }
      }
    };

    on_for_of(var_, expression, block) {
      if (this.#jsx && this.#ast.type === "for_of") {
        this.parse(this.s(
          "block",
          this.s("send", expression, "map"),
          this.s("args", this.s("arg", var_.children[0])),
          this.s("autoreturn", block)
        ));

        return
      };

      {
        let next_token;
        let vars;

        try {
          vars = Object.assign({}, this.#vars);
          next_token = this.#next_token;
          this.#next_token = "continue";
          this.put(`for (${this.es2015 ? "let" : "var"} `);
          this.parse(var_);

          if (expression && ["irange", "erange"].includes(expression.type)) {
            this.put(" = ");
            this.parse(expression.children[0]);
            this.put("; ");
            this.parse(var_);

            if (expression.type === "erange") {
              this.put(" < ")
            } else {
              this.put(" <= ")
            };

            this.parse(expression.children.at(-1));
            this.put("; ");
            this.parse(var_);
            this.put("++")
          } else {
            this.put(this.#ast.type === "for_of" ? " of " : " in ");
            this.parse(expression)
          };

          this.puts(") {");
          this.redoable(block);
          this.sput("}")
        } finally {
          this.#next_token = next_token;
          if (this.es2015) this.#vars = vars
        }
      }
    };

    // (and
    //   (...)
    //   (...))
    // (or
    //   (...)
    //   (...))
    // Note: not handled below
    //   (...))
    // Comparison operators that indicate a boolean context
    static COMPARISON_OPS = [
      "<",
      "<=",
      ">",
      ">=",
      "==",
      "!=",
      "===",
      "!==",
      "=~",
      "!~"
    ];

    // Check if a node represents a boolean expression (comparison, boolean literal, etc.)
    is_boolean_expression(node) {
      let method;
      if (!node) return false;

      switch (node.type) {
      case "true":
      case "false":
        return true;

      case "send":

        // Check for comparison operators
        method = node.children[1];
        if (Converter.COMPARISON_OPS.includes(method)) return true;

        // Check for predicate methods (ending with ?)
        if (method.toString().endsWith("?")) return true;
        false;
        break;

      case "and":
      case "or":
      case "not":
        return true;

      case "begin":

        // Check the inner expression
        return node.children.length == 1 && this.is_boolean_expression(node.children[0]);

      default:
        return false
      }
    };

    on_and(left, right) {
      let type = this.#ast.type;

      if (this.es2020 && type == "and") {
        let node = this.rewrite(left, right);

        if (node.type === "csend") {
          return this.parse(right.updated(node.type, node.children))
        } else {
          [left, right] = node.children
        }
      };

      let op_index = this.operator_index(type);
      let lgroup = Converter.LOGICAL.includes(left.type) && op_index < this.operator_index(left.type);
      if (left && left.type === "begin") lgroup = true;
      let rgroup = Converter.LOGICAL.includes(right.type) && op_index < this.operator_index(right.type);
      if (right.type === "begin") rgroup = true;
      if (lgroup) this.put("(");
      this.parse(left);
      if (lgroup) this.put(")");

      // Use || instead of ?? in boolean contexts even when nullish option is set
      let use_nullish = this.#or == "nullish" && this.es2020 && !this.is_boolean_expression(left) && !this.is_boolean_expression(right);
      this.put(type == "and" ? " && " : use_nullish ? " ?? " : " || ");
      if (rgroup) this.put("(");
      this.parse(right);
      if (rgroup) this.put(")")
    };

    on_or(left, right) {
      let type = this.#ast.type;

      if (this.es2020 && type == "and") {
        let node = this.rewrite(left, right);

        if (node.type === "csend") {
          return this.parse(right.updated(node.type, node.children))
        } else {
          [left, right] = node.children
        }
      };

      let op_index = this.operator_index(type);
      let lgroup = Converter.LOGICAL.includes(left.type) && op_index < this.operator_index(left.type);
      if (left && left.type === "begin") lgroup = true;
      let rgroup = Converter.LOGICAL.includes(right.type) && op_index < this.operator_index(right.type);
      if (right.type === "begin") rgroup = true;
      if (lgroup) this.put("(");
      this.parse(left);
      if (lgroup) this.put(")");
      let use_nullish = this.#or == "nullish" && this.es2020 && !this.is_boolean_expression(left) && !this.is_boolean_expression(right);
      this.put(type == "and" ? " && " : use_nullish ? " ?? " : " || ");
      if (rgroup) this.put("(");
      this.parse(right);
      if (rgroup) this.put(")")
    };

    // (not
    //   (...))
    on_not(expr) {
      let group;

      if (expr.type === "send" && Converter.INVERT_OP.includes(expr.children[1])) {
        this.parse(this.s(
          "send",
          expr.children[0],
          Converter.INVERT_OP[expr.children[1]],
          expr.children[2]
        ))
      } else if (expr.type === "defined?") {
        this.parse(this.s("undefined?", ...expr.children))
      } else if (expr.type === "or") {
        this.parse(this.s(
          "and",
          this.s("not", expr.children[0]),
          this.s("not", expr.children[1])
        ))
      } else if (expr.type === "and") {
        this.parse(this.s(
          "or",
          this.s("not", expr.children[0]),
          this.s("not", expr.children[1])
        ))
      } else if (expr.type === "send" && expr.children.slice(0, 2) == [
        null,
        "typeof"
      ] && expr.children[2]?.type == "send" && Converter.INVERT_OP.includes(expr.children[2].children[1])) {
        // Handle "not typeof x == y" => "typeof x != y"
        // Ruby parses "typeof x == y" as "typeof(x == y)" due to precedence
        this.comparison = expr.children[2];

        this.parse(this.s(
          "send",
          this.s("send", null, "typeof", comparison.children[0]),
          Converter.INVERT_OP[comparison.children[1]],
          comparison.children[2]
        ))
      } else {
        this.group = Converter.LOGICAL.includes(expr.type) && this.operator_index("not") < this.operator_index(expr.type);
        if (expr && ["begin", "in?"].includes(expr.type)) group = true;
        this.put("!");
        if (group) this.put("(");
        this.parse(expr);
        if (group) this.put(")")
      }
    };

    // rewrite a && a.b to a&.b
    rewrite(left, right) {
      if (left && left.type === "and") left = this.rewrite(...left.children);

      if (right.type != "send" || Converter.OPERATORS.flat(Infinity).includes(right.children[1])) {
        return this.s("and", left, right)
      } else if (this.conditionally_equals(left, right.children[0])) {
        // a && a.b => a&.b
        return right.updated("csend", [left, ...right.children.slice(1)])
      } else if (this.conditionally_equals(
        left.children.at(-1),
        right.children[0]
      )) {
        // a && b && b.c => a && b&.c
        return left.updated(
          "and",

          [left.children[0], left.children.at(-1).updated(
            "csend",
            [left.children.at(-1), ...right.children.slice(1)]
          )]
        )
      } else {
        return this.s("and", left, right)
      }
    };

    // determine if two trees are identical, modulo conditionalilties
    // in other words a.b == a&.b
    conditionally_equals(left, right) {
      if (left == right) {
        return true
      } else if (typeof left !== "object" || !left !== null || !("type" in left) || !left || !right || left.type != "csend" || right.type != "send") {
        return false
      } else {
        return this.conditionally_equals(left.children[0], right.children[0]) && this.conditionally_equals(
          left.children.at(-1),
          right.children.at(-1)
        )
      }
    };

    // (return
    //   (int 1))
    on_return(value=null) {
      if (value) {
        this.put("return ");
        this.parse(value)
      } else {
        this.put("return")
      }
    };

    static EXPRESSIONS = [
      "array",
      "float",
      "hash",
      "int",
      "lvar",
      "nil",
      "send",
      "attr",
      "str",
      "sym",
      "dstr",
      "dsym",
      "cvar",
      "ivar",
      "zsuper",
      "super",
      "or",
      "and",
      "block",
      "const",
      "true",
      "false",
      "xnode",
      "taglit",
      "self",
      "op_asgn",
      "and_asgn",
      "or_asgn",
      "taglit",
      "gvar",
      "csend",
      "call"
    ];

    on_autoreturn(...statements) {
      if (statements == [null]) return;
      let block = Object.assign({}, statements);

      while (block.length == 1 && block[0].type === "begin") {
        block = Object.assign({}, block[0].children)
      };

      if (block == []) return;

      if (Converter.EXPRESSIONS.includes(block.at(-1).type)) {
        block.push(this.#ast.updated("return", [block.pop()]))
      } else if (block.at(-1).type === "if") {
        let node = block.pop();

        if (node.children[1] && node.children[2] && Converter.EXPRESSIONS.includes(node.children[1].type) && Converter.EXPRESSIONS.includes(node.children[2].type)) {
          node = this.s("return", node)
        } else {
          let conditions = [[
            node.children[0],
            node.children[1] ? this.s("autoreturn", node.children[1]) : null
          ]];

          while (node.children[2] && node.children[2].type === "if") {
            node = node.children[2];

            conditions.unshift([
              node.children[0],
              node.children[1] ? this.s("autoreturn", node.children[1]) : null
            ])
          };

          node = node.children[2] ? this.s("autoreturn", node.children[2]) : null;

          for (let [condition, cstatements] of conditions) {
            node = this.s("if", condition, cstatements, node)
          }
        };

        block.push(node)
      } else if (block.at(-1).type === "case") {
        let node = block.pop();
        let children = Object.assign({}, node.children);

        for (let i = 1; i < children.length; i++) {
          if (children[i] == null) continue;

          // case statements without else clause end with nil
          if (children[i].type === "when") {
            let gchildren = Object.assign({}, children[i].children);

            if (gchildren.length != 0 && Converter.EXPRESSIONS.includes(gchildren.at(-1).type)) {
              gchildren.push(this.s("return", gchildren.pop()));
              children[i] = children[i].updated(null, gchildren)
            }
          } else if (Converter.EXPRESSIONS.includes(children[i].type)) {
            children[i] = children[i].updated("return", [children[i]])
          }
        };

        block.push(node.updated(null, children))
      } else if (block.at(-1).type === "lvasgn") {
        block.push(this.s("return", this.s("lvar", block.at(-1).children[0])))
      } else if (block.at(-1).type === "ivasgn") {
        block.push(this.s("return", this.s("ivar", block.at(-1).children[0])))
      } else if (block.at(-1).type === "cvasgn") {
        block.push(this.s("return", this.s("cvar", block.at(-1).children[0])))
      };

      if (block.length == 1) {
        this.parse(block[0], this.#state)
      } else {
        this.parse(this.s("begin", ...block), this.#state)
      }
    };

    // (masgn
    //   (mlhs
    //     (lvasgn :a)
    //     (lvasgn :b))
    //   (array
    //     (int 1)
    //     (int 2)))
    on_masgn(lhs, rhs) {
      let block;

      // Check if destructuring is safe. JavaScript has these constraints:
      // - `let [a, b] = x` works (all new local vars)
      // - `[this.a, this.b] = x` works (all property assignments, no let)
      // - `let a; [a, this.b] = x` works (pre-declared local + property)
      // - `let [a, this.b] = x` FAILS (can't mix let with property in same destructure)
      //
      // We allow destructuring if all targets are the same "kind":
      // - All local variables (lvasgn), OR
      // - All non-local (ivasgn, cvasgn, etc.)
      let has_lvasgn = lhs.children.some(c => (
        c.type === "lvasgn" || c.type === "mlhs" || c.type === "splat"
      ));

      let has_non_lvasgn = lhs.children.some(c => (
        ["ivasgn", "cvasgn", "gvasgn", "send"].includes(c.type)
      ));

      // If mixed local and non-local, fall through to non-destructuring path
      let use_destructuring = this.es2015 && !has_lvasgn || !has_non_lvasgn;

      if (use_destructuring) {
        let walk = (node) => {
          let results = [];

          for (let var_ of node.children) {
            if (var_.type === "lvasgn") {
              results.push(var_)
            } else if (var_.type === "mlhs" || var_.type === "splat") {
              results += walk[var_]
            }
          };

          return results
        };

        let vars = walk[lhs];
        let newvars = vars.filter(var_ => !(var_.children[0] in this.#vars));

        if (newvars.length > 0) {
          if (vars == newvars) {
            this.put("let ")
          } else {
            this.put(`let ${newvars.map(var_ => var_.children.at(-1)).join(", ")}${this._sep}`)
          }
        };

        for (let var_ of newvars) {
          this.#vars[var_.children.at(-1)] ||= this.#inner ? "pending" : true
        };

        this.put("[");

        lhs.children.forEach((child, index) => {
          if (index != 0) this.put(", ");
          return this.parse(child)
        });

        this.put("] = ");
        this.parse(rhs)
      } else if (rhs.type === "array") {
        if (lhs.children.length == rhs.children.length) {
          block = [];

          // Mark new local vars as :masgn to tell vasgn handler not to treat as setters
          // The marker will be cleared to true when actually processed
          for (let var_ of lhs.children) {
            if (var_.type === "lvasgn" && !(var_.children[0] in this.#vars)) {
              this.#vars[var_.children[0]] = "masgn"
            }
          };

          // Mark new local vars as :masgn to tell vasgn handler not to treat as setters
          lhs.children.zip(
            rhs.children.zip,
            (var_, val) => block.push(this.s(var_.type, ...var_.children, ...val))
          );

          this.parse(this.s("begin", ...block), this.#state)
        } else {
          throw new Error("unmatched assignment", this.#ast)
        }
      } else {
        block = [];

        for (let var_ of lhs.children) {
          if (var_.type === "lvasgn" && !(var_.children[0] in this.#vars)) {
            this.#vars[var_.children[0]] = "masgn"
          }
        };

        lhs.children.forEach((var_, i) => (
          block.push(this.s(
            var_.type,
            ...var_.children,
            this.s("send", rhs, "[]", this.s("int", i))
          ))
        ));

        this.parse(this.s("begin", ...block), this.#state)
      }
    }
  };

  return {Error, Converter}
})();
      // Discover and register all on_* handler methods
      // The Ruby code uses handle(:type) { } which calls define_method and registers the type.
      // After transpilation, we have on_* methods but the #$handlers static array is empty.
      // We populate it by scanning for on_* methods on the prototype.
      (function() {
        const { Converter } = Ruby2JS;
        const proto = Converter.prototype;
        const types = [];
        for (const key of Object.getOwnPropertyNames(proto)) {
          if (key.startsWith('on_') && typeof proto[key] === 'function') {
            types.push(key.slice(3)); // Remove 'on_' prefix
          }
        }
        // Store in a way that the constructor can access
        Converter._discoveredHandlers = types;
      })();

      // Re-export classes for convenience
      // Note: Token, Line, Serializer are defined in preamble (not in Ruby2JS)
      const { Converter } = Ruby2JS;
      export { Node, s, Token, Line, Serializer, Ruby2JS, Converter };
