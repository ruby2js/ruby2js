// Auto-generated by Ruby2JS self-hosting
// This module provides a JavaScript implementation of Ruby2JS

// AST Node class
class Node {
  constructor(type, children = []) {
    this.type = type;
    this.children = Object.freeze(children);
    this.loc = null;
  }

  updated(newType, newChildren) {
    const n = new Node(newType || this.type, newChildren || this.children);
    n.loc = this.loc;
    return n;
  }
}

// S-expression helper
function s(type, ...children) {
  return new Node(type, children);
}

// Stub base classes
class NotImplementedError extends Error {
  constructor(message) {
    super(message);
    this.name = 'NotImplementedError';
  }
}

// Ruby Hash class stub (used for type checking in parse_all)
class Hash {}

// Token - wraps a string with AST location info
// Hand-written because Ruby's def empty? doesn't transpile to valid JS
class Token {
  constructor(value, ast) {
    this.value = value != null ? String(value) : '';
    this.ast = ast;
    this.loc = ast?.location || null;
  }
  toString() { return this.value; }
  get length() { return this.value.length; }
  isEmpty() { return this.value.length === 0; }
  startsWith(...args) { return this.value.startsWith(...args); }
  endsWith(...args) { return this.value.endsWith(...args); }
  gsub(pattern, replacement) { return this.value.replace(new RegExp(pattern, 'g'), replacement); }
  charAt(i) { return this.value[i]; }
  plus(other) { return this.value + String(other); }
}

// Line - holds tokens for a single output line
// Hand-written because Ruby's def empty? doesn't transpile to valid JS
class Line {
  constructor(...args) {
    this.tokens = args;
    this.indent = 0;
  }
  get length() { return this.tokens.length; }
  get(i) { return this.tokens[i]; }
  set(i, v) { this.tokens[i] = v; }
  push(...args) { this.tokens.push(...args); return this; }
  pop() { return this.tokens.pop(); }
  shift() { return this.tokens.shift(); }
  unshift(...args) { this.tokens.unshift(...args); return this; }
  get first() { return this.tokens[0]; }
  get last() { return this.tokens[this.tokens.length - 1]; }
  isEmpty() { return this.tokens.every(t => t.isEmpty()); }
  each(fn) { this.tokens.forEach(fn); }
  eachWithIndex(fn) { this.tokens.forEach((t, i) => fn(t, i)); }
  map(fn) { return this.tokens.map(fn); }
  find(fn) { return this.tokens.find(fn); }
  includes(item) { return this.tokens.includes(item); }
  toArray() { return this.tokens.map(t => t.toString()); }
  join(sep = '') { return this.tokens.map(t => t.toString()).join(sep); }
  insert(i, ...items) { this.tokens.splice(i, 0, ...items); }
  splice(start, count, ...items) {
    const removed = this.tokens.splice(start, count, ...items);
    return removed;
  }
  findLastIndex(fn) {
    for (let i = this.tokens.length - 1; i >= 0; i--) {
      if (fn(this.tokens[i])) return i;
    }
    return null;
  }
  isComment() {
    const first = this.find(t => !t.isEmpty());
    return first && first.startsWith('//');
  }
  toString() {
    if (this.isEmpty()) return '';
    const content = this.join();
    const first = this.tokens[0]?.toString();
    if (first === 'case ' || first === 'default:') {
      return ' '.repeat(Math.max(0, this.indent - 2)) + content;
    }
    if (this.indent > 0) return ' '.repeat(this.indent) + content;
    return content;
  }
}

// Serializer - output formatting for the converter
// Hand-written because the Ruby version has operator overloading (def +)
// and other patterns that don't transpile cleanly
class Serializer {
  constructor() {
    this._sep = '; ';
    this._nl = '';
    this._ws = ' ';
    this._width = 80;
    this._indent = 0;
    this._lines = [new Line()];
    this._line = this._lines[this._lines.length - 1];
    this._timestamps = {};
    this._ast = null;
    this.file_name = '';
  }

  enable_vertical_whitespace() {
    this._sep = ";\n";
    this._nl = "\n";
    this._ws = this._nl;
    this._indent = 2;
  }

  // indent multi-line parameter lists, array constants, blocks
  reindent(lines) {
    let indent = 0;
    for (const line of lines) {
      const first = line.find(token => !token.isEmpty());
      if (first) {
        const lastIdx = line.findLastIndex(token => !token.isEmpty());
        const last = line.get(lastIdx);
        if ((first.startsWith('<') && line.includes('>')) ||
            (last && last.endsWith('>') && line.includes('<'))) {
          const node = line.join('').match(/.*?(<.*)/)?.[1] || '';
          if (node.startsWith('</')) indent -= this._indent;
          line.indent = indent;
          const node2 = line.join('').match(/.*(<.*)/)?.[1] || '';
          if (!node2.includes('</') && !node2.includes('/>')) indent += this._indent;
        } else {
          if (')}]'.includes(first.charAt(0)) && indent >= this._indent) indent -= this._indent;
          line.indent = indent;
          if (last && '({['.includes(last.charAt(last.length - 1))) indent += this._indent;
        }
      } else {
        line.indent = indent;
      }
    }
  }

  // add horizontal (indentation) and vertical (blank lines) whitespace
  respace() {
    if (this._indent === 0) return;
    this.reindent(this._lines);

    for (let i = this._lines.length - 3; i >= 0; i--) {
      if (this._lines[i].length === 0) {
        this._lines.splice(i, 1);
      } else if (
        this._lines[i+1].isComment() && !this._lines[i].isComment() &&
        this._lines[i].indent === this._lines[i+1].indent
      ) {
        this._lines.splice(i+1, 0, new Line());
      } else if (
        this._lines[i].indent === this._lines[i+1].indent &&
        this._lines[i+1].indent < this._lines[i+2]?.indent &&
        !this._lines[i].isComment()
      ) {
        this._lines.splice(i+1, 0, new Line());
      } else if (
        this._lines[i].indent > this._lines[i+1].indent &&
        this._lines[i+1].indent === this._lines[i+2]?.indent &&
        !this._lines[i+2]?.isEmpty()
      ) {
        this._lines.splice(i+2, 0, new Line());
      }
    }
  }

  // add a single token to the current line
  put(string) {
    if (!(typeof string === 'string') || !string.includes('\n')) {
      this._line.push(new Token(string, this._ast));
    } else {
      const parts = string.split('\n');
      const first = parts.shift();
      if (first) this._line.push(new Token(first, this._ast));
      for (const part of parts) {
        this._lines.push(new Line(new Token(part, this._ast)));
      }
      if (string.endsWith('\n')) this._lines.push(new Line());
      this._line = this._lines[this._lines.length - 1];
    }
  }

  // add a single token and advance to next line
  puts(string) {
    if (!(typeof string === 'string') || !string.includes('\n')) {
      this._line.push(new Token(string, this._ast));
    } else {
      this.put(string);
    }
    this._line = new Line();
    this._lines.push(this._line);
  }

  // advance to next line and add a single token
  sput(string) {
    if (!(typeof string === 'string') || !string.includes('\n')) {
      this._line = new Line(new Token(string, this._ast));
      this._lines.push(this._line);
    } else {
      this._line = new Line();
      this._lines.push(this._line);
      this.put(string);
    }
  }

  // current location: [line number, token number]
  output_location() {
    return [this._lines.length - 1, this._line.length];
  }

  // insert a line into the output
  insert(mark, line) {
    if (mark[1] === 0) {
      this._lines.splice(mark[0], 0, new Line(new Token(line.replace(/\n$/, ''), this._ast)));
    } else {
      this._lines[mark[0]].splice(mark[1], 0, new Token(line, this._ast));
    }
  }

  // capture (and remove) tokens from the output stream
  capture(block) {
    const mark = this.output_location();
    block();
    let lines = this._lines.splice(mark[0] + 1);
    this._line = this._lines[this._lines.length - 1];

    if (lines.length === 0) {
      lines = [new Line(...this._line.splice(mark[1]))];
    } else if (this._line.length !== mark[1]) {
      lines.unshift(new Line(...this._line.splice(mark[1])));
    }

    return lines.map(l => l.join()).join(this._ws);
  }

  // wrap long statements in curly braces
  wrap(open = '{', close = '}', block) {
    this.puts(open);
    const mark = this.output_location();
    block();

    if (
      this._lines.length > mark[0] + 1 ||
      this._lines[mark[0] - 1].join().length + this._line.join().length >= this._width
    ) {
      this.sput(close);
    } else {
      this._line = this._lines[mark[0] - 1];
      const lastLine = this._lines.pop();
      this._line.pop();
      lastLine.each(token => this._line.push(token));
    }
  }

  // compact small expressions into a single line
  compact(block) {
    const mark = this.output_location();
    block();
    if (this._lines.length - mark[0] <= 1) return;
    if (this._indent === 0) return;

    let work = [];
    let len = 0;
    let trail = null;
    let split = null;
    const slice = this._lines.slice(mark[0]);
    this.reindent(slice);

    for (let index = 0; index < slice.length; index++) {
      const line = slice[index];
      if (line.length === 0) line.push(new Token('', null));
      if (line.first.startsWith('//')) {
        len += this._width;
      } else {
        if (trail === line.indent && this._indent > 0) { work.push(new Token(' ', null)); len += 1; }
        len += line.map(t => t.length).reduce((a, b) => a + b, 0);
        line.each(token => work.push(token));

        if (trail === this._indent && line.indent === this._indent) {
          split = [len, work.length, index];
          if (len >= this._width - 10) break;
        }
        trail = line.indent;
      }
    }

    if (len < this._width - 10) {
      this._lines.splice(mark[0], this._lines.length - mark[0]);
      this._lines.push(new Line(...work));
      this._line = this._lines[this._lines.length - 1];
    } else if (split && split[0] < this._width - 10) {
      if (slice[split[2]].indent < slice[split[2] + 1]?.indent) {
        const close = slice.pop();
        close.each(token => slice[slice.length - 1].push(token));
        this._lines[mark[0]] = new Line(...work.slice(0, split[1]));
        this._lines.splice(mark[0] + 1, this._lines.length - mark[0] - 1, ...slice.slice(split[2] + 1));
        this._line = this._lines[this._lines.length - 1];
      }
    }
  }

  // return the output as a string
  to_s() {
    if (this._str) return this._str;
    this.respace();
    return this._lines.map(l => l.toString()).join(this._nl);
  }
}

// Forward declaration for module (assigned by transpiled code)
let Ruby2JS;

// Token wraps a string with AST location info for sourcemaps
class Token {
  #string = string.toString();
  #ast = ast;
  #loc;

  get loc() {
    return this.#loc
  };

  set loc(loc) {
    this.#loc = loc
  };

  get ast() {
    return this.#ast
  };

  set ast(ast) {
    this.#ast = ast
  };

  constructor(string, ast) {
    if (ast && typeof ast === "object" && ast !== null && "location" in ast) {
      this.#loc = ast.location
    }
  };

  get to_s() {
    return this.#string
  };

  get to_str() {
    return this.#string
  };

  get length() {
    return this.#string.length
  };

  empty() {
    return this.#string.length == 0
  };

  start_with(...args) {
    return this.#string.startsWith(...args)
  };

  end_with(...args) {
    return this.#string.endsWith(...args)
  };

  [](index) {
    return this.#string[index]
  }
};

// Line holds tokens for a single output line
class Line {
  #tokens = tokens;
  #indent;

  get indent() {
    return this.#indent
  };

  set indent(indent) {
    this.#indent = indent
  };

  constructor(...tokens) {
    this._indent = 0
  };

  <<(token) {
    this.#tokens.push(token);
    return this
  };

  push(...tokens) {
    this.#tokens.push(...tokens);
    return this
  };

  get pop() {
    this.#tokens.pop()
  };

  get first() {
    return this.#tokens[0]
  };

  get last() {
    return this.#tokens.at(-1)
  };

  get length() {
    return this.#tokens.length
  };

  [](index) {
    return this.#tokens[index]
  };

  set [](index, value) {
    return this.#tokens[index] = value
  };

  find(block) {
    return this.#tokens.find(block)
  };

  rindex(block) {
    return this.#tokens.lastIndexOf(block)
  };

  each(block) {
    return this.#tokens.forEach(block)
  };

  each_with_index(block) {
    return this.#tokens.forEach(block)
  };

  map(block) {
    return this.#tokens.map(block)
  };

  include(item) {
    return this.#tokens.some(t => t.toString() == item.toString())
  };

  insert(index, ...items) {
    return this.#tokens.insert(index, ...items)
  };

  slice(range) {
    return this.#tokens.splice(range, 1)
  };

  unshift(...items) {
    this.#tokens.unshift(...items);
    return this
  };

  get to_a() {
    return this.#tokens.map(item => item.toString())
  };

  join(sep="") {
    return this.#tokens.map(item => item.toString()).join(sep)
  };

  is_comment() {
    let first_token = this.find(token => token.length != 0);
    return first_token?.startsWith("//")
  };

  empty() {
    return this.#tokens.every(token => token.length == 0)
  };

  get to_s() {
    if (this.length == 0) {
      return ""
    } else if (["case ", "default:"].includes((this.#tokens[0] || "").toString())) {
      return " ".repeat(Math.max(0, this.indent() - 2)) + this.join.bind(this)
    } else if (this.indent() > 0) {
      return " ".repeat(this.indent()) + this.join.bind(this)
    } else {
      return this.join.bind(this)
    }
  };

  // For array-like concatenation: work += line
  get to_ary() {
    return this.#tokens
  }
};

class Serializer {
  #ast;
  #file_name;
  #line;
  #mappings;
  #mark;
  #sourcemap;
  #str;
  #timestamps;

  get timestamps() {
    return this.#timestamps
  };

  get file_name() {
    return this.#file_name
  };

  set file_name(file_name) {
    this.#file_name = file_name
  };

  constructor() {
    this._sep = "; ";
    this._nl = "";
    this._ws = " ";
    this._width = 80;
    this._indent = 0;
    this._lines = [new Line];
    this.#line = this._lines.at(-1);
    this.#timestamps = {};
    this.#ast = null;
    this.#file_name = ""
  };

  timestamp(file) {
    if (file) {
      if (File.is_exist(file)) return this.#timestamps[file] = File.mtime(file)
    }
  };

  is_uptodate() {
    if (this.#timestamps.length == 0) return false;
    return this.#timestamps.every((file, mtime) => File.mtime(file) == mtime)
  };

  get mtime() {
    if (this.#timestamps.length == 0) return Time.now;
    return this.#timestamps.values.max
  };

  get enable_vertical_whitespace() {
    this._sep = ";\n";
    this._nl = "\n";
    this._ws = this._nl;
    return this._indent = 2
  };

  // indent multi-line parameter lists, array constants, blocks
  reindent(lines) {
    let indent = 0;

    for (let line of lines) {
      let first = line.find(token => token.length != 0);

      if (first) {
        let last = line[(() => {
          let _i = line.findLastIndex(token => token.length != 0);
          return _i >= 0 ? _i : null
        })()];

        if (first.startsWith("<") && line.includes(">") || last.endsWith(">") && line.includes("<")) {
          let node = line.join.match(/.*?(<.*)/)?.[1];
          if (node.startsWith("</")) indent -= this._indent;
          line.indent = indent;
          node = line.join.match(/.*(<.*)/)?.[1];
          if (!node.includes("</") && !node.includes("/>")) indent += this._indent
        } else {
          if (")}]".includes(first[0]) && indent >= this._indent) indent -= this._indent;
          line.indent = indent;
          if ("({[".includes(last.at(-1))) indent += this._indent
        }
      } else {
        line.indent = indent
      }
    }
  };

  respace() {
    if (this._indent == 0) return;
    this.reindent(this._lines);

    {
      let i = this._lines.length - 3;

      while (i >= 0) {
        if (this._lines[i].length == 0) {
          delete this._lines[i]
        } else if (this._lines[i + 1].is_comment() && !this._lines[i].is_comment() && this._lines[i].indent() == this._lines[i + 1].indent()) {
          this._lines.insert(i + 1, new Line)
        } else if (this._lines[i].indent() == this._lines[i + 1].indent() && this._lines[i + 1].indent() < parseInt(this._lines[i + 2].indent()) && !this._lines[i].is_comment()) {
          this._lines.insert(i + 1, new Line)
        } else if (this._lines[i].indent() > this._lines[i + 1].indent() && this._lines[i + 1].indent() == parseInt(this._lines[i + 2].indent()) && !this._lines[i + 2].length?.==(0)) {
          this._lines.insert(i + 2, new Line)
        };

        i--
      }
    }
  };

  // add horizontal (indentation) and vertical (blank lines) whitespace
  // before a comment
  // start of indented block
  // end of indented block
  // add a single token to the current line
  put(string) {
    let parts, first;

    if (String && string?.includes("\n")) {
      parts = string.split("\n");
      first = parts.shift();
      if (first) this.#line.push(new Token(first, this.#ast));

      for (let part of parts) {
        this._lines.push(new Line(new Token(part, this.#ast)))
      };

      if (string.endsWith("\n")) this._lines.push(new Line);
      this.#line = this._lines.at(-1);
      return this.#line
    } else {
      return this.#line.push(new Token(string, this.#ast))
    }
  };

  put_bang(string) {
    return this.#line.push(new Token(string.replaceAll("\r", "\n"), this.#ast))
  };

  // add a single token to the current line without checking for newline
  // add a single token to the current line and then advance to next line
  puts(string) {
    if (String && string?.includes("\n")) {
      this.put(string)
    } else {
      this.#line.push(new Token(string, this.#ast))
    };

    this.#line = new Line;
    return this._lines.push(this.#line)
  };

  // advance to next line and then add a single token to the current line
  sput(string) {
    if (String && string?.includes("\n")) {
      this.#line = new Line;
      this._lines.push(this.#line);
      return this.put(string)
    } else {
      this.#line = new Line(new Token(string, this.#ast));
      return this._lines.push(this.#line)
    }
  };

  // current location: [line number, token number]
  get output_location() {
    return [this._lines.length - 1, this.#line.length]
  };

  // insert a line into the output
  insert(mark, line) {
    return mark.at(-1) == 0 ? this._lines.insert(
      mark[0],
      new Line(new Token(line.chomp, this.#ast))
    ) : this._lines[mark[0]].insert(
      mark.at(-1),
      new Token(line, this.#ast)
    )
  };

  // capture (and remove) tokens from the output stream
  capture(block) {
    let mark = this.output_location();
    block.call;
    let lines = this._lines.splice(mark[0] + 1) || [];
    this.#line = this._lines.at(-1);

    if (lines.length == 0) {
      lines = [this.#line.splice(mark.at(-1)) || []]
    } else if (this.#line.length != mark.at(-1)) {
      lines.unshift(this.#line.splice(mark.at(-1)) || [])
    };

    return lines.map(l => (
      typeof l === "object" && l !== null && "join" in l ? l.join : l.map(item => (
        item.toString()
      )).join
    )).join(this._ws)
  };

  // wrap long statements in curly braces
  wrap(open="{", close="}", _implicitBlockYield=null) {
    let popped;
    this.puts(open);
    let mark = this.output_location();
    _implicitBlockYield();

    if (this._lines.length > mark[0] + 1 || this._lines[mark[0] - 1].join.length + this.#line.join.length >= this._width) {
      return this.sput(close)
    } else {
      this.#line = this._lines[mark[0] - 1];
      this.#line.pop();
      popped = this._lines.pop();
      return this.#line.push(...popped.to_ary)
    }
  };

  compact(_implicitBlockYield=null) {
    let close;
    let mark = this.output_location();
    _implicitBlockYield();
    if (this._lines.length - mark[0] <= 1) return;
    if (this._indent == 0) return;
    let work = [];
    let len = 0;
    let trail = null;
    let split = null;
    let slice = this._lines.slice(mark[0]);
    this.reindent(slice);

    {
      let index = 0;

      while (index < slice.length()) {
        let line = slice[index];
        if (line.length == 0) line.push(new Token("", null));

        if (line[0].startsWith("//")) {
          len += this._width
        } else {
          if (trail == line.indent() && this._indent > 0) {
            work.push(new Token(" ", null));
            len++
          };

          len += line.map(item => item.length).reduce((a, b) => a + b, 0);
          work.push(...line.to_ary);

          if (trail == this._indent && line.indent() == this._indent) {
            split = [len, work.length, index];
            if (len >= this._width - 10) break
          };

          trail = line.indent()
        };

        index++
      }
    };

    if (len < this._width - 10) {
      this._lines.splice(mark[0]);
      this._lines.push(new Line(...work));
      this.#line = this._lines.at(-1);
      return this.#line
    } else if (split && split[0] < this._width - 10) {
      if (slice[split[2]].indent() < parseInt(slice[split[2] + 1].indent())) {
        close = slice.pop();
        slice.at(-1).push(...close.to_ary);
        this._lines[mark[0]] = new Line(...work.slice(0, split[1] - 1 + 1));
        this._lines.splice(mark[0] + 1);

        for (let line of slice.slice(split[2] + 1)) {
          this._lines.push(line)
        };

        this.#line = this._lines.at(-1);
        return this.#line
      }
    }
  };

  // remove the open brace
  // compact small expressions into a single line
  // survey what we have to work with, keeping track of a possible
  // split of the last argument or value
  // comments are a deal breaker
  // full collapse
  // collapse all but the last argument (typically a hash or function)
  // return the output as a string
  get to_s() {
    if (this.#str) return this.#str;
    let respace;
    this.#str = this._lines.map(item => item.toString()).join(this._nl);
    return this.#str
  };

  get to_str() {
    return this.#str ||= this.to_s()
  };

  static BASE64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

  // https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit
  // http://sokra.github.io/source-map-visualization/
  vlq(...mark) {
    let diffs;

    if (!this.#mark) {
      diffs = mark;
      this.#mark = [0, 0, 0, 0, 0, 0]
    } else {
      if (this.#mark[0] == mark[0]) {
        if (this.#mark[4] == mark[4] && this.#mark[3] == mark[3]) return;
        if (this.#mappings != "") this.#mappings += ","
      };

      diffs = mark.zip(this.#mark).map((a, b) => a - b)
    };

    while (this.#mark[0] < mark[0]) {
      this.#mappings += ";";
      this.#mark[0]++;
      diffs[1] = mark[1]
    };

    this.#mark.splice(0, mark.length - 0, ...mark);

    for (let diff of diffs.slice(1)) {
      let data, encoded;

      if (diff < 0) {
        data = -diff.push(1) + 1
      } else {
        data = diff.push(1)
      };

      if (data <= 31) {
        encoded = Serializer.BASE64[data]
      } else {
        encoded = "";

        do {
          let digit = data & 31;
          data >>= 5;
          if (data > 0) digit |= 32;
          encoded += Serializer.BASE64[digit]
        } while (data > 0)
      };

      this.#mappings += encoded
    }
  };

  // workaround https://github.com/opal/opal/issues/575
  get sourcemap() {
    let respace;
    this.#mappings = "";
    let sources = [];
    let names = [];
    this.#mark = null;

    this._lines.forEach((line, row) => {
      let col = line.indent();

      for (let token of line) {
        if (typeof token === "object" && token !== null && "loc" in token && token.loc && typeof token.loc === "object" && token.loc !== null && "expression" in token.loc && token.loc.expression) {
          let pos = token.loc.expression.begin_pos;
          let buffer = token.loc.expression.source_buffer;
          let source_index = sources.indexOf(buffer);

          if (!source_index) {
            source_index = sources.length;
            this.timestamp(buffer.name);
            sources.push(buffer)
          };

          let line_num = buffer.line_for_position(pos) - 1;
          let column = buffer.column_for_position(pos);
          let name = null;

          if (["lvasgn", "lvar"].includes(token.ast.type)) {
            name = token.ast.children[0]
          } else if (["casgn", "const"].includes(token.ast.type)) {
            if (token.ast.children[0] == null) name = token.ast.children[1]
          };

          if (name) {
            let index = names.find_index(name);

            if (!index) {
              index = names.length;
              names.push(name)
            };

            this.vlq(row, col, source_index, line_num, column, index)
          } else {
            this.vlq(row, col, source_index, line_num, column)
          }
        };

        col += token.length
      }
    });

    this.#sourcemap = {
      version: 3,
      file: this.#file_name,
      sources: sources.map(item => item.name),
      names: names.map(item => item.toString()),
      mappings: this.#mappings
    };

    return this.#sourcemap
  }
};

class Error extends NotImplementedError {
  constructor(message, ast) {
    let loc = ast.loc;

    if (loc) {
      if (typeof loc === "object" && loc !== null && "expression" in loc && loc.expression) {
        // Parser gem location
        message += " at " + loc.expression.source_buffer.name.toString();
        message += ":" + JSON.stringify(loc.expression.line);
        message += ":" + loc.expression.column.toString()
      } else if (Object.prototype.toString.call(loc) === "[object Object]" && loc.start_offset) {
        // Ruby2JS::Node location (prism-direct)
        message += " at offset " + (loc.start_offset || "").toString()
      }
    };

    super(message)
  }
};

class Converter extends Serializer {
  #ast;
  #autobind;
  #binding;
  #block_depth;
  #block_this;
  #class_name;
  #class_parent;
  #comments;
  #comparison;
  #eslevel;
  #handlers;
  #inner;
  #instance_method;
  #ivars;
  #jsx;
  #module_type;
  #namespace;
  #next_token;
  #options;
  #or;
  #prop;
  #prototype;
  #rbstack;
  #redoable;
  #scope;
  #state;
  #strict;
  #timestamps;
  #underscored_private;
  #vars;
  #varstack;

  get ast() {
    return this.#ast
  };

  set ast(ast) {
    this.#ast = ast
  };

  static LOGICAL = ["and", "not", "or"];

  static OPERATORS = [
    ["[]", "[]="],
    ["not", "!"],
    ["**"],
    ["*", "/", "%"],
    ["+", "-"],
    [">>", "<<"],
    ["&"],
    ["^", "|"],
    ["<=", "<", ">", ">="],
    ["==", "!=", "===", "!==", "=~", "!~"],
    ["and", "or"]
  ];

  static INVERT_OP = {
    "<": ">=",
    "<=": ">",
    "==": "!=",
    "!=": "==",
    ">": "<=",
    ">=": "<",
    "===": "!=="
  };

  static GROUP_OPERATORS = [
    "begin",
    "dstr",
    "dsym",
    "and",
    "or",
    "casgn",
    "if"
  ];

  static VASGN = ["cvasgn", "ivasgn", "gvasgn", "lvasgn"];

  get binding() {
    return this.#binding
  };

  set binding(binding) {
    this.#binding = binding
  };

  get ivars() {
    return this.#ivars
  };

  set ivars(ivars) {
    this.#ivars = ivars
  };

  get namespace() {
    return this.#namespace
  };

  set namespace(namespace) {
    this.#namespace = namespace
  };

  constructor(ast, comments, vars={}) {
    super();

    [this.#ast, this.#comments, this.#vars] = [
      ast,
      comments,
      Object.assign({}, vars)
    ];

    this.#varstack = [];
    this.#scope = ast;
    this.#inner = null;
    this.#rbstack = [];
    this.#next_token = "return";
    this.#handlers = {};

    for (let name of Object.getOwnPropertyNames(Object.getPrototypeOf(this)).filter(k => (
      k.startsWith("on_")
    ))) {
      this.#handlers[name.slice(3)] = this[name]
    };

    this.#state = null;
    this.#block_this = null;
    this.#block_depth = null;
    this.#prop = null;
    this.#instance_method = null;
    this.#prototype = null;
    this.#class_parent = null;
    this.#class_name = null;
    this.#jsx = false;
    this.#autobind = true;
    this.#eslevel = "es5";
    this.#strict = false;
    this.#comparison = "equality";
    this.#or = "logical";
    this.#underscored_private = true;
    this.#redoable = false
  };

  set width(width) {
    return this._width = width
  };

  convert() {
    this.scope(this.#ast);

    if (this.#strict) {
      return this._sep == "; " ? this._lines[0].unshift(`"use strict"${this._sep}`) : this._lines.unshift(new Line("\"use strict\";"))
    }
  };

  operator_index(op) {
    return Converter.OPERATORS.indexOf(Converter.OPERATORS.find(el => (
      el.includes(op)
    ))) || -1
  };

  // define a new scope; primarily determines what variables are visible and deals with hoisting of
  // declarations
  scope(ast, args=null) {
    {
      let scope;
      let inner;

      try {
        scope = this.#scope;
        this.#scope = ast;
        inner = this.#inner;
        this.#inner = null;
        let mark = this.output_location();
        this.#varstack.push(this.#vars);
        if (args) this.#vars = args;

        this.#vars = Object.fromEntries(Object.entries(this.#vars).map(([key, value]) => (
          [key, true]
        )));

        this.parse(ast, "statement");

        let vars = Object.entries(this.#vars).filter(([key, value]) => (
          value == "pending"
        )).map(e => e[0]);

        if (vars.length != 0) {
          this.insert(
            mark,
            `${this.es2015 ? "let" : "var"} ${vars.join(", ")}${this._sep}`
          );

          for (let var_ of vars) {
            this.#vars[var_] = true
          }
        }
      } finally {
        this.#vars = this.#varstack.pop();
        this.#scope = scope;
        this.#inner = inner
      }
    }
  };

  // retroactively add a declaration for 'pending' variables
  // handle the oddity where javascript considers there to be a scope (e.g. the body of an if statement),
  // whereas Ruby does not.
  jscope(ast, args=null) {
    try {
      this.#varstack.push(this.#vars);
      if (args) this.#vars = args;

      this.#vars = Object.fromEntries(Object.entries(this.#vars).map(([key, value]) => (
        [key, true]
      )));

      this.parse(ast, "statement")
    } finally {
      let pending = Object.fromEntries(Object.entries(this.#vars).filter(([key, value]) => (
        value == "pending"
      )));

      this.#vars = this.#varstack.pop();
      Object.assign(this.#vars, pending)
    }
  };

  s(type, ...args) {
    return null
  };

  get strict() {
    return this.#strict
  };

  set strict(strict) {
    this.#strict = strict
  };

  get eslevel() {
    return this.#eslevel
  };

  set eslevel(eslevel) {
    this.#eslevel = eslevel
  };

  get module_type() {
    return this.#module_type
  };

  set module_type(module_type) {
    this.#module_type = module_type
  };

  get comparison() {
    return this.#comparison
  };

  set comparison(comparison) {
    this.#comparison = comparison
  };

  get or() {
    return this.#or
  };

  set or(or) {
    this.#or = or
  };

  get underscored_private() {
    return this.#underscored_private
  };

  set underscored_private(underscored_private) {
    this.#underscored_private = underscored_private
  };

  get es2015() {
    return this.#eslevel >= 2_015
  };

  get es2016() {
    return this.#eslevel >= 2_016
  };

  get es2017() {
    return this.#eslevel >= 2_017
  };

  get es2018() {
    return this.#eslevel >= 2_018
  };

  get es2019() {
    return this.#eslevel >= 2_019
  };

  get es2020() {
    return this.#eslevel >= 2_020
  };

  get es2021() {
    return this.#eslevel >= 2_021
  };

  get es2022() {
    return this.#eslevel >= 2_022
  };

  get es2023() {
    return this.#eslevel >= 2_023
  };

  get es2024() {
    return this.#eslevel >= 2_024
  };

  get es2025() {
    return this.#eslevel >= 2_025
  };

  static #$handlers = [];

  static handle() {
    let types = Array.prototype.slice.call(
      arguments,
      1,
      arguments.length - 1
    );

    let block = arguments[arguments.length - 1];

    if (arguments.length <= 0) {
      block = null
    } else if (typeof block !== "function") {
      types.push(block);
      block = null
    };

    for (let type of types) {
      define_method(`on_${type}`, block);
      Converter.#$handlers.push(type)
    }
  };

  // extract comments that either precede or are included in the node.
  // remove from the list so this node's comments won't appear again later in the tree.
  comments(ast) {
    let list;
    let [comment_list, comment_key] = this.find_comment_entry(ast);

    if (ast.loc && typeof ast.loc === "object" && ast.loc !== null && "expression" in ast.loc) {
      let expression = ast.loc.expression;

      list = comment_list.filter(comment => (
        expression.source_buffer == comment.loc.expression.source_buffer && comment.loc.expression.begin_pos < expression.end_pos
      ))
    } else {
      list = comment_list
    };

    if (this.#comments.has(comment_key) && this.#comments[comment_key]) {
      this.#comments[comment_key] -= list
    };

    return list.map((comment) => {
      if (comment.text.startsWith("=begin")) {
        return comment.text.includes("*/") ? comment.text.replace(
          /^=begin/,
          ""
        ).replace(/^=end\Z/m, "").replaceAll(/^/gm, "//") : comment.text.replace(
          /^=begin/,
          "/*"
        ).replace(/^=end\Z/m, "*/")
      } else {
        return comment.text.replace(/^#/m, "//") + "\n"
      }
    })
  };

  // Find comments for an AST node using multiple lookup strategies:
  // 1. Direct lookup by object identity
  // 2. Location-based lookup (for nodes recreated by filters with same location)
  // 3. First-child location lookup (for synthetic nodes wrapping real content)
  // Returns [comment_list, comment_key] where comment_key is used for removal
  find_comment_entry(ast) {
    let comment_list = this.#comments[ast];
    if (comment_list && comment_list.length != 0) return [comment_list, ast];

    if (ast.loc && typeof ast.loc === "object" && ast.loc !== null && "expression" in ast.loc && ast.loc.expression) {
      let expression = ast.loc.expression;

      for (let [key, value] of this.#comments) {
        if (key == "_raw" || value == null || value.length == 0) continue;

        if (typeof key !== "object" || !key !== null || !("loc" in key) || typeof key.loc !== "object" || !key.loc !== null || !("expression" in key.loc)) {
          continue
        };

        let key_expr = key.loc.expression;
        if (!key_expr) continue;

        if (key_expr.source_buffer == expression.source_buffer && key_expr.begin_pos == expression.begin_pos && key_expr.end_pos == expression.end_pos) {
          return [value, key]
        }
      }
    };

    if (!ast.loc || typeof ast.loc !== "object" || !ast.loc !== null || !("expression" in ast.loc) || !ast.loc.expression) {
      let first_loc = this.find_first_location(ast);

      if (first_loc) {
        for (let [key, value] of this.#comments) {
          if (key == "_raw" || value == null || value.length == 0) continue;

          if (typeof key !== "object" || !key !== null || !("loc" in key) || typeof key.loc !== "object" || !key.loc !== null || !("expression" in key.loc)) {
            continue
          };

          let key_expr = key.loc.expression;
          if (!key_expr || key_expr.source_buffer != first_loc.source_buffer) continue;
          if (key_expr.begin_pos <= first_loc.begin_pos + 1) return [value, key]
        }
      }
    };

    return [[], ast]
  };

  // First try direct lookup by object identity
  // If ast has location info, try location-based lookup
  // This handles cases where filters created new nodes with same location
  // For synthetic nodes (no location), try to find comments via first child with location
  // If the key starts at or near where our content starts, use its comments
  // If no first_loc (empty synthetic node), don't try to find comments
  // Find the first source location in an AST tree (depth-first)
  find_first_location(ast) {
    if (typeof ast !== "object" || !ast !== null || !("children" in ast)) {
      return null
    };

    if (ast.loc && typeof ast.loc === "object" && ast.loc !== null && "expression" in ast.loc && ast.loc.expression) {
      return ast.loc.expression
    };

    for (let child of ast.children) {
      if (typeof child !== "object" || !child !== null || !("type" in child) || typeof child !== "object" || !child !== null || !("children" in child)) {
        continue
      };

      let loc = this.find_first_location(child);
      if (loc) return loc
    };

    return null
  };

  parse(ast, state="expression") {
    {
      let oldast;
      let oldstate;

      try {
        oldstate = this.#state;
        this.#state = state;
        oldast = this.#ast;
        this.#ast = ast;
        if (!ast) return;
        let handler = this.#handlers[ast.type];
        if (!handler) throw new Error(`unknown AST type ${ast.type}`, ast);

        if (state == "statement") {
          for (let comment of this.comments(ast)) {
            this.puts(comment.chomp)
          }
        };

        handler.call(this, ...ast.children)
      } finally {
        this.#ast = oldast;
        this.#state = oldstate
      }
    }
  };

  parse_all(...args) {
    this.#options = typeof args.at(-1) === "object" && args.at(-1) !== null && !args.at(-1).type ? args.pop() : {};
    let sep = (this.#options.join || "").toString();
    let state = this.#options.state || "expression";
    let index = 0;

    for (let arg of args) {
      if (index != 0) this.put(sep);
      this.parse(arg, state);
      if (arg != this.s("begin")) index++
    }
  };

  group(ast) {
    if (["dstr", "dsym"].includes(ast.type) && this.es2015) {
      return this.parse(ast)
    } else {
      this.put("(");
      this.parse(ast);
      return this.put(")")
    }
  };

  redoable(block) {
    {
      let save_redoable;

      try {
        save_redoable = this.#redoable;

        let has_redo = node => (
          node.children.some((child) => {
            if (typeof child !== "object" || !child !== null || !("type" in child) || typeof child !== "object" || !child !== null || !("children" in child)) {
              return false
            };

            if (child.type === "redo") return true;

            if (["for", "while", "while_post", "until", "until_post"].includes(child.type)) {
              return false
            };

            return has_redo[child]
          })
        );

        this.#redoable = has_redo[this.#ast];

        if (this.#redoable) {
          this.put(this.es2015 ? "let " : "var ");
          this.put(`redo$${this._sep}`);
          this.puts("do {");
          this.put(`redo$ = false${this._sep}`);
          this.scope(block);
          this.put(`${this._nl}} while(redo$)`)
        } else {
          this.scope(block)
        }
      } finally {
        this.#redoable = save_redoable
      }
    }
  };

  timestamp(file) {
    super.timestamp(file);
    if (!file) return;

    let walk = (ast) => {
      if (ast.loc && typeof ast.loc === "object" && ast.loc !== null && "expression" in ast.loc && ast.loc.expression) {
        let filename = ast.loc.expression.source_buffer.name;

        if (filename && filename.length != 0) {
          this.#timestamps[filename] ||= (() => {
            try {
              File.mtime(filename)
            } catch {
              null
            }
          })()
        }
      };

      for (let child of ast.children) {
        if (typeof child === "object" && child !== null && "type" in child && typeof child === "object" && child !== null && "children" in child) {
          walk[child]
        }
      }
    };

    if (this.#ast) return walk[this.#ast]
  }
};

Converter.prototype.number_format = (number) => {
  if (!this.es2021) return number.toString();
  let parts = number.toString().split(".");
  parts[0] = parts[0].replaceAll(/(\d)(?=(\d\d\d)+(?!\d))/g, "$1_");
  if (parts[1]) parts[1] = parts[1].replaceAll(/(\d\d\d)(?=\d)/g, "$1_");
  return parts.join(".")
};

Converter.prototype.is_hoist = (outer, inner, name) => {
  for (let var_ of outer.children) {
    if (var_ == inner) continue;
    if (var_ == name && ["lvar", "gvar"].includes(outer.type)) return true;

    if (typeof var_ === "object" && var_ !== null && "type" in var_ && typeof var_ === "object" && var_ !== null && "children" in var_ && is_hoist(
      var_,
      inner,
      name
    )) return true
  };

  return false
};

Converter.prototype.multi_assign_declarations = () => {
  let undecls = [];
  let child = this.#ast;

  while (true) {
    let subchild;

    if (["send", "casgn"].include(child.type)) {
      subchild = child.children[2]
    } else {
      subchild = child.children[1]
    };

    if (subchild.type == "send") {
      if (!/=$/m.test(subchild.children[1])) break
    } else if (!["send", "cvasgn", "ivasgn", "gvasgn", "lvasgn"].include(subchild.type)) {
      break
    };

    child = subchild;

    if (child.type == "lvasgn" && !this.#vars.include(child.children[0])) {
      undecls.push(child.children[0])
    }
  };

  if (undecls.length != 0) {
    if (this.es2015) {
      this.put("let ")
    } else {
      this.put("var ")
    };

    return this.put(`${undecls.map(item => item.toString()).join(", ")}${this._sep}`)
  }
};

Converter.prototype.collapse_strings = (node) => {
  let left = node.children[0];
  if (!left) return node;
  let right = node.children[2];

  if (left.type === "send" && left.children.length == 3 && left.children[1] == "+") {
    left = collapse_strings(left)
  };

  if (right.type === "send" && right.children.length == 3 && right.children[1] == "+") {
    right = collapse_strings(right)
  };

  if (["dstr", "str"].includes(left.type) && ["dstr", "str"].includes(right.type)) {
    if (left.type === "str" && right.type === "str") {
      return left.updated(null, [left.children[0] + right.children[0]])
    } else {
      if (left.type === "str") left = this.s("dstr", left);
      if (right.type === "str") right = this.s("dstr", right);
      return left.updated(null, left.children + right.children)
    }
  };

  if (left == node.children[0] && right == node.children[2]) {
    return node
  } else {
    return node.updated(null, [left, "+", right])
  }
};

Converter.prototype.range_to_array = (node) => {
  let length, start_value, finish_value, index_var, blank;
  let [start, finish] = node.children;

  if (start.type === "int" && start.children[0] == 0) {
    if (finish.type === "int") {
      length = finish.children[0] + (node.type === "irange" ? 1 : 0)
    } else {
      length = `${finish.children.at(-1)}` + (node.type === "irange" ? "+1" : "")
    };

    if (this.es2015) {
      return this.put(`[...Array(${length}).keys()]`)
    } else {
      return this.put(`Array.apply(null, {length: ${length}}).map(Function.call, Number)`)
    }
  } else {
    start_value = start.children.filter(x => x != null)[0];
    finish_value = finish.children.filter(x => x != null)[0];

    if (start.type === "int" && finish.type === "int") {
      length = finish_value - start_value + (node.type === "irange" ? 1 : 0)
    } else {
      length = `(${finish_value}-${start_value}` + (node.type === "irange" ? "+1" : "") + ")"
    };

    if ("idx" in this.#vars || start_value == "idx" || finish_value == "idx") {
      index_var = "i$"
    } else {
      index_var = "idx"
    };

    if (this.es2015) {
      if ("_" in this.#vars || start_value == "_" || finish_value == "_") {
        blank = "_$"
      } else {
        blank = "_"
      };

      return this.put(`Array.from({length: ${length}}, (${blank}, ${index_var}) => ${index_var}+${start_value})`)
    } else {
      return this.put(`Array.apply(null, {length: ${length}}).map(Function.call, Number).map(function (${index_var}) { return ${index_var}+${start_value} })`)
    }
  }
};

Converter.prototype.combine_properties = (body) => {
  for (let i = 0; i < body.length - 1; i++) {
    if (!body[i] || body[i].type !== "prop") continue;

    for (let j = i + 1; j < body.length; j++) {
      if (!body[j] || body[j].type !== "prop") break;

      if (body[i].children[0] == body[j].children[0]) {
        for (let node of [body[i], body[j]]) {
          let node_comments = this.#comments[node];

          if (node_comments && node_comments.length != 0) {
            for (let [key, value] of node.children[1].values[0]) {
              if (["get", "set"].includes(key) && typeof value === "object" && value !== null && "type" in value && typeof value === "object" && value !== null && "children" in value) {
                this.#comments[value] = this.#comments[node];
                break
              }
            }
          }
        };

        let merge = Object.fromEntries(Object.entries((body[i].children[1].to_a + body[j].children[1].to_a).reduce(
          ($acc, name) => {
            let $key = name.toString();
            ($acc[$key] = $acc[$key] || []).push(name);
            return $acc
          },

          {}
        )).map(([name, values]) => (
          [name, values.map(item => item.at(-1)).reduce("merge")]
        )));

        body[j] = this.s("prop", body[j].children[0], merge);
        body[i] = null;
        break
      }
    }
  }
};

Converter.prototype.is_boolean_expression = (node) => {
  let method;
  if (!node) return false;

  switch (node.type) {
  case "true":
  case "false":
    return true;

  case "send":
    method = node.children[1];
    if (COMPARISON_OPS.includes(method)) return true;
    if (method.toString().endsWith("?")) return true;
    false;
    break;

  case "and":
  case "or":
  case "not":
    return true;

  case "begin":
    return node.children.length == 1 && is_boolean_expression(node.children[0]);

  default:
    return false
  }
};

Converter.prototype.rewrite = (left, right) => {
  if (left && left.type === "and") left = rewrite(...left.children);

  if (right.type != "send" || OPERATORS.flat(Infinity).includes(right.children[1])) {
    return this.s("and", left, right)
  } else if (conditionally_equals(left, right.children[0])) {
    return right.updated("csend", [left, ...right.children.slice(1)])
  } else if (conditionally_equals(
    left.children.at(-1),
    right.children[0]
  )) {
    return left.updated(
      "and",

      [left.children[0], left.children.at(-1).updated(
        "csend",
        [left.children.at(-1), ...right.children.slice(1)]
      )]
    )
  } else {
    return this.s("and", left, right)
  }
};

Converter.prototype.conditionally_equals = (left, right) => {
  if (left == right) {
    return true
  } else if (typeof left !== "object" || !left !== null || !("type" in left) || !left || !right || left.type != "csend" || right.type != "send") {
    return false
  } else {
    return conditionally_equals(left.children[0], right.children[0]) && conditionally_equals(
      left.children.at(-1),
      right.children.at(-1)
    )
  }
};
      // Discover and register all on_* handler methods
      // The Ruby code uses handle(:type) { } which calls define_method and registers the type.
      // After transpilation, we have on_* methods but the #$handlers static array is empty.
      // We populate it by scanning for on_* methods on the prototype.
      (function() {
        const { Converter } = Ruby2JS;
        const proto = Converter.prototype;
        const types = [];
        for (const key of Object.getOwnPropertyNames(proto)) {
          if (key.startsWith('on_') && typeof proto[key] === 'function') {
            types.push(key.slice(3)); // Remove 'on_' prefix
          }
        }
        // Store in a way that the constructor can access
        Converter._discoveredHandlers = types;
      })();

      // Re-export classes for convenience
      // Note: Token, Line, Serializer are defined in preamble (not in Ruby2JS)
      const { Converter } = Ruby2JS;
      export { Node, s, Token, Line, Serializer, Ruby2JS, Converter };
