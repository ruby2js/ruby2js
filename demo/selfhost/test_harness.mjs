// Minimal test harness for selfhosted specs
// Provides describe/it/must_equal compatible with transpiled Minitest specs

// Import from the unified bundle (same code used by CLI and browser)
import {
  Ruby2JS,
  Prism,
  PrismSourceBuffer,
  PrismSourceRange,
  Hash,
  setupGlobals,
  initPrism as sharedInitPrism,
  getPrismParse
} from './ruby2js.mjs';

// Set up globals
setupGlobals(Ruby2JS);
globalThis.Namespace = Ruby2JS.Namespace;
globalThis.Ruby2JS = Ruby2JS;

// ============================================================================
// Filter Infrastructure
// ============================================================================

// Create Filter namespace (transpiled filters will attach here)
Ruby2JS.Filter = Ruby2JS.Filter || {};

// Global include/exclude tracking for filters
Ruby2JS.Filter._included = new Set();
Ruby2JS.Filter._excluded = new Set();
Ruby2JS.Filter.DEFAULTS = [];

Ruby2JS.Filter.include = function(...methods) {
  methods.forEach(m => Ruby2JS.Filter._included.add(m));
};

Ruby2JS.Filter.exclude = function(...methods) {
  methods.forEach(m => Ruby2JS.Filter._excluded.add(m));
};

Ruby2JS.Filter.included_methods = function() {
  return Ruby2JS.Filter._included;
};

Ruby2JS.Filter.excluded_methods = function() {
  return Ruby2JS.Filter._excluded;
};

// Ruby polyfills are now auto-generated by the polyfill filter in the bundle.
// Only Object#to_a is defined here since it's not used by the main code
// but may be needed by transpiled specs.
if (!Object.prototype.to_a) {
  Object.defineProperty(Object.prototype, 'to_a', {
    get: function() {
      return Object.entries(this);
    },
    configurable: true
  });
}

// Add ast_node helper if not present
Ruby2JS.ast_node = Ruby2JS.ast_node || function(obj) {
  return typeof obj === 'object' && obj !== null && 'type' in obj && 'children' in obj;
};

// Use SEXP from the transpiled bundle
const SEXP = Ruby2JS.Filter.SEXP;

// Node updated method - creates new node with optional type/children changes
function nodeUpdated(newType, newChildren) {
  const type = newType ?? this.type;
  const children = newChildren ?? this.children;
  return {
    type,
    children,
    updated: nodeUpdated,
    is_method: this.is_method,
    get first() { return children[0]; },
    get last() { return children[children.length - 1]; }
  };
}

// Wrap s() to add nodeUpdated if the transpiled version doesn't have it
const originalS = SEXP.s.bind(SEXP);
SEXP.s = function(type, ...children) {
  const node = originalS(type, ...children);
  if (!node.updated) {
    node.updated = nodeUpdated;
  }
  return node;
};

// FilterProcessor - thin wrapper that uses transpiled Ruby2JS.Filter.Processor
// Copies filter methods onto a Processor instance and delegates to it
class FilterProcessor {
  constructor(filter, options = {}) {
    // Create a Processor instance (it expects comments as constructor arg)
    this._processor = new Ruby2JS.Filter.Processor({});
    this._processor.options = options;
    this._filter = filter;

    // Copy filter's on_<type> methods onto the processor
    for (const key of Object.keys(filter)) {
      if (key.startsWith('on_') && typeof filter[key] === 'function') {
        this._processor[key] = filter[key].bind(filter);
      }
    }

    // Also check prototype for methods
    const proto = Object.getPrototypeOf(filter);
    if (proto) {
      for (const key of Object.getOwnPropertyNames(proto)) {
        if (key.startsWith('on_') && typeof filter[key] === 'function') {
          this._processor[key] = filter[key].bind(filter);
        }
      }
    }

    // Bind SEXP methods to the filter for creating nodes
    filter.s = SEXP.s;
    filter.S = (type, ...children) => this._processor._ast?.updated(type, children);
    filter.ast_node = Ruby2JS.ast_node;
    filter._options = options;

    // Bind process to filter for recursive calls
    filter.process = (node) => this._processor.process(node);
    filter.process_children = (node) => this._processor.process_children(node);

    // Add excluded/included checkers
    const excludedFn = (method) => Ruby2JS.Filter._excluded.has(method);
    const includedFn = (method) => Ruby2JS.Filter._included.has(method);
    filter.excluded = excludedFn;
    filter.included = includedFn;

    // Call _setup if filter has it (for transpiled filters with module-level functions)
    if (typeof filter._setup === 'function') {
      filter._setup({
        excluded: excludedFn,
        included: includedFn,
        process: filter.process,
        process_children: filter.process_children,
        s: SEXP.s,
        S: filter.S
      });
    }
  }

  process(node) {
    return this._processor.process(node);
  }

  processChildren(node) {
    return this._processor.process_children(node);
  }
}

// Export for use by transpiled filters
Ruby2JS.FilterProcessor = FilterProcessor;
Ruby2JS.SEXP = SEXP;
globalThis.SEXP = SEXP;

// Re-export initPrism from bundle (already initialized at module load)
export async function initPrism() {
  return await sharedInitPrism();
}

// Updated convert that uses the initialized parser
Ruby2JS.convert = function(source, opts = {}) {
  // Default eslevel to 2020 (same as Ruby2JS default)
  if (opts.eslevel === undefined) {
    opts.eslevel = 2020;
  }

  const prismParse = getPrismParse();
  if (!prismParse) {
    return {
      toString() {
        return `[ERROR: Prism not initialized. Call initPrism() first]`;
      }
    };
  }

  try {
    // Step 1: Parse Ruby source using Prism WASM
    const parseResult = prismParse(source);

    // Step 2: Walk Prism AST to create Parser-compatible AST
    const walker = new Ruby2JS.PrismWalker(source, opts.file || null);
    let ast = walker.visit(parseResult.value);

    // Step 3: Extract comments
    const comments = {};
    if (parseResult.comments) {
      comments[ast] = parseResult.comments;
      comments._raw = parseResult.comments;
    }

    // Step 3.5: Apply filters if specified
    if (opts.filters && Array.isArray(opts.filters)) {
      for (const filter of opts.filters) {
        if (!filter) continue;

        // Always call _setup to update options (module-level vars in transpiled filters)
        if (typeof filter._setup === 'function') {
          const excludedFn = (method) => Ruby2JS.Filter._excluded.has(method);
          const includedFn = (method) => Ruby2JS.Filter._included.has(method);
          filter._setup({
            excluded: excludedFn,
            included: includedFn,
            _options: opts
          });
        }

        if (typeof filter.on_send === 'function' || typeof filter.on_block === 'function') {
          // Filter uses on_<type> handlers - wrap with FilterProcessor
          const processor = new FilterProcessor(filter, opts);
          ast = processor.process(ast);
        }
      }
    }

    // Step 4: Create converter and generate JavaScript
    const converter = new Ruby2JS.Converter(ast, comments, {});

    // Apply options
    if (opts.eslevel) converter.eslevel = opts.eslevel;
    if (opts.comparison) converter.comparison = opts.comparison;
    if (opts.strict) converter.strict = opts.strict;
    if (opts.binding) converter.binding = opts.binding;
    if (opts.ivars) converter.ivars = opts.ivars;

    // Set up namespace for class/module tracking
    converter.namespace = new Ruby2JS.Namespace();

    // Enable vertical whitespace if source has newlines (matches Ruby2JS.convert)
    if (source.includes("\n")) {
      converter.enable_vertical_whitespace;
    }

    // convert is a getter (no-arg method becomes getter in ES6 class)
    converter.convert;

    return {
      toString() {
        // to_s is also a getter
        return converter.to_s;
      }
    };
  } catch (e) {
    return {
      toString() {
        return `[ERROR: ${e.message}]`;
      },
      error: e
    };
  }
};

let currentDescribe = [];
let testCount = 0;
let passCount = 0;
let failCount = 0;
let skipCount = 0;
let failures = [];

// Store before hooks per describe level
let beforeHooks = [];

// Reset test state between spec runs
export function resetTests() {
  currentDescribe = [];
  testCount = 0;
  passCount = 0;
  failCount = 0;
  skipCount = 0;
  failures = [];
  beforeHooks = [];
}

// Get current test results without logging
export function getTestResults() {
  return {
    total: testCount,
    passed: passCount,
    failed: failCount,
    skipped: skipCount,
    failures: failures.slice() // return a copy
  };
}

export function describe(name, fn) {
  // Handle different name types: functions use .name, objects need special handling
  let displayName;
  if (typeof name === 'function') {
    displayName = name.name || 'Anonymous';
  } else if (typeof name === 'object' && name !== null) {
    // Check for well-known module objects (like Ruby2JS which has convert method)
    if (name === globalThis.Ruby2JS) {
      displayName = 'Ruby2JS';
    } else {
      displayName = name.constructor?.name !== 'Object' ? name.constructor.name : 'Object';
    }
  } else {
    displayName = String(name);
  }
  currentDescribe.push(displayName);
  const prevBeforeHooksLength = beforeHooks.length;
  fn();
  // Remove any before hooks added at this level
  beforeHooks.length = prevBeforeHooksLength;
  currentDescribe.pop();
}

export function it(name, fn) {
  testCount++;
  const fullName = [...currentDescribe, name].join(' > ');
  try {
    // Run all before hooks first
    for (const hook of beforeHooks) {
      hook();
    }
    fn();
    passCount++;
  } catch (e) {
    if (e.message === 'SKIP') {
      skipCount++;
      passCount--; // Undo the implicit pass
    } else {
      failCount++;
      failures.push({ name: fullName, error: e });
    }
  }
}

export function skip(reason) {
  throw new Error('SKIP');
}

// before hooks - store to run before each test
export function before(fn) {
  beforeHooks.push(fn);
}

// Extend String prototype with must_equal for chaining
String.prototype.must_equal = function(expected) {
  if (this.valueOf() !== expected) {
    throw new Error(`Expected:\n  "${expected}"\nbut got:\n  "${this.valueOf()}"`);
  }
  return this;
};

// Also support must_include, must_match
String.prototype.must_include = function(substring) {
  if (!this.includes(substring)) {
    throw new Error(`Expected "${this.valueOf()}" to include "${substring}"`);
  }
  return this;
};

String.prototype.must_match = function(pattern) {
  if (!pattern.test(this.valueOf())) {
    throw new Error(`Expected "${this.valueOf()}" to match ${pattern}`);
  }
  return this;
};

// Boolean assertions
Boolean.prototype.must_equal = function(expected) {
  if (this.valueOf() !== expected) {
    throw new Error(`Expected ${expected} but got ${this.valueOf()}`);
  }
  return this;
};

// Array assertions
Array.prototype.must_equal = function(expected) {
  const actual = JSON.stringify(this);
  const exp = JSON.stringify(expected);
  if (actual !== exp) {
    throw new Error(`Expected ${exp} but got ${actual}`);
  }
  return this;
};

// Number assertions
Number.prototype.must_equal = function(expected) {
  if (this.valueOf() !== expected) {
    throw new Error(`Expected ${expected} but got ${this.valueOf()}`);
  }
  return this;
};

// Ruby's send method - call methods dynamically by name
if (!Object.prototype.send) {
  Object.defineProperty(Object.prototype, 'send', {
    value: function(methodName, ...args) {
      const method = this[methodName];
      if (typeof method === 'function') {
        return method.apply(this, args);
      }
      throw new Error(`undefined method '${methodName}' for ${this.constructor.name}`);
    },
    writable: true,
    configurable: true
  });
}

export function runTests() {
  console.log(`\nTests: ${testCount}, Passed: ${passCount}, Failed: ${failCount}, Skipped: ${skipCount}`);
  if (failures.length > 0) {
    console.log('\nFailures:');
    failures.slice(0, 20).forEach(f => {
      console.log(`\n  ${f.name}`);
      console.log(`    ${f.error.message.split('\n').join('\n    ')}`);
    });
    if (failures.length > 20) {
      console.log(`\n  ... and ${failures.length - 20} more failures`);
    }
  }
  return failCount === 0;
}

// Export globals for non-module usage
globalThis.describe = describe;
globalThis.it = it;
globalThis.skip = skip;
globalThis.before = before;
globalThis.runTests = runTests;
globalThis.resetTests = resetTests;
globalThis.getTestResults = getTestResults;
globalThis.initPrism = initPrism;
