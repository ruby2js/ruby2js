// Minimal test harness for selfhosted specs
// Provides describe/it/must_equal compatible with transpiled Minitest specs

// Import shared runtime (single source of truth for these classes)
import {
  Prism,
  PrismSourceBuffer,
  PrismSourceRange,
  Hash,
  setupGlobals,
  initPrism as sharedInitPrism,
  getPrismParse
} from './shared/runtime.mjs';
import { Namespace } from './dist/namespace.mjs';

// Set up globals
setupGlobals();
globalThis.Namespace = Namespace;

// Ruby polyfills are now auto-generated by the polyfill filter in dist/walker.mjs
// and dist/converter.mjs. Only Object#to_a is defined here since it's not used by
// the walker/converter but may be needed by transpiled specs.
if (!Object.prototype.to_a) {
  Object.defineProperty(Object.prototype, 'to_a', {
    get: function() {
      return Object.entries(this);
    },
    configurable: true
  });
}

// Import walker first to get Node class (transpiled from lib/ruby2js/node.rb)
const { Ruby2JS: WalkerModule } = await import('./dist/walker.mjs');

// Set up Ruby2JS.Node before importing converter (which uses it)
globalThis.Ruby2JS = {
  Node: WalkerModule.Node,  // Reuse Node from walker (single source of truth)
  // Check if something is an AST node (has type and children properties)
  // Guarded to handle primitives safely (unlike 'prop' in obj which throws)
  ast_node(obj) {
    return typeof obj === 'object' && obj !== null && 'type' in obj && 'children' in obj;
  },
  convert(source, opts = {}) {
    return {
      toString() {
        return `[ERROR: Prism not initialized. Call initPrism() first]`;
      }
    };
  }
};

// Now import converter (needs Ruby2JS.Node to be available)
const { Ruby2JS: ConverterModule } = await import('./dist/converter.mjs');

// Expose Serializer and Converter for specs that test them directly
Ruby2JS.Serializer = ConverterModule.Serializer;
Ruby2JS.Converter = ConverterModule.Converter;

// Re-export initPrism from shared runtime
export async function initPrism() {
  return await sharedInitPrism();
}

// Updated convert that uses the initialized parser
Ruby2JS.convert = function(source, opts = {}) {
  const prismParse = getPrismParse();
  if (!prismParse) {
    return {
      toString() {
        return `[ERROR: Prism not initialized. Call initPrism() first]`;
      }
    };
  }

  try {
    // Step 1: Parse Ruby source using Prism WASM
    const parseResult = prismParse(source);

    // Step 2: Walk Prism AST to create Parser-compatible AST
    const walker = new WalkerModule.PrismWalker(source, opts.file || null);
    const ast = walker.visit(parseResult.value);

    // Step 3: Extract comments
    const comments = {};
    if (parseResult.comments) {
      comments[ast] = parseResult.comments;
      comments._raw = parseResult.comments;
    }

    // Step 4: Create converter and generate JavaScript
    const converter = new ConverterModule.Converter(ast, comments, {});

    // Apply options
    if (opts.eslevel) converter.eslevel = opts.eslevel;
    if (opts.comparison) converter.comparison = opts.comparison;
    if (opts.strict) converter.strict = opts.strict;
    if (opts.binding) converter.binding = opts.binding;
    if (opts.ivars) converter.ivars = opts.ivars;

    // Set up namespace for class/module tracking
    converter.namespace = new Namespace();

    // Enable vertical whitespace if source has newlines (matches Ruby2JS.convert)
    if (source.includes("\n")) {
      converter.enable_vertical_whitespace;
    }

    // convert is a getter (no-arg method becomes getter in ES6 class)
    converter.convert;

    return {
      toString() {
        // to_s is also a getter
        return converter.to_s;
      }
    };
  } catch (e) {
    return {
      toString() {
        return `[ERROR: ${e.message}]`;
      },
      error: e
    };
  }
};

let currentDescribe = [];
let testCount = 0;
let passCount = 0;
let failCount = 0;
let skipCount = 0;
let failures = [];

// Store before hooks per describe level
let beforeHooks = [];

export function describe(name, fn) {
  // Handle different name types: functions use .name, objects need special handling
  let displayName;
  if (typeof name === 'function') {
    displayName = name.name || 'Anonymous';
  } else if (typeof name === 'object' && name !== null) {
    // Check for well-known module objects (like Ruby2JS which has convert method)
    if (name === globalThis.Ruby2JS) {
      displayName = 'Ruby2JS';
    } else {
      displayName = name.constructor?.name !== 'Object' ? name.constructor.name : 'Object';
    }
  } else {
    displayName = String(name);
  }
  currentDescribe.push(displayName);
  const prevBeforeHooksLength = beforeHooks.length;
  fn();
  // Remove any before hooks added at this level
  beforeHooks.length = prevBeforeHooksLength;
  currentDescribe.pop();
}

export function it(name, fn) {
  testCount++;
  const fullName = [...currentDescribe, name].join(' > ');
  try {
    // Run all before hooks first
    for (const hook of beforeHooks) {
      hook();
    }
    fn();
    passCount++;
  } catch (e) {
    if (e.message === 'SKIP') {
      skipCount++;
      passCount--; // Undo the implicit pass
    } else {
      failCount++;
      failures.push({ name: fullName, error: e });
    }
  }
}

export function skip(reason) {
  throw new Error('SKIP');
}

// before hooks - store to run before each test
export function before(fn) {
  beforeHooks.push(fn);
}

// Extend String prototype with must_equal for chaining
String.prototype.must_equal = function(expected) {
  if (this.valueOf() !== expected) {
    throw new Error(`Expected:\n  "${expected}"\nbut got:\n  "${this.valueOf()}"`);
  }
  return this;
};

// Also support must_include, must_match
String.prototype.must_include = function(substring) {
  if (!this.includes(substring)) {
    throw new Error(`Expected "${this.valueOf()}" to include "${substring}"`);
  }
  return this;
};

String.prototype.must_match = function(pattern) {
  if (!pattern.test(this.valueOf())) {
    throw new Error(`Expected "${this.valueOf()}" to match ${pattern}`);
  }
  return this;
};

// Boolean assertions
Boolean.prototype.must_equal = function(expected) {
  if (this.valueOf() !== expected) {
    throw new Error(`Expected ${expected} but got ${this.valueOf()}`);
  }
  return this;
};

// Array assertions
Array.prototype.must_equal = function(expected) {
  const actual = JSON.stringify(this);
  const exp = JSON.stringify(expected);
  if (actual !== exp) {
    throw new Error(`Expected ${exp} but got ${actual}`);
  }
  return this;
};

export function runTests() {
  console.log(`\nTests: ${testCount}, Passed: ${passCount}, Failed: ${failCount}, Skipped: ${skipCount}`);
  if (failures.length > 0) {
    console.log('\nFailures:');
    failures.slice(0, 20).forEach(f => {
      console.log(`\n  ${f.name}`);
      console.log(`    ${f.error.message.split('\n').join('\n    ')}`);
    });
    if (failures.length > 20) {
      console.log(`\n  ... and ${failures.length - 20} more failures`);
    }
  }
  return failCount === 0;
}

// Export globals for non-module usage
globalThis.describe = describe;
globalThis.it = it;
globalThis.skip = skip;
globalThis.before = before;
globalThis.runTests = runTests;
globalThis.initPrism = initPrism;
