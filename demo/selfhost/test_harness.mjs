// Minimal test harness for selfhosted specs
// Provides describe/it/must_equal compatible with transpiled Minitest specs

// Import from the unified bundle (same code used by CLI and browser)
import {
  Ruby2JS,
  Prism,
  PrismSourceBuffer,
  PrismSourceRange,
  PrismComment,
  Hash,
  setupGlobals,
  associateComments,
  initPrism as sharedInitPrism,
  getPrismParse,
  convert as bundleConvert
} from './ruby2js.js';

// Set up globals
setupGlobals(Ruby2JS);
globalThis.Namespace = Ruby2JS.Namespace;
globalThis.Ruby2JS = Ruby2JS;

// Provide a require shim for transpiled specs that use inline require
// (e.g., require 'ruby2js/filter/return' inside a function)
// Filters should already be loaded by run_all_specs.mjs, so this is a no-op
globalThis.require = function(path) {
  // Extract filter name from path like "ruby2js/filter/return"
  const match = path.match(/ruby2js\/filter\/(\w+)/);
  if (match) {
    const filterName = match[1].charAt(0).toUpperCase() + match[1].slice(1);
    if (!Ruby2JS.Filter[filterName]) {
      throw new Error(`Filter ${filterName} not loaded. Load it via run_all_specs.mjs or import manually.`);
    }
    // Filter already loaded, nothing to do
    return;
  }
  throw new Error(`require not supported for: ${path}`);
};

// Alias Parser.AST.Node to Ruby2JS.Node so transpiled SEXP.s works
// (Ruby source uses Parser gem's AST nodes, JS uses Ruby2JS.Node)
globalThis.Parser = { AST: { Node: Ruby2JS.Node } };

// ============================================================================
// Filter Infrastructure
// ============================================================================

// Create Filter namespace (transpiled filters will attach here)
Ruby2JS.Filter = Ruby2JS.Filter || {};

// Global include/exclude tracking for filters
Ruby2JS.Filter._included = new Set();
Ruby2JS.Filter._excluded = new Set();
Ruby2JS.Filter.DEFAULTS = [];

Ruby2JS.Filter.include = function(...methods) {
  methods.forEach(m => Ruby2JS.Filter._included.add(m));
};

Ruby2JS.Filter.exclude = function(...methods) {
  methods.forEach(m => Ruby2JS.Filter._excluded.add(m));
};

Ruby2JS.Filter.included_methods = function() {
  return Ruby2JS.Filter._included;
};

Ruby2JS.Filter.excluded_methods = function() {
  return Ruby2JS.Filter._excluded;
};

// Ruby polyfills are now auto-generated by the polyfill filter in the bundle.
// Only Object#to_a is defined here since it's not used by the main code
// but may be needed by transpiled specs.
if (!Object.prototype.to_a) {
  Object.defineProperty(Object.prototype, 'to_a', {
    get: function() {
      return Object.entries(this);
    },
    configurable: true
  });
}

// Export SEXP globally for transpiled filters
// (Bundle's SEXP.s already creates Node instances with updated() method)
const SEXP = Ruby2JS.Filter.SEXP;
Ruby2JS.SEXP = SEXP;
globalThis.SEXP = SEXP;

// AST node type checker - used by transpiled filters (e.g., Ruby2JS.ast_node(node))
Ruby2JS.ast_node = Ruby2JS.ast_node || function(obj) {
  return typeof obj === 'object' && obj !== null && 'type' in obj && 'children' in obj;
};

// Re-export initPrism from bundle (already initialized at module load)
export async function initPrism() {
  return await sharedInitPrism();
}

// Convert function - delegates to bundle's convert which uses Pipeline
// Pipeline now correctly handles class-based filters via Object.assign
Ruby2JS.convert = function(source, opts = {}) {
  // Default eslevel to 2020 (same as Ruby2JS default)
  if (opts.eslevel === undefined) {
    opts.eslevel = 2020;
  }

  try {
    const result = bundleConvert(source, opts);
    return { toString: () => result };
  } catch (e) {
    return { toString: () => `[ERROR: ${e.message}]`, error: e };
  }
};

let currentDescribe = [];
let testCount = 0;
let passCount = 0;
let failCount = 0;
let skipCount = 0;
let failures = [];

// Store before hooks per describe level
let beforeHooks = [];

// Reset test state between spec runs
export function resetTests() {
  currentDescribe = [];
  testCount = 0;
  passCount = 0;
  failCount = 0;
  skipCount = 0;
  failures = [];
  beforeHooks = [];
}

// Get current test results without logging
export function getTestResults() {
  return {
    total: testCount,
    passed: passCount,
    failed: failCount,
    skipped: skipCount,
    failures: failures.slice() // return a copy
  };
}

export function describe(name, fn) {
  // Handle different name types: functions use .name, objects need special handling
  let displayName;
  if (typeof name === 'function') {
    displayName = name.name || 'Anonymous';
  } else if (typeof name === 'object' && name !== null) {
    // Check for well-known module objects (like Ruby2JS which has convert method)
    if (name === globalThis.Ruby2JS) {
      displayName = 'Ruby2JS';
    } else {
      displayName = name.constructor?.name !== 'Object' ? name.constructor.name : 'Object';
    }
  } else {
    displayName = String(name);
  }
  currentDescribe.push(displayName);
  const prevBeforeHooksLength = beforeHooks.length;
  fn();
  // Remove any before hooks added at this level
  beforeHooks.length = prevBeforeHooksLength;
  currentDescribe.pop();
}

export function it(name, fn) {
  testCount++;
  const fullName = [...currentDescribe, name].join(' > ');
  try {
    // Run all before hooks first
    for (const hook of beforeHooks) {
      hook();
    }
    fn();
    passCount++;
  } catch (e) {
    if (e.message === 'SKIP') {
      skipCount++;
      passCount--; // Undo the implicit pass
    } else {
      failCount++;
      failures.push({ name: fullName, error: e });
    }
  }
}

export function skip(reason) {
  throw new Error('SKIP');
}

// before hooks - store to run before each test
export function before(fn) {
  beforeHooks.push(fn);
}

// Extend String prototype with must_equal for chaining
String.prototype.must_equal = function(expected) {
  if (this.valueOf() !== expected) {
    throw new Error(`Expected:\n  "${expected}"\nbut got:\n  "${this.valueOf()}"`);
  }
  return this;
};

// Also support must_include, must_match
String.prototype.must_include = function(substring) {
  if (!this.includes(substring)) {
    throw new Error(`Expected "${this.valueOf()}" to include "${substring}"`);
  }
  return this;
};

String.prototype.must_match = function(pattern) {
  if (!pattern.test(this.valueOf())) {
    throw new Error(`Expected "${this.valueOf()}" to match ${pattern}`);
  }
  return this;
};

// Boolean assertions
Boolean.prototype.must_equal = function(expected) {
  if (this.valueOf() !== expected) {
    throw new Error(`Expected ${expected} but got ${this.valueOf()}`);
  }
  return this;
};

// Array assertions
Array.prototype.must_equal = function(expected) {
  const actual = JSON.stringify(this);
  const exp = JSON.stringify(expected);
  if (actual !== exp) {
    throw new Error(`Expected ${exp} but got ${actual}`);
  }
  return this;
};

Array.prototype.must_include = function(item) {
  if (!this.includes(item)) {
    throw new Error(`Expected array to include ${item}`);
  }
  return this;
};

// Number assertions
Number.prototype.must_equal = function(expected) {
  if (this.valueOf() !== expected) {
    throw new Error(`Expected ${expected} but got ${this.valueOf()}`);
  }
  return this;
};

// Ruby's send method - call methods dynamically by name
if (!Object.prototype.send) {
  Object.defineProperty(Object.prototype, 'send', {
    value: function(methodName, ...args) {
      const method = this[methodName];
      if (typeof method === 'function') {
        return method.apply(this, args);
      }
      throw new Error(`undefined method '${methodName}' for ${this.constructor.name}`);
    },
    writable: true,
    configurable: true
  });
}

export function runTests() {
  console.log(`\nTests: ${testCount}, Passed: ${passCount}, Failed: ${failCount}, Skipped: ${skipCount}`);
  if (failures.length > 0) {
    console.log('\nFailures:');
    failures.slice(0, 20).forEach(f => {
      console.log(`\n  ${f.name}`);
      console.log(`    ${f.error.message.split('\n').join('\n    ')}`);
    });
    if (failures.length > 20) {
      console.log(`\n  ... and ${failures.length - 20} more failures`);
    }
  }
  return failCount === 0;
}

// Export globals for non-module usage
globalThis.describe = describe;
globalThis.it = it;
globalThis.skip = skip;
globalThis.before = before;
globalThis.runTests = runTests;
globalThis.resetTests = resetTests;
globalThis.getTestResults = getTestResults;
globalThis.initPrism = initPrism;
