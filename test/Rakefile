# Test orchestration for Ruby2JS demos
#
# Usage (from repository root):
#   bundle exec rake -f test/Rakefile integration[blog]   # Automated tests
#   bundle exec rake -f test/Rakefile system[blog]        # Manual browser testing
#
# Or from test/ directory:
#   rake integration[blog]
#   rake system[blog]
#
# These commands ensure all dependencies are up-to-date before testing.

require 'fileutils'

ROOT = File.expand_path('..', __dir__)
TEST_DIR = __dir__
ARTIFACTS = File.join(ROOT, 'artifacts')
TARBALLS = File.join(ARTIFACTS, 'tarballs')

# Demos that can be tested
DEMOS = %w[blog chat notes photo_gallery dictaphone workflow]

# ============================================
# Helper methods
# ============================================

def demo_tarball(demo)
  # Tarballs use hyphens, directories use underscores
  # CI creates artifacts/demo-blog.tar.gz (not in subdirectory)
  demo_hyphen = demo.tr('_', '-')
  File.join(ARTIFACTS, "demo-#{demo_hyphen}.tar.gz")
end

def demo_create_script(demo)
  # Scripts use hyphens in directory names
  demo_hyphen = demo.tr('_', '-')
  File.join(TEST_DIR, demo_hyphen, "create-#{demo_hyphen}")
end

def package_tarballs_exist?
  %w[ruby2js-beta.tgz ruby2js-rails-beta.tgz vite-plugin-ruby2js-beta.tgz].all? do |name|
    File.exist?(File.join(TARBALLS, name))
  end
end

def demo_tarball_exists?(demo)
  File.exist?(demo_tarball(demo))
end

# ============================================
# Build tasks
# ============================================

desc "Build npm package tarballs"
task :tarballs do
  if package_tarballs_exist?
    puts "Package tarballs exist, checking if rebuild needed..."
  end

  # Always rebuild to ensure they're current
  # The selfhost Rakefile has proper dependency tracking
  Dir.chdir(ROOT) do
    sh 'bundle exec rake -f demo/selfhost/Rakefile release'
  end
end

# Define file tasks for each demo tarball
# These only rebuild when the create script changes
DEMOS.each do |demo|
  demo_hyphen = demo.tr('_', '-')
  script = File.join(TEST_DIR, demo_hyphen, "create-#{demo_hyphen}")
  tarball = File.join(ARTIFACTS, "demo-#{demo_hyphen}.tar.gz")

  next unless File.exist?(script)  # Skip demos without create scripts

  # File task: tarball depends on create script
  file tarball => script do
    demo_dir = File.join(ARTIFACTS, demo)

    # Clean existing demo directory
    FileUtils.rm_rf(demo_dir)
    FileUtils.mkdir_p(ARTIFACTS)

    puts "Creating #{demo} demo..."
    Dir.chdir(ROOT) do
      # Run in a clean shell without Bundler environment (create script needs Rails)
      # Using env -i with explicit PATH to find rails and other tools
      path = ENV['PATH']
      sh "env -i PATH=#{path} HOME=#{ENV['HOME']} #{script} #{demo_dir}"
      sh "tar --exclude='node_modules' -czf #{tarball} -C #{ARTIFACTS} #{demo}"
    end

    puts "Created: #{tarball}"
  end
end

desc "Create demo tarball (only if create script changed)"
task :demo_tarball, [:demo] do |t, args|
  demo = args[:demo] || 'blog'

  unless DEMOS.include?(demo)
    abort "Unknown demo: #{demo}. Available: #{DEMOS.join(', ')}"
  end

  script = demo_create_script(demo)
  unless File.exist?(script)
    abort "Create script not found: #{script}"
  end

  tarball = demo_tarball(demo)

  # Invoke the file task (checks timestamps automatically)
  Rake::Task[tarball].invoke
end

# ============================================
# Integration tests (automated, no browser)
# ============================================

desc "Run integration tests for a demo (default: blog)"
task :integration, [:demo] do |t, args|
  demo = args[:demo] || 'blog'

  # Ensure tarballs are built
  Rake::Task[:tarballs].invoke

  # Ensure demo tarball exists
  unless demo_tarball_exists?(demo)
    Rake::Task[:demo_tarball].invoke(demo)
  end

  # Run integration tests
  integration_dir = File.join(TEST_DIR, 'integration')

  Dir.chdir(integration_dir) do
    # Install test dependencies if needed
    unless File.exist?('node_modules')
      sh 'npm install'
    end

    # Setup demo from local tarballs
    puts "\nSetting up #{demo} demo from local tarballs..."
    sh "node setup.mjs --local #{demo}"

    # Run tests
    puts "\nRunning tests..."
    # Test files use hyphens to avoid vitest substring matching
    # Some demos use juntos- prefix to avoid matching similarly named demos
    test_name = demo.tr('_', '-')
    case test_name
    when 'blog' then test_name = 'juntos-blog'
    when 'chat' then test_name = 'juntos-chat'
    when 'photo-gallery' then test_name = 'juntos-photo-gallery'
    when 'dictaphone' then test_name = 'juntos-dictaphone'
    end
    test_file = "./#{test_name}.test.mjs"

    unless File.exist?(test_file)
      abort "No test file found: #{test_file}"
    end

    sh "npm test -- #{test_file}"
  end
end

# ============================================
# System tests (manual browser testing)
# ============================================

desc "Start system test container for manual browser testing (default: blog)"
task :system, [:demo, :database, :target] do |t, args|
  demo = args[:demo] || 'blog'
  database = args[:database] || 'dexie'
  target = args[:target] || 'browser'

  # Ensure tarballs are built
  Rake::Task[:tarballs].invoke

  # Ensure demo tarball exists
  unless demo_tarball_exists?(demo)
    Rake::Task[:demo_tarball].invoke(demo)
  end

  demo_hyphen = demo.tr('_', '-')
  image_name = "ruby2js-#{demo_hyphen}-test"
  container_name = "#{image_name}-container"

  # Stop and remove existing container
  system "docker stop #{container_name} 2>/dev/null"
  system "docker rm #{container_name} 2>/dev/null"

  # Generate a Dockerfile that uses local tarballs
  dockerfile = File.join(ARTIFACTS, 'Dockerfile.system-test')
  generate_system_test_dockerfile(dockerfile, demo, database, target)

  puts "\nBuilding Docker image with local tarballs..."
  Dir.chdir(ROOT) do
    sh "docker build -f #{dockerfile} -t #{image_name} ."
  end

  # Run container
  puts "\nStarting container..."
  # juntos server uses port 3000 for both browser (static) and node (express)
  port = 3000
  sh "docker run -d -p #{port}:#{port} --name #{container_name} #{image_name}"

  # Wait for startup and show logs
  sleep 2
  puts "\n" + "=" * 60
  puts "Container started!"
  puts "=" * 60
  puts "\nOpen in browser: http://localhost:#{port}"
  puts "\nView logs:       docker logs -f #{container_name}"
  puts "Stop container:  docker stop #{container_name}"
  puts "Remove:          docker rm #{container_name}"
  puts "\n"

  # Show initial logs
  sh "docker logs #{container_name}"
end

desc "Stop and remove system test container"
task :system_stop, [:demo] do |t, args|
  demo = args[:demo] || 'blog'
  demo_hyphen = demo.tr('_', '-')
  container_name = "ruby2js-#{demo_hyphen}-test-container"

  sh "docker stop #{container_name} 2>/dev/null || true"
  sh "docker rm #{container_name} 2>/dev/null || true"
  puts "Stopped and removed #{container_name}"
end

# ============================================
# Fizzy benchmark (production Rails app eject)
# ============================================

FIZZY_DIR = ENV['FIZZY_DIR'] || File.expand_path('~/git/fizzy')
RUBY2JS_PKG = File.join(ROOT, 'demo/selfhost')
RUBY2JS_RAILS_PKG = File.join(ROOT, 'packages/ruby2js-rails')

desc "Build selfhost, eject Fizzy, and run tests"
task :fizzy, [:timeout] do |t, args|
  timeout = (args[:timeout] || 300).to_i

  unless File.directory?(FIZZY_DIR)
    abort "Fizzy not found at #{FIZZY_DIR}. Set FIZZY_DIR env var."
  end

  # 1. Build selfhost (copies ruby2js.js to both packages)
  puts "\n=== Building selfhost ==="
  Dir.chdir(ROOT) do
    sh 'bundle exec rake -f demo/selfhost/Rakefile local'
  end

  # 2. Symlink dev packages in fizzy/node_modules/ so eject uses current source
  puts "\n=== Symlinking dev packages for eject ==="
  fizzy_nm = File.join(FIZZY_DIR, 'node_modules')
  if File.directory?(fizzy_nm)
    FileUtils.rm_rf(File.join(fizzy_nm, 'ruby2js'))
    FileUtils.rm_rf(File.join(fizzy_nm, 'ruby2js-rails'))
    FileUtils.ln_s(RUBY2JS_PKG, File.join(fizzy_nm, 'ruby2js'))
    FileUtils.ln_s(RUBY2JS_RAILS_PKG, File.join(fizzy_nm, 'ruby2js-rails'))
    puts "  Symlinked ruby2js → #{RUBY2JS_PKG}"
    puts "  Symlinked ruby2js-rails → #{RUBY2JS_RAILS_PKG}"
  end

  # 3. Eject
  puts "\n=== Ejecting Fizzy ==="
  cli = File.join(RUBY2JS_RAILS_PKG, 'cli.mjs')
  Dir.chdir(FIZZY_DIR) do
    sh "node #{cli} eject -d sqlite"
  end

  ejected = File.join(FIZZY_DIR, 'ejected')

  # 4. Install npm deps (vitest, etc.) then symlink dev packages in ejected/
  puts "\n=== Setting up node_modules ==="
  Dir.chdir(ejected) do
    sh 'npm install 2>&1'

    # Replace installed packages with symlinks to dev source
    FileUtils.rm_rf('node_modules/ruby2js')
    FileUtils.rm_rf('node_modules/ruby2js-rails')
    FileUtils.ln_s(RUBY2JS_PKG, 'node_modules/ruby2js')
    FileUtils.ln_s(RUBY2JS_RAILS_PKG, 'node_modules/ruby2js-rails')
    puts "  Symlinked ruby2js → #{RUBY2JS_PKG}"
    puts "  Symlinked ruby2js-rails → #{RUBY2JS_RAILS_PKG}"
  end

  # 5. Run tests
  puts "\n=== Running tests ==="
  Rake::Task[:fizzy_test].invoke(timeout)
end

desc "Run Fizzy tests only (skip build/eject, reuse existing ejected/)"
task :fizzy_test, [:timeout] do |t, args|
  timeout = (args[:timeout] || 60).to_i
  ejected = File.join(FIZZY_DIR, 'ejected')

  unless File.directory?(ejected)
    abort "No ejected directory. Run `rake fizzy` first."
  end

  # Use lightweight Node-native runner (bypasses Vite, avoids OOM).
  # Each file runs in its own Node process to prevent memory accumulation.
  runner = File.join(ejected, 'test/runner.mjs')
  loader = File.join(ejected, 'test/register-loader.mjs')

  unless File.exist?(runner) && File.exist?(loader)
    abort "Test runner not found. Re-eject to generate test/runner.mjs."
  end

  test_files = Dir.glob("#{ejected}/test/**/*.test.{mjs,js}").sort
  passed_files = 0
  failed_files = 0
  errored_files = 0
  passed_tests = 0
  failed_tests = 0
  error_details = []

  puts "Running #{test_files.size} test files (#{timeout}s timeout per file)..."
  puts ""

  test_files.each_with_index do |file, i|
    rel = file.sub("#{ejected}/", '')
    cmd = "cd #{ejected} && timeout #{timeout} node --import ./test/register-loader.mjs test/runner.mjs -q #{rel} 2>&1"
    output = `#{cmd}`
    status = $?.exitstatus

    # Parse results from runner output:
    #   ✓ path  (N passed)
    #   ✗ path  (N passed, M failed)
    #   ERROR path: message
    #   Test Files  N passed | M failed | K errored  (total)
    #        Tests  N passed | M failed  (total)
    #
    # Check for errored test FILES first — when describe callbacks throw,
    # the Tests line still shows "0 passed | 0 failed" which would otherwise
    # match as "passed".
    if output =~ /\d+ passed \| \d+ failed \| (\d+) errored/ && $1.to_i > 0
      errored_files += 1
      msg = output.lines.find { |l| l.include?('ERROR') }&.strip || 'load error'
      error_details << [rel, msg, []]
    elsif output =~ /Tests\s+(\d+)\s+passed\s*\|\s*(\d+)\s+failed/
      pt, ft = $1.to_i, $2.to_i
      passed_tests += pt
      failed_tests += ft
      if ft > 0
        failed_files += 1
        # Extract failure details
        failures = output.lines.select { |l| l.include?('Expected') || l.include?('Error:') }.first(3).map(&:strip)
        error_details << [rel, "#{pt} passed, #{ft} failed", failures]
      elsif pt > 0
        passed_files += 1
      else
        # 0 tests registered, 0 failed — describe body likely threw
        errored_files += 1
        msg = output.lines.find { |l| l.include?('ERROR') || l.include?('ReferenceError') || l.include?('TypeError') }&.strip || 'no tests registered'
        error_details << [rel, msg, []]
      end
    elsif status == 124  # timeout
      errored_files += 1
      error_details << [rel, 'timeout', []]
    else
      errored_files += 1
      msg = output.lines.last(3).map(&:strip).reject(&:empty?).first || 'unknown error'
      error_details << [rel, msg, []]
    end

    print "\r  [#{i+1}/#{test_files.size}] #{passed_files} passed, #{failed_files} failed, #{errored_files} errored"
    $stdout.flush
  end

  puts "\n\n"
  puts "=" * 60
  puts " Test Files  #{passed_files} passed | #{failed_files} failed | #{errored_files} errored  (#{test_files.size})"
  puts "      Tests  #{passed_tests} passed | #{failed_tests} failed  (#{passed_tests + failed_tests})"
  puts "=" * 60

  if error_details.any?
    puts "\nFailing/errored files (first 40):"
    error_details.first(40).each do |file, status, details|
      puts "  #{file}: #{status}"
      details.each { |d| puts "    #{d}" } if details.any?
    end
    puts "  ... and #{error_details.size - 40} more" if error_details.size > 40
  end
end

desc "Summarize Fizzy test failure patterns (reuses existing ejected/)"
task :fizzy_summary, [:timeout] do |t, args|
  timeout = (args[:timeout] || 60).to_i
  ejected = File.join(FIZZY_DIR, 'ejected')

  unless File.directory?(ejected)
    abort "No ejected directory. Run `rake fizzy` first."
  end

  runner = File.join(ejected, 'test/runner.mjs')
  loader = File.join(ejected, 'test/register-loader.mjs')

  unless File.exist?(runner) && File.exist?(loader)
    abort "Test runner not found. Re-eject to generate test/runner.mjs."
  end

  test_files = Dir.glob("#{ejected}/test/**/*.test.{mjs,js}").sort
  passed = []
  failed = []
  errored = []
  total_passed_tests = 0
  total_failed_tests = 0

  puts "Running #{test_files.size} test files (#{timeout}s timeout per file)..."
  puts ""

  test_files.each_with_index do |file, i|
    rel = file.sub("#{ejected}/", '')
    # Use -v for failure details, pipe through tail to avoid capturing
    # 100K+ lines of SQL/migration noise per file
    cmd = "cd #{ejected} && timeout #{timeout} node --import ./test/register-loader.mjs test/runner.mjs -v #{rel} 2>&1 | tail -500"
    output = `#{cmd}`
    status = $?.exitstatus

    if output =~ /\d+ passed \| \d+ failed \| (\d+) errored/ && $1.to_i > 0
      # Error during load
      msg = output.lines.find { |l| l.include?('ERROR') }&.strip || ''
      errored << { file: rel, error: msg }
    elsif output =~ /Tests\s+(\d+)\s+passed\s*\|\s*(\d+)\s+failed/
      pt, ft = $1.to_i, $2.to_i
      total_passed_tests += pt
      total_failed_tests += ft
      if ft > 0
        # Extract failure messages from verbose output (last section: "Failures:")
        failure_msgs = []
        in_failures = false
        output.lines.each do |line|
          in_failures = true if line.strip == 'Failures:'
          next unless in_failures
          # Lines starting with 4 spaces under each test name are error messages
          if line =~ /^\s{4}(\S.*)/ && !line.include?('> ')
            failure_msgs << $1.strip
          end
        end
        failed << { file: rel, passed: pt, failed: ft, messages: failure_msgs }
      elsif pt > 0
        passed << { file: rel, passed: pt }
      else
        msg = output.lines.find { |l| l.include?('ERROR') || l.include?('ReferenceError') || l.include?('TypeError') }&.strip || 'no tests registered'
        errored << { file: rel, error: msg }
      end
    elsif status == 124
      errored << { file: rel, error: 'timeout (process killed)' }
    else
      msg = output.lines.last(3).map(&:strip).reject(&:empty?).first || 'unknown error'
      errored << { file: rel, error: msg }
    end

    print "\r  [#{i+1}/#{test_files.size}] #{passed.size} passed, #{failed.size} failed, #{errored.size} errored"
    $stdout.flush
  end

  puts "\n\n"

  # ---- Categorize errors ----
  error_categories = Hash.new { |h, k| h[k] = [] }

  errored.each do |info|
    msg = info[:error]
    case msg
    when /Cannot find module '([^']+)'/
      missing = $1.sub("#{ejected}/", '')
      if missing =~ /\.(svg|png|jpg|gif|webp|ico)$/
        error_categories["Missing asset import (#{File.basename(missing)})"] << info[:file]
      elsif missing.include?('active_support') || missing.include?('time.js')
        error_categories["Missing framework module (#{File.basename(missing, '.js')})"] << info[:file]
      elsif missing =~ /app\/models\/(.*)/
        model = $1.sub(/\.js$/, '')
        error_categories["Missing/mangled model import (#{model})"] << info[:file]
      elsif missing =~ /app\/views\/layouts\/(.*)/
        error_categories["Missing layout partial (#{$1})"] << info[:file]
      elsif missing =~ /app\/views\/(.*)/
        error_categories["Missing view module (#{$1})"] << info[:file]
      else
        error_categories["Cannot find module (#{File.basename(missing)})"] << info[:file]
      end
    when /does not provide an export named '([^']+)'/
      error_categories["Missing route export (#{$1})"] << info[:file]
    when /Invalid left-hand side/
      error_categories["Syntax error: invalid assignment"] << info[:file]
    when /timeout/
      error_categories["Timeout (infinite loop)"] << info[:file]
    when /no tests registered/
      error_categories["Empty test file (0 tests)"] << info[:file]
    else
      error_categories["Other load error"] << info[:file]
    end
  end

  # ---- Categorize failures ----
  failure_categories = Hash.new { |h, k| h[k] = [] }

  failed.each do |info|
    messages = info[:messages] || []
    patterns_seen = Set.new

    messages.each do |msg|
      pattern = case msg
      when /(\w+Controller\w*) is not defined/
        "Controller not defined (#{$1})"
      when /(\w+) is not defined/
        "Variable not defined"
      when /(\S+) is not a function/
        "Not a function"
      when /is not a constructor/
        "Not a constructor"
      when /Cannot read properties of (undefined|null) \(reading '([^']+)'\)/
        "Cannot read property of #{$1}"
      when /Cannot set property/
        "Cannot set property (getter-only)"
      when /NOT NULL constraint failed: (\w+\.\w+)/
        "Schema: NOT NULL (#{$1})"
      when /no column named (\w+)/
        "Schema: missing column (#{$1})"
      when /Maximum call stack/
        "Stack overflow"
      when /Expected (async )?function \w+|Expected \w+\(\) \{/
        "Predicate returns function not value"
      when /Expected/
        "Assertion mismatch"
      when /Active Storage service not initialized/
        "Active Storage not initialized"
      else
        nil
      end
      patterns_seen << pattern if pattern
    end

    patterns_seen << "Other test failure" if patterns_seen.empty?

    patterns_seen.each do |pattern|
      failure_categories[pattern] << info[:file]
    end
  end

  # ---- Print report ----
  puts "=" * 70
  puts " FIZZY EJECT TEST SUMMARY"
  puts "=" * 70
  puts ""
  puts " Test Files: #{passed.size} passed | #{failed.size} failed | #{errored.size} errored  (#{test_files.size})"
  puts "     Tests:  #{total_passed_tests} passed | #{total_failed_tests} failed  (#{total_passed_tests + total_failed_tests})"
  puts ""

  if passed.any?
    puts "-" * 70
    puts " PASSING FILES (#{passed.size})"
    puts "-" * 70
    passed.each { |info| puts "  ✓ #{info[:file]} (#{info[:passed]} tests)" }
    puts ""
  end

  if error_categories.any?
    puts "-" * 70
    puts " LOAD ERRORS by category (#{errored.size} files)"
    puts "-" * 70
    error_categories.sort_by { |_, files| -files.size }.each do |category, files|
      puts "  #{category} (#{files.size} files)"
      files.sort.each { |f| puts "    #{f}" }
    end
    puts ""
  end

  if failure_categories.any?
    puts "-" * 70
    puts " TEST FAILURES by pattern (#{failed.size} files)"
    puts "-" * 70
    failure_categories.sort_by { |_, files| -files.size }.each do |pattern, files|
      puts "  #{pattern} (#{files.size} files)"
      files.sort.each { |f| puts "    #{f}" }
    end
    puts ""
  end

  puts "=" * 70
end

# ============================================
# Convenience tasks
# ============================================

desc "List available demos"
task :list do
  puts "Available demos:"
  DEMOS.each do |demo|
    script = demo_create_script(demo)
    status = File.exist?(script) ? "✓" : "✗ (no create script)"
    puts "  #{demo.ljust(15)} #{status}"
  end
end

desc "Clean all built artifacts"
task :clean do
  FileUtils.rm_rf(ARTIFACTS)
  puts "Cleaned artifacts/"
end

# Generate a Dockerfile for system tests that uses local tarballs
def generate_system_test_dockerfile(path, demo, database, target)
  demo_hyphen = demo.tr('_', '-')

  # Determine which database packages to install
  db_packages = case database
  when 'sqlite' then 'better-sqlite3'
  when 'pg' then 'pg'
  when 'mysql' then 'mysql2'
  else ''
  end

  content = <<~DOCKERFILE
    # Auto-generated system test Dockerfile for #{demo}
    # Generated by: rake system[#{demo},#{database},#{target}]
    # Uses local tarballs from artifacts/

    FROM node:24

    WORKDIR /app

    ENV JUNTOS_DATABASE=#{database}
    ENV JUNTOS_TARGET=#{target}

    # Copy local tarballs
    COPY artifacts/tarballs/*.tgz /tarballs/
    COPY artifacts/demo-#{demo_hyphen}.tar.gz /tarballs/

    # Extract demo
    RUN tar -xzf /tarballs/demo-#{demo_hyphen}.tar.gz --strip-components=1 -C /app

    # Install ruby2js-rails first (includes js-yaml dependency)
    # Then run init which can now read ruby2js.yml
    RUN npm install /tarballs/ruby2js-rails-beta.tgz && \\
        rm -f package-lock.json && \\
        npx juntos init --no-install

    # Install all dependencies from package.json (including ruby2js.yml dependencies)
    # Then install remaining tarballs#{db_packages.empty? ? '' : " + #{db_packages}"}
    RUN npm install && \\
        npm install /tarballs/ruby2js-beta.tgz /tarballs/vite-plugin-ruby2js-beta.tgz#{db_packages.empty? ? '' : " #{db_packages}"}

    # Build
    RUN npx juntos build --verbose

    # Run migrations and seeds for server targets (Node/SQLite/PG)
    RUN npx juntos db prepare || echo "Migration skipped (browser target)"

    EXPOSE 3000 5173

    CMD ["npx", "juntos", "server"]
  DOCKERFILE

  FileUtils.mkdir_p(File.dirname(path))
  File.write(path, content)
  puts "Generated: #{path}"
end

task default: :list
