#!/usr/bin/env bash
# Create a Ruby2JS workflow builder demo with React Flow
# Usage: create-workflow [app-name]
#
# Creates a Rails app with Workflow, Node, and Edge models,
# ERB views for listing, and RBX views for React Flow canvas.
# Demonstrates using React ecosystem libraries via RBX files.
#
# Features:
# - Uses `# Pragma: browser` for browser-only React Flow imports
# - Uses `defined?(ReactFlow)` for SSR-safe rendering
# - Works with both browser (Dexie) and server (Node/Rails) targets
# - Real-time collaboration via broadcast_json_to and JsonStreamProvider
# - BroadcastChannel (browser) or WebSocket (node) for cross-tab/client sync
# - Double-click canvas to add nodes, double-click node to edit label
# - Select node + Delete/Backspace to remove nodes

set -e

APP_NAME="${1:-workflow_builder}"

echo "Creating Ruby2JS workflow builder: $APP_NAME"
echo ""

# Create Rails app (minimal, with Tailwind for nice styling)
rails new "$APP_NAME" --skip-git --skip-docker --css tailwind
cd "$APP_NAME"

# Generate Workflow model (--force needed because Rails reserves this name)
rails generate model Workflow name:string --force

# Generate Node model (belongs to workflow)
rails generate model Node workflow:references label:string node_type:string position_x:float position_y:float

# Generate Edge model (connects nodes within a workflow)
rails generate model Edge workflow:references source_node_id:integer target_node_id:integer

# Create database
rails db:create

# Add ruby2js gem from GitHub
bundle add ruby2js --github ruby2js/ruby2js --branch master

# Ensure git checkout is complete (handles Bundler version upgrade)
bundle install

# Update Workflow model with associations and validations
cat > app/models/workflow.rb << 'MODEL'
class Workflow < ApplicationRecord
  has_many :nodes, dependent: :destroy
  has_many :edges, dependent: :destroy

  validates :name, presence: true
end
MODEL

# Update Node model with JSON broadcasting for real-time collaboration
cat > app/models/node.rb << 'MODEL'
class Node < ApplicationRecord
  belongs_to :workflow

  validates :position_x, :position_y, presence: true
  validates :label, presence: true

  # Broadcast JSON events for real-time collaboration
  after_create_commit do
    broadcast_json_to "workflow_#{workflow_id}", "node_created"
  end

  after_update_commit do
    broadcast_json_to "workflow_#{workflow_id}", "node_updated"
  end

  after_destroy_commit do
    broadcast_json_to "workflow_#{workflow_id}", "node_destroyed"
  end
end
MODEL

# Update Edge model with JSON broadcasting
cat > app/models/edge.rb << 'MODEL'
class Edge < ApplicationRecord
  belongs_to :workflow
  belongs_to :source_node, class_name: 'Node'
  belongs_to :target_node, class_name: 'Node'

  # Broadcast JSON events for real-time collaboration
  after_create_commit do
    broadcast_json_to "workflow_#{workflow_id}", "edge_created"
  end

  after_destroy_commit do
    broadcast_json_to "workflow_#{workflow_id}", "edge_destroyed"
  end
end
MODEL

# Set up routes
cat > config/routes.rb << 'ROUTES'
Rails.application.routes.draw do
  root "workflows#index"

  resources :workflows do
    resources :nodes, only: [:create, :update, :destroy]
    resources :edges, only: [:create, :destroy]
    member do
      patch :update_positions
    end
  end
end
ROUTES

# Create WorkflowsController
mkdir -p app/controllers
cat > app/controllers/workflows_controller.rb << 'CONTROLLER'
class WorkflowsController < ApplicationController
  def index
    @workflows = Workflow.includes(:nodes, :edges).all
  end

  def show
    @workflow = Workflow.includes(:nodes, :edges).find(params[:id])
  end

  def new
    @workflow = Workflow.new
  end

  def create
    @workflow = Workflow.new(workflow_params)
    if @workflow.save
      redirect_to @workflow, notice: "Workflow created."
    else
      render :new, status: :unprocessable_entity
    end
  end

  def edit
    @workflow = Workflow.find(params[:id])
  end

  def update
    @workflow = Workflow.find(params[:id])
    if @workflow.update(workflow_params)
      redirect_to @workflow, notice: "Workflow updated."
    else
      render :edit, status: :unprocessable_entity
    end
  end

  def destroy
    @workflow = Workflow.find(params[:id])
    @workflow.destroy
    redirect_to workflows_path, notice: "Workflow deleted."
  end

  # Bulk update node positions from React Flow
  def update_positions
    @workflow = Workflow.find(params[:id])
    nodes_data = params[:nodes] || []

    nodes_data.each do |node_data|
      node = @workflow.nodes.find_by(id: node_data[:id])
      node&.update(
        position_x: node_data[:position][:x],
        position_y: node_data[:position][:y]
      )
    end

    head :ok
  end

  private

  def workflow_params
    params.require(:workflow).permit(:name)
  end
end
CONTROLLER

# Create NodesController
cat > app/controllers/nodes_controller.rb << 'CONTROLLER'
class NodesController < ApplicationController
  before_action :set_workflow

  def create
    @node = @workflow.nodes.build(node_params)
    if @node.save
      render json: @node
    else
      render json: { errors: @node.errors }, status: :unprocessable_entity
    end
  end

  def update
    @node = @workflow.nodes.find(params[:id])
    if @node.update(node_params)
      render json: @node
    else
      render json: { errors: @node.errors }, status: :unprocessable_entity
    end
  end

  def destroy
    @node = @workflow.nodes.find(params[:id])
    @node.destroy
    head :ok
  end

  private

  def set_workflow
    @workflow = Workflow.find(params[:workflow_id])
  end

  def node_params
    params.require(:node).permit(:label, :node_type, :position_x, :position_y)
  end
end
CONTROLLER

# Create EdgesController
cat > app/controllers/edges_controller.rb << 'CONTROLLER'
class EdgesController < ApplicationController
  before_action :set_workflow

  def create
    @edge = @workflow.edges.build(edge_params)
    if @edge.save
      render json: @edge
    else
      render json: { errors: @edge.errors }, status: :unprocessable_entity
    end
  end

  def destroy
    @edge = @workflow.edges.find(params[:id])
    @edge.destroy
    head :ok
  end

  private

  def set_workflow
    @workflow = Workflow.find(params[:workflow_id])
  end

  def edge_params
    params.require(:edge).permit(:source_node_id, :target_node_id)
  end
end
CONTROLLER

# Create views directory
mkdir -p app/views/workflows

# Create index view (ERB - no React needed for list)
cat > app/views/workflows/index.html.erb << 'VIEW'
<div class="container mx-auto px-4 py-8">
  <h1 class="text-3xl font-bold mb-8">Workflows</h1>

  <div class="grid gap-4 mb-8">
    <% @workflows.each do |workflow| %>
      <%= render workflow %>
    <% end %>
  </div>

  <%= link_to "New Workflow", new_workflow_path,
      class: "bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700" %>
</div>
VIEW

# Create workflow partial (ERB)
cat > app/views/workflows/_workflow.html.erb << 'PARTIAL'
<div id="<%= dom_id(workflow) %>" class="p-4 bg-white rounded-lg shadow flex justify-between items-center">
  <div>
    <h2 class="text-xl font-semibold"><%= workflow.name %></h2>
    <p class="text-gray-500 text-sm">
      <%= pluralize(workflow.nodes.size, "node") %>,
      <%= pluralize(workflow.edges.size, "edge") %>
    </p>
  </div>
  <div class="flex gap-2">
    <%= link_to "Open", workflow_path(workflow),
        class: "bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700" %>
    <%= link_to "Rename", edit_workflow_path(workflow),
        class: "bg-green-600 text-white px-4 py-2 rounded hover:bg-green-700" %>
    <%= button_to "Delete", workflow_path(workflow), method: :delete,
        class: "bg-red-600 text-white px-4 py-2 rounded hover:bg-red-700",
        data: { confirm: "Delete this workflow?" } %>
  </div>
</div>
PARTIAL

# Create new/edit views (ERB)
cat > app/views/workflows/new.html.erb << 'VIEW'
<div class="container mx-auto px-4 py-8">
  <h1 class="text-3xl font-bold mb-8">New Workflow</h1>
  <%= render "form", workflow: @workflow %>
</div>
VIEW

cat > app/views/workflows/edit.html.erb << 'VIEW'
<div class="container mx-auto px-4 py-8">
  <h1 class="text-3xl font-bold mb-8">Edit Workflow</h1>
  <%= render "form", workflow: @workflow %>
</div>
VIEW

cat > app/views/workflows/_form.html.erb << 'FORM'
<%= form_with model: workflow, class: "space-y-4 max-w-md" do |f| %>
  <div>
    <%= f.label :name, class: "block font-medium mb-1" %>
    <%= f.text_field :name, class: "w-full border rounded p-2" %>
  </div>
  <div class="flex gap-2">
    <%= f.submit class: "bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700 cursor-pointer" %>
    <%= link_to "Cancel", workflows_path, class: "text-gray-600 px-4 py-2" %>
  </div>
<% end %>
FORM

# Create show view (RBX - uses React Flow with real-time collaboration)
# Uses model operations directly (Node.create, Edge.create) instead of fetch()
# This makes the view target-agnostic: works with both browser (Dexie) and Node (RPC) targets
# JsonStreamProvider handles real-time updates via BroadcastChannel (browser) or WebSocket (node)
cat > app/views/workflows/Show.jsx.rb << 'RBX'
import React from 'react'
import WorkflowCanvas from 'components/WorkflowCanvas'
import JsonStreamProvider from '/lib/JsonStreamProvider.js'
import [Node], from: '/app/models/node.js'
import [Edge], from: '/app/models/edge.js'

export default
def Show(workflow:)
  # Get nodes and edges from workflow (preloaded by controller)
  nodes = workflow.nodes
  edges = workflow.edges

  # Convert Rails nodes to React Flow format
  flow_nodes = nodes.map do |node|
    {
      id: node.id.to_s,
      type: 'default',
      position: { x: node.position_x, y: node.position_y },
      data: { label: node.label }
    }
  end

  # Convert Rails edges to React Flow format
  flow_edges = edges.map do |edge|
    {
      id: edge.id.to_s,
      source: edge.source_node_id.to_s,
      target: edge.target_node_id.to_s
    }
  end

  handle_save = ->(updated_nodes) {
    # Update node positions directly in the database
    updated_nodes.each do |node_data|
      Node.find(node_data.id.to_i).then(->(node) {
        node.update(position_x: node_data.position.x, position_y: node_data.position.y)
      })
    end
  }

  handle_add_node = ->(position) {
    # Create node directly in the database
    Node.create(
      label: "New Node",
      node_type: "default",
      position_x: position.x,
      position_y: position.y,
      workflow_id: workflow.id
    )
  }

  handle_add_edge = ->(source_id, target_id) {
    # Create edge directly in the database
    Edge.create(
      source_node_id: source_id.to_i,
      target_node_id: target_id.to_i,
      workflow_id: workflow.id
    )
  }

  handle_delete_node = ->(node_id) {
    # Delete node from database (also deletes associated edges via dependent: :destroy)
    Node.find(node_id.to_i).then(->(node) {
      node.destroy()
    })
  }

  handle_update_node = ->(node_id, label) {
    # Update node label in database
    Node.find(node_id.to_i).then(->(node) {
      node.update(label: label)
    })
  }

  %x{
    <div className="container mx-auto px-4 py-8">
      <div className="flex justify-between items-center mb-4">
        <h1 className="text-3xl font-bold">{workflow.name}</h1>
        <a href="/workflows" className="text-blue-600 hover:underline">
          Back to Workflows
        </a>
      </div>
      <JsonStreamProvider stream={"workflow_#{workflow.id}"}>
        <WorkflowCanvas
          initialNodes={flow_nodes}
          initialEdges={flow_edges}
          onSave={handle_save}
          onAddNode={handle_add_node}
          onAddEdge={handle_add_edge}
          onDeleteNode={handle_delete_node}
          onUpdateNode={handle_update_node}
        />
      </JsonStreamProvider>
    </div>
  }
end
RBX

# Create components directory
mkdir -p app/components

# Create WorkflowCanvas component with real-time updates via useJsonStream hook
# Uses target pragma to mark React Flow as browser-only
cat > app/components/WorkflowCanvas.jsx.rb << 'COMPONENT'
import React, [useState, useEffect, useCallback], from: 'react'
# React Flow is browser-only (visual canvas library)
import ReactFlow, [Background, Controls, MiniMap, useNodesState, useEdgesState, addEdge], from: 'reactflow' # Pragma: browser
import 'reactflow/dist/style.css' # Pragma: browser
import [useJsonStream], from: '/lib/JsonStreamProvider.js'

export default
def WorkflowCanvas(initialNodes:, initialEdges:, onSave:, onAddNode:, onAddEdge:, onDeleteNode:, onUpdateNode:)
  # SSR-safe: only render canvas when ReactFlow is available
  unless defined?(ReactFlow)
    return %x{
      <div style={{ width: '100%', height: '600px', border: '1px solid #ddd', borderRadius: '8px' }}
           className="flex items-center justify-center bg-gray-100">
        <p className="text-gray-500">Workflow canvas requires browser environment</p>
      </div>
    }
  end

  nodes, setNodes, onNodesChange = useNodesState(initialNodes)
  edges, setEdges, onEdgesChange = useEdgesState(initialEdges)
  reactFlowInstance, setReactFlowInstance = useState(nil)

  # Get JSON stream messages from context provider
  stream = useJsonStream()

  # Handle incoming broadcast messages for real-time collaboration
  useEffect(-> {
    return unless stream.lastMessage
    payload = stream.lastMessage

    case payload.type
    when 'node_created'
      new_node = {
        id: payload.id.to_s,
        type: 'default',
        position: { x: payload.data.position_x, y: payload.data.position_y },
        data: { label: payload.data.label }
      }
      setNodes(->(nds) { [*nds, new_node] })

    when 'node_updated'
      setNodes(->(nds) {
        nds.map do |n|
          if n.id == payload.id.to_s
            {
              **n,
              position: { x: payload.data.position_x, y: payload.data.position_y },
              data: { label: payload.data.label }
            }
          else
            n
          end
        end
      })

    when 'node_destroyed'
      setNodes(->(nds) { nds.filter(->(n) { n.id != payload.id.to_s }) })

    when 'edge_created'
      new_edge = {
        id: payload.id.to_s,
        source: payload.data.source_node_id.to_s,
        target: payload.data.target_node_id.to_s
      }
      setEdges(->(eds) { [*eds, new_edge] })

    when 'edge_destroyed'
      setEdges(->(eds) { eds.filter(->(e) { e.id != payload.id.to_s }) })
    end
  }, [stream.lastMessage])

  # Handle new connections between nodes
  handle_connect = ->(connection) {
    onAddEdge(connection.source, connection.target).then(->(edge) {
      setEdges(->(eds) {
        addEdge({ **connection, id: edge.id.to_s }, eds)
      })
    })
  }

  # Save positions after drag ends
  handle_node_drag_stop = ->(_event, _node) {
    # Collect all node positions
    positions = nodes.map do |n|
      { id: n.id, position: n.position }
    end
    onSave(positions)
  }

  # Double-click on pane to add new node (uses viewport-aware coordinates)
  handle_pane_double_click = useCallback(->(event) {
    return unless reactFlowInstance
    # Convert screen coordinates to flow coordinates (accounts for zoom/pan)
    position = reactFlowInstance.screenToFlowPosition({
      x: event.clientX,
      y: event.clientY
    })

    onAddNode(position).then(->(node) {
      new_node = {
        id: node.id.to_s,
        type: 'default',
        position: { x: node.position_x, y: node.position_y },
        data: { label: node.label }
      }
      setNodes(->(nds) { [*nds, new_node] })
    })
  }, [reactFlowInstance, onAddNode])

  # Delete selected nodes via keyboard (Backspace/Delete)
  handle_nodes_delete = ->(deleted_nodes) {
    deleted_nodes.each do |node|
      onDeleteNode(node.id)
    end
  }

  # Double-click on node to edit label
  handle_node_double_click = ->(_event, node) {
    new_label = prompt("Edit node label:", node.data.label)
    if new_label && new_label != node.data.label
      onUpdateNode(node.id, new_label)
      # Optimistic update - real-time broadcast will confirm
      setNodes(->(nds) {
        nds.map do |n|
          if n.id == node.id
            { **n, data: { **n.data, label: new_label } }
          else
            n
          end
        end
      })
    end
  }

  %x{
    <div style={{ width: '100%', height: '600px', border: '1px solid #ddd', borderRadius: '8px' }}>
      <ReactFlow
        nodes={nodes}
        edges={edges}
        onNodesChange={onNodesChange}
        onEdgesChange={onEdgesChange}
        onConnect={handle_connect}
        onNodeDragStop={handle_node_drag_stop}
        onNodesDelete={handle_nodes_delete}
        onNodeDoubleClick={handle_node_double_click}
        onPaneDoubleClick={handle_pane_double_click}
        onInit={setReactFlowInstance}
        zoomOnDoubleClick={false}
        fitView
      >
        <Background color="#aaa" gap={16} />
        <Controls />
        <MiniMap />
      </ReactFlow>
      <p className="text-gray-500 text-sm mt-2 text-center">
        Double-click canvas to add nodes. Double-click node to edit label. Select + Delete to remove. Drag handles to connect.
      </p>
    </div>
  }
end
COMPONENT

# Rebuild Tailwind CSS to include all view classes
bin/rails tailwindcss:build

# Create seeds with sample workflow
cat > db/seeds.rb << 'SEEDS'
# Sample workflow for the demo
return if Workflow.count > 0

workflow = Workflow.create!(name: "User Registration Flow")

# Create nodes
start_node = workflow.nodes.create!(
  label: "Start",
  node_type: "input",
  position_x: 250,
  position_y: 0
)

email_node = workflow.nodes.create!(
  label: "Enter Email",
  node_type: "default",
  position_x: 100,
  position_y: 100
)

password_node = workflow.nodes.create!(
  label: "Create Password",
  node_type: "default",
  position_x: 400,
  position_y: 100
)

verify_node = workflow.nodes.create!(
  label: "Verify Email",
  node_type: "default",
  position_x: 250,
  position_y: 200
)

complete_node = workflow.nodes.create!(
  label: "Registration Complete",
  node_type: "output",
  position_x: 250,
  position_y: 300
)

# Create edges
workflow.edges.create!(source_node: start_node, target_node: email_node)
workflow.edges.create!(source_node: start_node, target_node: password_node)
workflow.edges.create!(source_node: email_node, target_node: verify_node)
workflow.edges.create!(source_node: password_node, target_node: verify_node)
workflow.edges.create!(source_node: verify_node, target_node: complete_node)

puts "Created workflow '#{workflow.name}' with #{workflow.nodes.count} nodes and #{workflow.edges.count} edges"
SEEDS

# Create ruby2js.yml with React dependencies
# These get added to dist/package.json and bundled by Vite
cat > config/ruby2js.yml << 'CONFIG'
# React ecosystem dependencies for RBX files
dependencies:
  react: "^18.2.0"
  react-dom: "^18.2.0"
  reactflow: "^11.10.0"
CONFIG

# Run ruby2js:install generator to set up dist/, package.json, and npm dependencies
bin/rails generate ruby2js:install

echo ""
echo "Workflow builder created: $APP_NAME/"
echo ""
echo "To run with Juntos (transpiled to JavaScript):"
echo "  cd $APP_NAME"
echo "  bin/juntos dev -d dexie              # Browser with IndexedDB"
echo "  bin/juntos up -t node -d sqlite      # Node.js with SQLite"
echo ""
echo "Real-time collaboration:"
echo "  - Browser target: changes sync across tabs via BroadcastChannel"
echo "  - Node target: changes sync across clients via WebSocket"
echo "  - Open multiple browser windows to see real-time updates!"
echo ""
echo "The canvas uses React Flow for drag-and-drop node editing."
echo "  - Double-click canvas to add nodes"
echo "  - Double-click node to edit label"
echo "  - Select node + Delete key to remove"
echo "  - Drag handles to connect nodes"
echo ""
echo "Real-time components (from ruby2js-rails package):"
echo "  - JsonStreamProvider: React context for real-time subscriptions"
echo "  - useJsonStream hook: access broadcast messages in components"
echo "  - broadcast_json_to: model callback sends JSON events"
echo ""
echo "To run with Rails:"
echo "  cd $APP_NAME"
echo "  bin/rails db:prepare"
echo "  bin/rails server"
echo ""
