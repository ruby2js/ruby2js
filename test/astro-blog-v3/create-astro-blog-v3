#!/bin/bash
# Create Astro blog v3 - browser-first SSR with worker-in-browser pattern
# Same code can target browser (IndexedDB) or edge (D1) with adapter swap

set -e

# Color output
RED='\033[0;31m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Get the directory where this script is located
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
RUBY2JS_ROOT="$(dirname "$(dirname "$SCRIPT_DIR")")"

echo -e "${BLUE}Creating Astro blog v3...${NC}"

# Create project directory
PROJECT_DIR="${1:-/tmp/astro-blog-v3}"
rm -rf "$PROJECT_DIR"
mkdir -p "$PROJECT_DIR"
cd "$PROJECT_DIR"

echo -e "${GREEN}Initializing npm project...${NC}"
npm init -y > /dev/null

# Install dependencies
echo -e "${GREEN}Installing dependencies...${NC}"
npm install astro @hotwired/turbo > /dev/null 2>&1

# Install ruby2js packages from local development paths
npm install "$RUBY2JS_ROOT/packages/ruby2js-rails" > /dev/null 2>&1

# Install esbuild for browser bundling
npm install -D esbuild > /dev/null 2>&1

# Create directory structure
mkdir -p src/{layouts,pages/articles,lib,models}
mkdir -p 'src/pages/articles/[id]'
mkdir -p public

# ============================================================
# Browser Adapter
# ============================================================

# Create browser adapter for Astro
cat > browser-adapter.mjs << 'EOF'
// Minimal browser adapter for Astro
// Produces a worker-like module with fetch(request) -> Response

export default function browserAdapter() {
  return {
    name: 'astro-adapter-browser',
    hooks: {
      'astro:config:done': ({ setAdapter }) => {
        setAdapter({
          name: 'astro-adapter-browser',
          serverEntrypoint: './browser-server.mjs',
          exports: ['default'],
          adapterFeatures: {
            buildOutput: 'server'
          },
          supportedAstroFeatures: {
            serverOutput: 'stable',
            staticOutput: 'stable'
          }
        });
      }
    }
  };
}
EOF

# Create browser server runtime
cat > browser-server.mjs << 'EOF'
// Browser server runtime - exports a fetch handler
import { App } from 'astro/app';

export function createExports(manifest) {
  const app = new App(manifest);

  return {
    default: {
      async fetch(request, env, ctx) {
        const response = await app.render(request);
        return response;
      }
    }
  };
}

export function start(manifest) {
  // No-op for browser - we don't auto-start
}
EOF

# Create astro.config.mjs with browser adapter and vite plugin
cat > astro.config.mjs << 'EOF'
import { defineConfig } from 'astro/config';
import browserAdapter from './browser-adapter.mjs';
import { ruby2jsModels } from 'ruby2js-rails/vite-models';

export default defineConfig({
  output: 'server',
  adapter: browserAdapter(),
  // Disable CSRF check for browser mode (Origin header can't be set from JS)
  security: {
    checkOrigin: false
  },
  // Use noop image service to avoid sharp (Node.js dependency)
  image: {
    service: { entrypoint: 'astro/assets/services/noop' }
  },
  vite: {
    plugins: [
      ruby2jsModels({
        database: 'dexie',
        modelsDir: 'src/models',
        outDir: 'src/lib/models'
      })
    ]
  }
});
EOF

# Create tsconfig.json
cat > tsconfig.json << 'EOF'
{
  "extends": "astro/tsconfigs/strict",
  "compilerOptions": {
    "strictNullChecks": true
  }
}
EOF

# Create the base layout with Turbo
cat > src/layouts/Layout.astro << 'EOF'
---
interface Props {
  title: string;
}

const { title } = Astro.props;
---

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <title>{title}</title>
    <style>
      :root {
        --color-bg: #f9fafb;
        --color-text: #111827;
        --color-primary: #2563eb;
        --color-primary-dark: #1d4ed8;
        --color-border: #e5e7eb;
        --color-error: #dc2626;
        --max-width: 800px;
      }

      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      body {
        font-family: system-ui, -apple-system, sans-serif;
        background: var(--color-bg);
        color: var(--color-text);
        line-height: 1.6;
        padding: 2rem;
      }

      .container {
        max-width: var(--max-width);
        margin: 0 auto;
      }

      header {
        margin-bottom: 2rem;
        padding-bottom: 1rem;
        border-bottom: 1px solid var(--color-border);
      }

      header h1 a {
        color: var(--color-text);
        text-decoration: none;
      }

      nav {
        margin-top: 0.5rem;
      }

      nav a {
        color: var(--color-primary);
        text-decoration: none;
        margin-right: 1rem;
      }

      nav a:hover {
        text-decoration: underline;
      }

      main {
        min-height: 60vh;
      }

      a {
        color: var(--color-primary);
      }

      a:hover {
        color: var(--color-primary-dark);
      }

      .btn {
        display: inline-block;
        padding: 0.5rem 1rem;
        background: var(--color-primary);
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        text-decoration: none;
        font-size: 1rem;
      }

      .btn:hover {
        background: var(--color-primary-dark);
        color: white;
      }

      .btn-danger {
        background: var(--color-error);
      }

      .btn-danger:hover {
        background: #b91c1c;
      }

      .form-group {
        margin-bottom: 1rem;
      }

      .form-group label {
        display: block;
        margin-bottom: 0.25rem;
        font-weight: 500;
      }

      .form-group input,
      .form-group textarea {
        width: 100%;
        padding: 0.5rem;
        border: 1px solid var(--color-border);
        border-radius: 4px;
        font-size: 1rem;
      }

      .form-group textarea {
        min-height: 150px;
        resize: vertical;
      }

      .article-card {
        padding: 1rem;
        margin-bottom: 1rem;
        border: 1px solid var(--color-border);
        border-radius: 4px;
        background: white;
      }

      .article-card h2 {
        margin-bottom: 0.5rem;
      }

      .article-card h2 a {
        text-decoration: none;
      }

      .article-meta {
        color: #6b7280;
        font-size: 0.875rem;
      }

      .article-body {
        margin: 1rem 0;
        white-space: pre-wrap;
      }

      .actions {
        display: flex;
        gap: 0.5rem;
        margin-top: 1rem;
      }

      .comment {
        padding: 1rem;
        margin-bottom: 0.5rem;
        background: #f3f4f6;
        border-radius: 4px;
      }

      .comment-meta {
        color: #6b7280;
        font-size: 0.875rem;
        margin-bottom: 0.5rem;
      }

      .comments-section {
        margin-top: 2rem;
        padding-top: 1rem;
        border-top: 1px solid var(--color-border);
      }

      .error {
        color: var(--color-error);
        font-size: 0.875rem;
        margin-top: 0.25rem;
      }

      .flash {
        padding: 1rem;
        margin-bottom: 1rem;
        border-radius: 4px;
        background: #d1fae5;
        color: #065f46;
      }

      .flash.error {
        background: #fee2e2;
        color: var(--color-error);
      }
    </style>
  </head>
  <body>
    <div class="container">
      <header>
        <h1><a href="/">Astro Blog</a></h1>
        <nav>
          <a href="/">Home</a>
          <a href="/articles">Articles</a>
          <a href="/about">About</a>
        </nav>
      </header>
      <main>
        <slot />
      </main>
    </div>
  </body>
</html>
EOF

# Create landing page
cat > src/pages/index.astro << 'EOF'
---
import Layout from '../layouts/Layout.astro';
---

<Layout title="Astro Blog">
  <h2>Welcome to Astro Blog</h2>
  <p>A simple blog built with Astro SSR, running entirely in your browser.</p>
  <p>This demonstrates the <strong>worker-in-browser pattern</strong>:</p>
  <ul>
    <li>Server-side rendering runs as a bundled worker</li>
    <li>Data persists in IndexedDB via Dexie</li>
    <li>Same code can deploy to edge (Cloudflare D1) or browser</li>
  </ul>
  <p>
    <a href="/articles" class="btn">View Articles</a>
  </p>
</Layout>
EOF

# Create about page
cat > src/pages/about.astro << 'EOF'
---
import Layout from '../layouts/Layout.astro';
---

<Layout title="About - Astro Blog">
  <h2>About This Demo</h2>
  <p>
    This blog demonstrates the <strong>worker-in-browser pattern</strong>:
    the same SSR code that runs on edge workers can also run
    directly in your browser.
  </p>

  <h3>How It Works</h3>
  <ol>
    <li>Build Astro with browser adapter (produces <code>dist/server/entry.mjs</code>)</li>
    <li>Bundle the entry for browser with esbuild</li>
    <li>Shell page loads the worker and intercepts navigation</li>
    <li>Requests route to <code>worker.fetch()</code> instead of HTTP</li>
    <li>Worker renders HTML, shell updates the page</li>
  </ol>

  <h3>Database Adapters</h3>
  <ul>
    <li><strong>Browser</strong>: Dexie (IndexedDB)</li>
    <li><strong>Edge</strong>: D1, Turso, Neon, etc.</li>
  </ul>

  <p>Same application logic, different storage backends.</p>

  <p><a href="/articles">&larr; Back to Articles</a></p>
</Layout>
EOF

# Create database setup module
cat > src/lib/db.mjs << 'EOF'
// Database setup - uses Dexie adapter for IndexedDB
import {
  initDatabase,
  openDatabase,
  defineSchema,
  registerSchema
} from 'ruby2js-rails/adapters/active_record_dexie.mjs';

let initialized = false;

// Register schemas for Dexie (needed before openDatabase)
registerSchema('articles', '++id, title, created_at');
registerSchema('comments', '++id, article_id, created_at');

export async function setupDatabase() {
  if (initialized) return;

  await initDatabase({ database: 'astro-blog' });
  defineSchema(1);
  await openDatabase();

  initialized = true;
}

// Re-export for direct access if needed
export { initDatabase, openDatabase, defineSchema, registerSchema };
EOF

# Create Article model (Ruby - transpiled by vite plugin)
cat > src/models/article.rb << 'EOF'
class Article < ApplicationRecord
  has_many :comments, dependent: :destroy

  validates :title, presence: true
  validates :body, presence: true, length: { minimum: 10 }
end
EOF

# Create Comment model (Ruby - transpiled by vite plugin)
cat > src/models/comment.rb << 'EOF'
class Comment < ApplicationRecord
  belongs_to :article

  validates :commenter, presence: true
  validates :body, presence: true
end
EOF

# Create articles index page
cat > src/pages/articles/index.astro << 'EOF'
---
import Layout from '../../layouts/Layout.astro';
import { setupDatabase } from '../../lib/db.mjs';
import { Article } from '../../lib/models/index.js';

// Initialize database
await setupDatabase();

const articles = await Article.order({ created_at: 'desc' }).toArray();
---

<Layout title="Articles - Astro Blog">
  <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
    <h2>Articles</h2>
    <a href="/articles/new" class="btn">New Article</a>
  </div>

  {articles.length === 0 ? (
    <p>No articles yet. <a href="/articles/new">Create one</a>!</p>
  ) : (
    <div id="articles">
      {articles.map((article) => (
        <div class="article-card">
          <h2><a href={`/articles/${article.id}`}>{article.title}</a></h2>
          <p class="article-meta">
            Created {new Date(article.created_at).toLocaleDateString()}
          </p>
          <p>{article.body.substring(0, 200)}{article.body.length > 200 ? '...' : ''}</p>
        </div>
      ))}
    </div>
  )}
</Layout>
EOF

# Create new article page
cat > src/pages/articles/new.astro << 'EOF'
---
import Layout from '../../layouts/Layout.astro';
import { setupDatabase } from '../../lib/db.mjs';
import { Article } from '../../lib/models/index.js';

// Initialize database
await setupDatabase();

let errors = {};
let title = '';
let body = '';

if (Astro.request.method === 'POST') {
  const formData = await Astro.request.formData();
  title = formData.get('title')?.toString() || '';
  body = formData.get('body')?.toString() || '';

  const article = new Article({ title, body });

  if (await article.save()) {
    return Astro.redirect(`/articles/${article.id}`);
  }

  errors = article.errors;
}
---

<Layout title="New Article - Astro Blog">
  <h2>New Article</h2>

  <form method="POST" action="/articles/new">
    <div class="form-group">
      <label for="title">Title</label>
      <input type="text" id="title" name="title" value={title} />
      {errors.title && <p class="error">{errors.title[0]}</p>}
    </div>

    <div class="form-group">
      <label for="body">Body</label>
      <textarea id="body" name="body">{body}</textarea>
      {errors.body && <p class="error">{errors.body[0]}</p>}
    </div>

    <div class="actions">
      <button type="submit" class="btn">Create Article</button>
      <a href="/articles">Cancel</a>
    </div>
  </form>
</Layout>
EOF

# Create show article page
cat > 'src/pages/articles/[id].astro' << 'EOF'
---
import Layout from '../../layouts/Layout.astro';
import { setupDatabase } from '../../lib/db.mjs';
import { Article, Comment } from '../../lib/models/index.js';

// Initialize database
await setupDatabase();

const id = Number(Astro.params.id);

// Handle POST actions
if (Astro.request.method === 'POST') {
  const formData = await Astro.request.formData();
  const action = formData.get('_action');

  if (action === 'delete_article') {
    const article = await Article.find(id);
    await article.destroy();
    return Astro.redirect('/articles');
  }

  if (action === 'add_comment') {
    const commenter = formData.get('commenter')?.toString() || 'Anonymous';
    const body = formData.get('body')?.toString() || '';
    if (body.trim()) {
      await Comment.create({ article_id: id, commenter, body });
    }
    return Astro.redirect(`/articles/${id}`);
  }

  if (action === 'delete_comment') {
    const commentId = Number(formData.get('comment_id'));
    const comment = await Comment.find(commentId);
    await comment.destroy();
    return Astro.redirect(`/articles/${id}`);
  }
}

let article;
try {
  article = await Article.find(id);
} catch (e) {
  return Astro.redirect('/articles');
}

const comments = await Comment.where({ article_id: id }).order({ created_at: 'asc' }).toArray();
---

<Layout title={`${article.title} - Astro Blog`}>
  <article>
    <h2>{article.title}</h2>
    <p class="article-meta">
      Created {new Date(article.created_at).toLocaleDateString()}
      {article.updated_at !== article.created_at && (
        <span> · Updated {new Date(article.updated_at).toLocaleDateString()}</span>
      )}
    </p>
    <div class="article-body">{article.body}</div>

    <div class="actions">
      <a href={`/articles/${id}/edit`} class="btn">Edit</a>
      <form method="POST" action={`/articles/${id}`} style="display: inline;">
        <input type="hidden" name="_action" value="delete_article" />
        <button type="submit" class="btn btn-danger"
                onclick="return confirm('Are you sure?')">Delete</button>
      </form>
      <a href="/articles">Back to Articles</a>
    </div>
  </article>

  <section class="comments-section">
    <h3>Comments ({comments.length})</h3>

    <div id="comments">
      {comments.map((comment) => (
        <div class="comment">
          <p class="comment-meta">
            <strong>{comment.commenter}</strong> ·
            {new Date(comment.created_at).toLocaleDateString()}
            <form method="POST" action={`/articles/${id}`} style="display: inline; margin-left: 1rem;">
              <input type="hidden" name="_action" value="delete_comment" />
              <input type="hidden" name="comment_id" value={comment.id} />
              <button type="submit" style="background: none; border: none; color: var(--color-error); cursor: pointer;">
                Delete
              </button>
            </form>
          </p>
          <p>{comment.body}</p>
        </div>
      ))}
    </div>

    <h4 style="margin-top: 1rem;">Add a comment</h4>
    <form method="POST" action={`/articles/${id}`}>
      <input type="hidden" name="_action" value="add_comment" />
      <div class="form-group">
        <label for="commenter">Name</label>
        <input type="text" id="commenter" name="commenter" placeholder="Anonymous" />
      </div>
      <div class="form-group">
        <label for="comment_body">Comment</label>
        <textarea id="comment_body" name="body" rows="3"></textarea>
      </div>
      <button type="submit" class="btn">Post Comment</button>
    </form>
  </section>
</Layout>
EOF

# Create edit article page
cat > 'src/pages/articles/[id]/edit.astro' << 'EOF'
---
import Layout from '../../../layouts/Layout.astro';
import { setupDatabase } from '../../../lib/db.mjs';
import { Article } from '../../../lib/models/index.js';

// Initialize database
await setupDatabase();

const id = Number(Astro.params.id);
let article;

try {
  article = await Article.find(id);
} catch (e) {
  return Astro.redirect('/articles');
}

let errors = {};
let title = article.title;
let body = article.body;

if (Astro.request.method === 'POST') {
  const formData = await Astro.request.formData();
  title = formData.get('title')?.toString() || '';
  body = formData.get('body')?.toString() || '';

  article.title = title;
  article.body = body;

  if (await article.save()) {
    return Astro.redirect(`/articles/${id}`);
  }

  errors = article.errors;
}
---

<Layout title={`Edit: ${article.title} - Astro Blog`}>
  <h2>Edit Article</h2>

  <form method="POST" action={`/articles/${id}/edit`}>
    <div class="form-group">
      <label for="title">Title</label>
      <input type="text" id="title" name="title" value={title} />
      {errors.title && <p class="error">{errors.title[0]}</p>}
    </div>

    <div class="form-group">
      <label for="body">Body</label>
      <textarea id="body" name="body">{body}</textarea>
      {errors.body && <p class="error">{errors.body[0]}</p>}
    </div>

    <div class="actions">
      <button type="submit" class="btn">Update Article</button>
      <a href={`/articles/${id}`}>Cancel</a>
    </div>
  </form>
</Layout>
EOF

# Create favicon
cat > public/favicon.svg << 'EOF'
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 128 128">
  <rect width="128" height="128" fill="#2563eb" rx="8"/>
  <text x="64" y="80" font-family="system-ui" font-size="64" fill="white" text-anchor="middle">A</text>
</svg>
EOF

# ============================================================
# Browser Shell and Bundling
# ============================================================

# Create browser shell (index.html for serving the app)
cat > public/index.html << 'EOF'
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Astro Blog</title>
</head>
<body>
  <div id="app">Loading...</div>
  <script type="module">
    // Minimal shim for process.env
    window.process = { env: {} };

    const app = document.getElementById('app');
    let worker;

    async function init() {
      worker = await import('./browser-worker.mjs');
      await navigate(location.pathname || '/');
    }

    async function navigate(path) {
      const url = new URL(path, location.origin);
      const request = new Request(url.href);

      try {
        const response = await worker.default.fetch(request);
        const html = await response.text();

        // Parse and render
        const parser = new DOMParser();
        const doc = parser.parseFromString(html, 'text/html');

        // Update title
        const title = doc.querySelector('title');
        if (title) document.title = title.textContent;

        // Replace body content
        document.body.innerHTML = doc.body.innerHTML;

        // Re-attach click handlers for navigation
        attachLinkHandlers();
      } catch (e) {
        app.innerHTML = '<p style="color:red">Error: ' + e.message + '</p>';
        console.error(e);
      }
    }

    async function submitForm(form) {
      const url = new URL(form.action || location.href, location.origin);
      const formData = new FormData(form);
      const request = new Request(url.href, {
        method: form.method?.toUpperCase() || 'POST',
        body: formData
      });

      try {
        const response = await worker.default.fetch(request);

        // Handle redirects
        if (response.status >= 300 && response.status < 400) {
          const location = response.headers.get('Location');
          if (location) {
            history.pushState({}, '', location);
            await navigate(location);
            return;
          }
        }

        const html = await response.text();
        const parser = new DOMParser();
        const doc = parser.parseFromString(html, 'text/html');

        const title = doc.querySelector('title');
        if (title) document.title = title.textContent;

        document.body.innerHTML = doc.body.innerHTML;
        attachLinkHandlers();
      } catch (e) {
        console.error('Form submission error:', e);
      }
    }

    function attachLinkHandlers() {
      // Handle link clicks
      document.querySelectorAll('a[href^="/"]').forEach(link => {
        link.addEventListener('click', (e) => {
          e.preventDefault();
          const path = link.getAttribute('href');
          history.pushState({}, '', path);
          navigate(path);
        });
      });

      // Handle form submissions
      document.querySelectorAll('form').forEach(form => {
        form.addEventListener('submit', (e) => {
          e.preventDefault();
          submitForm(form);
        });
      });
    }

    // Handle back/forward
    window.addEventListener('popstate', () => {
      navigate(location.pathname);
    });

    init();
  </script>
</body>
</html>
EOF

# Create esbuild bundler for browser
cat > bundle-for-browser.mjs << 'EOF'
// Bundle the Astro server entry for browser execution
import * as esbuild from 'esbuild';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';

const __dirname = dirname(fileURLToPath(import.meta.url));

async function bundle() {
  console.log('Bundling worker for browser...');

  try {
    const result = await esbuild.build({
      entryPoints: [join(__dirname, 'dist/server/entry.mjs')],
      bundle: true,
      outfile: join(__dirname, 'dist/client/browser-worker.mjs'),
      format: 'esm',
      platform: 'browser',
      target: 'es2020',
      minify: false,
      sourcemap: true,
      define: {
        'process.env.NODE_ENV': '"production"'
      },
      logLevel: 'info'
    });

    console.log('Bundle created: dist/client/browser-worker.mjs');
    return result;
  } catch (error) {
    console.error('Bundle failed:', error);
    process.exit(1);
  }
}

bundle();
EOF

# Update package.json
cat > package.json << 'EOF'
{
  "name": "astro-blog-v3",
  "type": "module",
  "version": "0.0.1",
  "scripts": {
    "dev": "astro dev",
    "build": "astro build && node bundle-for-browser.mjs",
    "preview": "npx serve dist/client",
    "astro": "astro"
  },
  "dependencies": {
    "@hotwired/turbo": "^8.0.0",
    "astro": "^5.0.0"
  },
  "devDependencies": {
    "esbuild": "^0.24.0"
  }
}
EOF

# Reinstall with correct package.json
npm install > /dev/null 2>&1
npm install "$RUBY2JS_ROOT/packages/ruby2js-rails" > /dev/null 2>&1

echo ""
echo -e "${GREEN}Astro blog v3 created at: $PROJECT_DIR${NC}"
echo ""
echo "To run:"
echo "  cd $PROJECT_DIR"
echo "  npm run build     # Build for browser"
echo "  npm run preview   # Serve at http://localhost:3000"
echo ""
echo "For development:"
echo "  npm run dev       # Start Astro dev server (limited - no IndexedDB)"
echo ""
