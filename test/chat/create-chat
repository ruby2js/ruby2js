#!/usr/bin/env bash
# Create a Ruby2JS chat demo with Turbo Streams
# Usage: create-chat [app-name]
#
# Creates a Rails app with a simple chat room demonstrating
# real-time Turbo Streams broadcasting.

set -e

APP_NAME="${1:-chat}"

echo "Creating Ruby2JS chat: $APP_NAME"
echo ""

# Create Rails app (minimal, with Tailwind for nice styling)
rails new "$APP_NAME" --skip-git --skip-docker --css tailwind
cd "$APP_NAME"

# Generate Message scaffold
rails generate scaffold Message username:string body:text

# Remove unused scaffolded views (chat only needs index, create, destroy)
rm -f app/views/messages/show.html.erb \
      app/views/messages/edit.html.erb \
      app/views/messages/new.html.erb \
      app/views/messages/_form.html.erb \
      app/views/messages/*.json.jbuilder

# Create database
rails db:create

# Update Message model with broadcasting
cat > app/models/message.rb << 'MODEL'
class Message < ApplicationRecord
  validates :username, presence: true
  validates :body, presence: true

  # Broadcast all changes (create, update, destroy) to chat room subscribers
  broadcasts_to -> { "chat_room" }, target: "messages"
end
MODEL

# Set up routes - simple single room chat
cat > config/routes.rb << 'ROUTES'
Rails.application.routes.draw do
  root "messages#index"
  resources :messages, only: [:index, :create, :destroy]
end
ROUTES

# Update MessagesController for chat
cat > app/controllers/messages_controller.rb << 'CONTROLLER'
class MessagesController < ApplicationController
  def index
    @messages = Message.order(created_at: :asc)
    @message = Message.new
  end

  def create
    @message = Message.new(message_params)
    if @message.save
      # Turbo Stream handles the response - just acknowledge
      respond_to do |format|
        format.turbo_stream
        format.html { redirect_to messages_path }
      end
    else
      redirect_to messages_path, alert: "Could not send message."
    end
  end

  def destroy
    @message = Message.find(params[:id])
    @message.destroy
    respond_to do |format|
      format.turbo_stream
      format.html { redirect_to messages_path }
    end
  end

  private

  def message_params
    params.require(:message).permit(:username, :body)
  end
end
CONTROLLER

# Create chat room view
cat > app/views/messages/index.html.erb << 'VIEW'
<div class="max-w-2xl mx-auto p-4" data-controller="chat">
  <h1 class="text-2xl font-bold mb-6">Chat Room</h1>

  <%# Subscribe to real-time updates %>
  <%= turbo_stream_from "chat_room" %>

  <%# Messages container - broadcasts append here %>
  <div id="messages"
       class="space-y-4 mb-8 h-96 overflow-y-auto border rounded p-4 bg-gray-50">
    <%= render @messages %>
  </div>

  <%# New message form - clears input after successful submission %>
  <%= form_with model: @message, class: "space-y-4",
      data: { action: "turbo:submit-end->chat#clearInput" } do |form| %>
    <div class="flex gap-4">
      <div class="w-1/4">
        <%= form.text_field :username,
            placeholder: "Your name",
            value: cookies[:chat_username],
            class: "w-full border rounded p-2" %>
      </div>
      <div class="flex-1">
        <%= form.text_field :body,
            placeholder: "Type a message...",
            autofocus: true,
            class: "w-full border rounded p-2",
            data: { chat_target: "body" } %>
      </div>
      <%= form.submit "Send",
          class: "bg-blue-600 text-white px-6 py-2 rounded hover:bg-blue-700" %>
    </div>
  <% end %>
</div>
VIEW

# Create message partial
cat > app/views/messages/_message.html.erb << 'PARTIAL'
<div id="<%= dom_id(message) %>" class="p-3 bg-white rounded shadow-sm" data-chat-target="message">
  <div class="flex justify-between items-start">
    <div>
      <span class="font-semibold text-blue-600"><%= message.username %></span>
      <span class="text-gray-400 text-sm ml-2"><%= message.created_at.strftime("%H:%M") %></span>
    </div>
    <%= button_to "Ã—", message_path(message), method: :delete,
        class: "text-gray-400 hover:text-red-600 text-xl leading-none",
        data: { turbo_confirm: "Delete this message?" } %>
  </div>
  <p class="text-gray-700 mt-1"><%= message.body %></p>
</div>
PARTIAL

# Create Turbo Stream response for create
mkdir -p app/views/messages
cat > app/views/messages/create.turbo_stream.erb << 'TURBO'
<%# Clear the form after sending %>
<%= turbo_stream.replace "new_message" do %>
  <%= form_with model: Message.new, class: "space-y-4" do |form| %>
    <div class="flex gap-4">
      <div class="w-1/4">
        <%= form.text_field :username,
            placeholder: "Your name",
            value: cookies[:chat_username],
            class: "w-full border rounded p-2" %>
      </div>
      <div class="flex-1">
        <%= form.text_field :body,
            placeholder: "Type a message...",
            autofocus: true,
            class: "w-full border rounded p-2" %>
      </div>
      <%= form.submit "Send",
          class: "bg-blue-600 text-white px-6 py-2 rounded hover:bg-blue-700" %>
    </div>
  <% end %>
<% end %>
TURBO

# Create Turbo Stream response for destroy (empty - broadcast handles it)
cat > app/views/messages/destroy.turbo_stream.erb << 'TURBO'
<%# Broadcast handles the removal - nothing needed here %>
TURBO

# Rebuild Tailwind CSS
bin/rails tailwindcss:build

# Create seeds with sample messages
cat > db/seeds.rb << 'SEEDS'
# Sample messages for the chat demo
return if Message.count > 0

Message.create!(username: "Alice", body: "Hey everyone! Welcome to the chat room.")
Message.create!(username: "Bob", body: "Hi Alice! This is pretty cool.")
Message.create!(username: "Carol", body: "Love how messages appear in real-time!")
Message.create!(username: "Alice", body: "Yeah, Turbo Streams makes it so easy.")

puts "Created #{Message.count} sample messages"
SEEDS

# Create Stimulus controller for auto-scroll and form clearing (in Ruby for transpilation)
mkdir -p app/javascript/controllers
cat > app/javascript/controllers/chat_controller.rb << 'CONTROLLER'
class ChatController < Stimulus::Controller
  # Auto-scroll to show the new message
  def messageTargetConnected(element)
    element.scrollIntoView()
  end

  # Clear the message input after form submission
  def clearInput
    bodyTarget.value = ""
    bodyTarget.focus()
  end
end
CONTROLLER

# Update fixtures with valid data
cat > test/fixtures/messages.yml << 'FIXTURES'
one:
  username: Alice
  body: Hey everyone! Welcome to the chat room.

two:
  username: Bob
  body: Hi Alice! This is pretty cool.
FIXTURES

# Model tests
cat > test/models/message_test.rb << 'TEST'
require "test_helper"

class MessageTest < ActiveSupport::TestCase
  test "creates a message with valid attributes" do
    message = messages(:one)
    assert_not_nil message.id
    assert_equal "Alice", message.username
  end

  test "validates username presence" do
    message = Message.new(username: "", body: "Valid body")
    assert_not message.save
  end

  test "validates body presence" do
    message = Message.new(username: "TestUser", body: "")
    assert_not message.save
  end
end
TEST

# Controller tests
cat > test/controllers/messages_controller_test.rb << 'TEST'
require "test_helper"

class MessagesControllerTest < ActionDispatch::IntegrationTest
  setup do
    @message = messages(:one)
  end

  test "should get index" do
    get messages_url
    assert_response :success
    assert_select "h1", "Chat Room"
    assert_select "#messages" do
      assert_select "div", minimum: 1
    end
  end

  test "should create message" do
    assert_difference("Message.count") do
      post messages_url, params: { message: { username: "Carol", body: "Hello!" } }
    end
    assert_redirected_to messages_path
  end

  test "should not create message with invalid params" do
    assert_no_difference("Message.count") do
      post messages_url, params: { message: { username: "", body: "" } }
    end
    assert_redirected_to messages_path
  end

  test "should destroy message" do
    assert_difference("Message.count", -1) do
      delete message_url(@message)
    end
    assert_redirected_to messages_path
  end

  test "clears input after form submission" do
    skip unless defined? Document
    get messages_url
    connect_stimulus "chat", ChatController

    body_input = document.querySelector("[data-chat-target='body']")
    body_input.value = "Hello!"

    form = document.querySelector("form")
    form.dispatchEvent(Event.new("turbo:submit-end", bubbles: true))

    assert_equal "", body_input.value
  end

  test "auto-scrolls on new message" do
    skip unless defined? Document
    Element.prototype.scrollIntoView = -> {}
    get messages_url
    connect_stimulus "chat", ChatController

    messages_div = document.querySelector("#messages")
    new_msg = document.createElement("div")
    new_msg.setAttribute("data-chat-target", "message")
    new_msg.scrollIntoView = vi.fn()
    messages_div.appendChild(new_msg)

    await_mutations

    assert new_msg.scrollIntoView.mock.calls.length > 0
  end
end
TEST

echo ""
echo "Chat created: $APP_NAME/"
echo ""
echo "To run with Juntos (transpiled to JavaScript):"
echo "  cd $APP_NAME"
echo "  bin/juntos dev -d dexie      # Browser with IndexedDB"
echo "  bin/juntos dev -d sqljs      # Browser with sql.js (SQLite in WASM)"
echo ""
echo "To deploy to Cloudflare:"
echo "  cd $APP_NAME"
echo "  bin/juntos db:prepare -d d1  # Create D1 database, migrate, seed"
echo "  bin/juntos deploy -d d1      # Deploy to Cloudflare Workers"
echo ""
echo "To run with Rails:"
echo "  cd $APP_NAME"
echo "  bin/rails db:prepare"
echo "  bin/rails server"
echo ""
echo "Open multiple browser tabs to see real-time messaging!"
echo ""
