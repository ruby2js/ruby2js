#!/usr/bin/env bash
# Create a Ruby2JS blog demo with nested routes and real-time updates
# Usage: create-blog [app-name]
#
# Creates a Rails app with Article and Comment models featuring:
# - Nested routes for articles and comments
# - Real-time updates via Turbo Streams broadcasting
# - broadcasts_to for automatic create/update/destroy broadcasts

set -e

APP_NAME="${1:-blog}"

echo "Creating Ruby2JS blog: $APP_NAME"
echo ""

# Create Rails app (minimal, with Tailwind for nice styling)
rails new "$APP_NAME" --skip-git --skip-docker --css tailwind
cd "$APP_NAME"

# Generate Article scaffold
rails generate scaffold Article title:string body:text

# Generate Comment scaffold (will be nested under articles)
rails generate scaffold Comment article:references commenter:string body:text

# Create database (migration and seeding done separately)
rails db:create

# Add ruby2js gem from GitHub (branch required for bundle config local to work)
bundle add ruby2js --github ruby2js/ruby2js --branch master

# Ensure git checkout is complete (handles Bundler version upgrade)
bundle install

# Update Article model with associations, validations, and broadcasting
cat > app/models/article.rb << 'MODEL'
class Article < ApplicationRecord
  has_many :comments, dependent: :destroy

  # Broadcast article changes to index page subscribers
  broadcasts_to -> { "articles" }, inserts_by: :prepend

  validates :title, presence: true
  validates :body, presence: true, length: { minimum: 10 }
end
MODEL

# Update Comment model with broadcasting
cat > app/models/comment.rb << 'MODEL'
class Comment < ApplicationRecord
  belongs_to :article

  # Broadcast comment changes to article show page subscribers
  broadcasts_to -> { "article_#{article_id}_comments" }, target: "comments"
end
MODEL

# Set up nested routes
cat > config/routes.rb << 'ROUTES'
Rails.application.routes.draw do
  root "articles#index"

  resources :articles do
    resources :comments, only: [:create, :destroy]
  end
end
ROUTES

# Update ArticlesController to use eager loading
sed -i.bak 's/@articles = Article.all/@articles = Article.includes(:comments).all/' app/controllers/articles_controller.rb
rm -f app/controllers/articles_controller.rb.bak

# Add turbo_stream_from subscription to articles index for real-time updates
sed -i.bak '1s/^/<%= turbo_stream_from "articles" %>\n\n<div id="articles">\n/' app/views/articles/index.html.erb
echo '</div>' >> app/views/articles/index.html.erb
rm -f app/views/articles/index.html.erb.bak

# Update article partial with ID for targeting and comment count
# The ID allows turbo streams to target individual articles for updates/removal
cat > app/views/articles/_article.html.erb << 'PARTIAL'
<div id="<%= dom_id(article) %>" class="p-4 border rounded mb-4">
  <h2 class="text-xl font-bold">
    <%= link_to article.title, article, class: "text-blue-600 hover:underline" %>
    <span id="<%= dom_id(article, :comments_count) %>" class="text-gray-500 text-sm font-normal ml-2">
      (<%= pluralize(article.comments.size, "comment") %>)
    </span>
  </h2>
  <p class="text-gray-700 mt-2"><%= truncate(article.body, length: 100) %></p>
  <div class="mt-2 space-x-2">
    <%= link_to "Show", article, class: "text-blue-600" %>
    <%= link_to "Edit", edit_article_path(article), class: "text-blue-600" %>
    <%= button_to "Delete", article, method: :delete, class: "text-red-600",
        data: { turbo_confirm: "Are you sure?" } %>
  </div>
</div>
PARTIAL

# Update CommentsController for nested routes
# Note: broadcasts_to handles real-time updates automatically, so we just use simple redirects
cat > app/controllers/comments_controller.rb << 'CONTROLLER'
class CommentsController < ApplicationController
  before_action :set_article

  def create
    @comment = @article.comments.build(comment_params)
    if @comment.save
      redirect_to @article, notice: "Comment was successfully created."
    else
      redirect_to @article, alert: "Could not create comment."
    end
  end

  def destroy
    @comment = @article.comments.find(params[:id])
    @comment.destroy
    redirect_to @article, notice: "Comment was successfully deleted."
  end

  private

  def set_article
    @article = Article.find(params[:article_id])
  end

  def comment_params
    params.require(:comment).permit(:commenter, :body)
  end
end
CONTROLLER

# Create comment partial for rendering individual comments
cat > app/views/comments/_comment.html.erb << 'PARTIAL'
<div id="<%= dom_id(comment) %>" class="p-4 bg-gray-50 rounded">
  <p class="font-semibold"><%= comment.commenter %></p>
  <p class="text-gray-700"><%= comment.body %></p>
  <%= button_to "Delete", [comment.article, comment], method: :delete,
      class: "text-red-600 text-sm mt-2",
      data: { turbo_confirm: "Are you sure?" } %>
</div>
PARTIAL

# Add comments section to article show view with real-time updates
cat >> app/views/articles/show.html.erb << 'VIEW'

<hr class="my-8">

<h2 class="text-xl font-bold mb-4">Comments</h2>

<%# Subscribe to real-time comment updates for this article %>
<%= turbo_stream_from "article_#{@article.id}_comments" %>

<div id="comments" class="space-y-4 mb-8">
  <%= render @article.comments %>
</div>

<h3 class="text-lg font-semibold mb-2">Add a Comment</h3>

<%= form_with model: [@article, Comment.new], class: "space-y-4" do |form| %>
  <div>
    <%= form.label :commenter, class: "block font-medium" %>
    <%= form.text_field :commenter, class: "block w-full border rounded p-2" %>
  </div>
  <div>
    <%= form.label :body, class: "block font-medium" %>
    <%= form.text_area :body, rows: 3, class: "block w-full border rounded p-2" %>
  </div>
  <%= form.submit "Add Comment", class: "bg-blue-600 text-white px-4 py-2 rounded" %>
<% end %>
VIEW

# Rebuild Tailwind CSS to include all view classes
bin/rails tailwindcss:build

# Create seeds with sample articles and comments
cat > db/seeds.rb << 'SEEDS'
# Sample articles and comments for the blog demo
# Seeds are idempotent - only run if database is empty
return if Article.count > 0

article1 = Article.create!(
  title: "Getting Started with Rails",
  body: "Rails is a web application framework running on the Ruby programming language. It makes building web apps faster and easier with conventions over configuration."
)

article1.comments.create!(
  commenter: "Alice",
  body: "Great introduction! Rails really does make development faster."
)

article1.comments.create!(
  commenter: "Bob",
  body: "I love how Rails handles database migrations automatically."
)

article2 = Article.create!(
  title: "Understanding MVC Architecture",
  body: "MVC stands for Model-View-Controller. Models handle data and business logic, Views display information to users, and Controllers coordinate between them."
)

article2.comments.create!(
  commenter: "Carol",
  body: "This pattern really helps keep code organized!"
)

article3 = Article.create!(
  title: "Ruby2JS: Rails Everywhere",
  body: "Ruby2JS transpiles Ruby to JavaScript, enabling Rails applications to run in browsers, on Node.js, and at the edge. Same code, different runtimes."
)

puts "Created #{Article.count} articles and #{Comment.count} comments"
SEEDS

# Run ruby2js:install generator to set up dist/, package.json, and npm dependencies
bin/rails generate ruby2js:install

echo ""
echo "Blog created: $APP_NAME/"
echo ""
echo "Features:"
echo "  - Real-time updates via Turbo Streams broadcasting"
echo "  - Index page updates when articles are added/removed"
echo "  - Article page updates when comments are added/removed"
echo ""
echo "To run with Juntos (transpiled to JavaScript):"
echo "  cd $APP_NAME"
echo "  bin/juntos dev -d dexie      # Browser with IndexedDB"
echo "  bin/juntos dev -d sqljs      # Browser with sql.js (SQLite in WASM)"
echo ""
echo "To deploy to Cloudflare:"
echo "  cd $APP_NAME"
echo "  bin/juntos db:prepare -d d1  # Create D1 database, migrate, seed"
echo "  bin/juntos deploy -d d1      # Deploy to Cloudflare Workers"
echo ""
echo "To run with Rails:"
echo "  cd $APP_NAME"
echo "  bin/rails db:prepare"
echo "  bin/rails server"
echo ""
echo "Open multiple browser tabs to see real-time updates!"
echo ""
