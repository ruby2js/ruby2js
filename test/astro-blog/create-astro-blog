#!/usr/bin/env bash
# Create an Astro blog demo with .astro.rb, .jsx.rb, and .erb.rb files
# Usage: create-astro-blog [app-name]
#
# Creates a full-stack blog demo featuring:
# - Level 1: Static content (.md) - About page
# - Level 2: Astro pages (.astro.rb) - Layout, landing, post shells
# - Level 3: Preact Islands (.jsx.rb or .erb.rb) - PostList, PostForm, Counter
#
# This demonstrates Ruby2JS at every level of an Astro project.

set -e

APP_NAME="${1:-astro-blog}"

# Calculate script location before cd'ing anywhere
SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
REPO_ROOT="$(cd "$SCRIPT_DIR/../.." && pwd)"

echo "Creating Astro blog: $APP_NAME"
echo ""

# Get the directory name for cd (handle both relative and absolute paths)
APP_DIR="$APP_NAME"
if [[ "$APP_NAME" == /* ]]; then
  # Absolute path - use as-is
  APP_DIR="$APP_NAME"
else
  # Relative path - will be created in current directory
  APP_DIR="$PWD/$APP_NAME"
fi

# Create Astro project (minimal template, no git, skip prompts)
npm create astro@latest "$APP_NAME" -- --template minimal --no-git --skip-houston --yes

cd "$APP_DIR"

# Install dependencies
# In CI, these will be replaced with the actual tarball paths
if [ -n "$RUBY2JS_TARBALL" ]; then
  npm install "$RUBY2JS_TARBALL" "$ASTRO_INTEGRATION_TARBALL" "$VITE_PLUGIN_TARBALL" "$RAILS_TARBALL"
  npm install @astrojs/preact preact dexie
else
  # Default: assume we're in the ruby2js repo for local dev
  npm install "$REPO_ROOT/demo/selfhost" "$REPO_ROOT/packages/ruby2js-astro" "$REPO_ROOT/packages/vite-plugin-ruby2js" "$REPO_ROOT/packages/ruby2js-rails"
  npm install @astrojs/preact preact dexie
fi

# Remove the default index.astro from the template
rm -f src/pages/index.astro

# Create directory structure
mkdir -p src/layouts src/pages/posts src/islands src/models src/lib public

# ============================================
# Astro configuration with Preact + Ruby2JS
# ============================================

cat > astro.config.mjs << 'CONFIG'
import { defineConfig } from 'astro/config';
import preact from '@astrojs/preact';
import ruby2js from 'ruby2js-astro';
import ruby2jsVite from 'vite-plugin-ruby2js';

export default defineConfig({
  integrations: [
    ruby2js(),
    preact()
  ],
  vite: {
    plugins: [
      // Handle .jsx.rb and .erb.rb files -> JSX with React+JSX filters
      // .jsx.rb: Ruby with inline %x{} JSX
      // .erb.rb: Ruby with ERB-style __END__ template
      ruby2jsVite({
        include: ['**/*.jsx.rb', '**/*.erb.rb'],
      })
    ]
  }
});
CONFIG

# ============================================
# Level 1: Static Content (Markdown)
# ============================================

cat > src/pages/about.md << 'ABOUT'
---
layout: ../layouts/Layout.astro
title: About
---

# About This Blog

This is a demo of Ruby2JS with Astro. It shows how Ruby can be used
at every level of an Astro project:

1. **Static content** (this page) - Plain markdown, no Ruby required
2. **Astro pages** - Ruby code in `.astro.rb` files, rendered at build time
3. **Interactive islands** - Preact components in `.jsx.rb` files, hydrated on client

## How It Works

- Posts are stored in **IndexedDB** using [Dexie.js](https://dexie.org/)
- The **PostList** island displays posts from the database
- The **PostForm** island creates new posts
- All Ruby code transpiles to JavaScript via Ruby2JS

Built with Ruby2JS.
ABOUT

# ============================================
# Level 2: Layout with View Transitions
# ============================================

cat > src/layouts/Layout.astro.rb << 'LAYOUT'
import ['ViewTransitions'], from: 'astro:transitions'

# Support both direct props (Astro pages) and frontmatter (markdown pages)
@title = Astro.props[:title] || Astro.props[:frontmatter]&.[](:title) || "Astro Blog"
__END__
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>{title}</title>
  <ViewTransitions />
  <style>
    :root {
      --color-bg: #f8fafc;
      --color-text: #1e293b;
      --color-primary: #3b82f6;
      --color-muted: #64748b;
      --color-border: #e2e8f0;
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: system-ui, -apple-system, sans-serif;
      background: var(--color-bg);
      color: var(--color-text);
      line-height: 1.6;
    }
    .container {
      max-width: 800px;
      margin: 0 auto;
      padding: 2rem;
    }
    a { color: var(--color-primary); text-decoration: none; }
    a:hover { text-decoration: underline; }
    nav {
      padding: 1rem 2rem;
      border-bottom: 1px solid var(--color-border);
      background: white;
    }
    nav a { margin-right: 1rem; }
    .post-card {
      padding: 1rem;
      margin: 1rem 0;
      background: white;
      border: 1px solid var(--color-border);
      border-radius: 8px;
    }
    .post-form input, .post-form textarea {
      width: 100%;
      margin: 0.5rem 0;
      padding: 0.75rem;
      border: 1px solid var(--color-border);
      border-radius: 4px;
      font-size: 1rem;
    }
    .post-form button {
      background: var(--color-primary);
      color: white;
      padding: 0.75rem 1.5rem;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 1rem;
    }
    .post-form button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
    .loading { color: var(--color-muted); }
    h1 { margin-bottom: 1rem; }
    h2 { margin: 1.5rem 0 1rem; }
  </style>
</head>
<body>
  <nav>
    <a href="/">Home</a>
    <a href="/posts">Posts</a>
    <a href="/about">About</a>
  </nav>
  <div class="container">
    <slot />
  </div>
</body>
</html>
LAYOUT

# ============================================
# Level 2: Landing Page
# ============================================

cat > src/pages/index.astro.rb << 'INDEX'
import Layout, from: '../layouts/Layout.astro'

@title = "Astro Blog with Ruby2JS"
__END__
<Layout title={title}>
  <main>
    <h1>Welcome to the Astro Blog</h1>
    <p style="margin-bottom: 2rem;">
      This demo shows Ruby2JS working at every level of an Astro project.
    </p>

    <section style="margin-bottom: 2rem;">
      <h2>Three Levels of Ruby</h2>
      <ul style="list-style: disc; padding-left: 1.5rem;">
        <li><strong>Level 1:</strong> Static markdown (<a href="/about">About page</a>)</li>
        <li><strong>Level 2:</strong> Astro pages in <code>.astro.rb</code> (this page)</li>
        <li><strong>Level 3:</strong> Preact islands in <code>.jsx.rb</code> or <code>.erb.rb</code> (<a href="/posts">Posts page</a>)</li>
      </ul>
    </section>

    <section>
      <h2>Get Started</h2>
      <p>
        Visit the <a href="/posts">Posts page</a> to create and view blog posts.
        Posts are stored in your browser's IndexedDB.
      </p>
    </section>
  </main>
</Layout>
INDEX

# ============================================
# Level 2: Posts Shell (hosts islands)
# ============================================

cat > src/pages/posts/index.astro.rb << 'POSTS'
import Layout, from: '../../layouts/Layout.astro'
import PostList, from: '../../islands/PostList.jsx'
import PostForm, from: '../../islands/PostForm.jsx'
import Counter, from: '../../islands/Counter.jsx'

@title = "Blog Posts"
__END__
<Layout title={title}>
  <main>
    <h1>Blog Posts</h1>

    <section style="margin-bottom: 2rem;">
      <PostList client:load />
    </section>

    <section style="margin-bottom: 2rem;">
      <h2>Create New Post</h2>
      <PostForm client:load />
    </section>

    <section style="padding: 1rem; background: #fff; border: 1px solid var(--color-border); border-radius: 8px;">
      <p style="color: var(--color-muted); font-size: 0.875rem; margin-bottom: 0.5rem;">
        This counter uses the <code>.erb.rb</code> format (ERB-style templates)
      </p>
      <Counter client:load initial={0} />
    </section>
  </main>
</Layout>
POSTS

# ============================================
# Level 2: Post Detail Shell
# ============================================

cat > 'src/pages/posts/[slug].astro.rb' << 'POSTDETAIL'
import Layout, from: '../../layouts/Layout.astro'
import PostDetail, from: '../../islands/PostDetail.jsx'

# Return empty paths - this route loads data client-side from IndexedDB
# Routes are accessed via View Transitions navigation, not pre-rendered
export def getStaticPaths
  []
end

@slug = Astro.params.slug
@title = "Post"
__END__
<Layout title={title}>
  <article>
    <PostDetail client:load slug={slug} />
    <footer style="margin-top: 2rem; padding-top: 1rem; border-top: 1px solid var(--color-border);">
      <a href="/posts">&larr; Back to all posts</a>
    </footer>
  </article>
</Layout>
POSTDETAIL

# ============================================
# Database Setup (JavaScript)
# ============================================

cat > src/lib/db.js << 'DATABASE'
import Dexie from 'dexie';

// Create the database
const db = new Dexie('astro_blog');

// Define schema (using camelCase to match Ruby2JS transpiled code)
db.version(1).stores({
  posts: '++id, title, slug, createdAt, updatedAt'
});

// Simple Post model wrapping Dexie
export class Post {
  constructor(attrs = {}) {
    Object.assign(this, attrs);
  }

  static get table() {
    return db.posts;
  }

  static async all() {
    const rows = await this.table.orderBy('createdAt').reverse().toArray();
    return rows.map(r => new Post(r));
  }

  static async find(id) {
    const row = await this.table.get(Number(id));
    return row ? new Post(row) : null;
  }

  static async findBy(conditions) {
    const row = await this.table.where(conditions).first();
    return row ? new Post(row) : null;
  }

  static async count() {
    return await this.table.count();
  }

  static async create(attrs) {
    const now = new Date().toISOString();
    const data = {
      ...attrs,
      slug: attrs.slug || attrs.title.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/(^-|-$)/g, ''),
      createdAt: attrs.createdAt || now,
      updatedAt: now
    };
    const id = await this.table.add(data);
    return new Post({ ...data, id });
  }

  async save() {
    const now = new Date().toISOString();
    this.updatedAt = now;
    if (!this.slug) {
      this.slug = this.title.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/(^-|-$)/g, '');
    }
    if (this.id) {
      await Post.table.put({ ...this });
    } else {
      this.createdAt = this.createdAt || now;
      this.id = await Post.table.add({ ...this });
    }
    return this;
  }

  async destroy() {
    if (this.id) {
      await Post.table.delete(this.id);
    }
  }
}

// Setup and seed database
export async function setupDatabase() {
  await db.open();

  // Seed if empty
  const count = await Post.count();
  if (count === 0) {
    await Post.create({
      title: 'Getting Started with Ruby2JS',
      body: 'Ruby2JS allows you to write your Astro components in Ruby, which gets transpiled to JavaScript at build time.\n\nThis post was seeded automatically to demonstrate the blog functionality.',
      slug: 'getting-started'
    });

    await Post.create({
      title: 'Preact Islands in Astro',
      body: 'Astro islands provide partial hydration for interactive components. This demo uses Preact for the PostList and PostForm islands.\n\nThe Ruby code in .jsx.rb files transpiles to JSX, which Astro then processes with Preact.',
      slug: 'preact-islands'
    });

    await Post.create({
      title: 'ActiveRecord in the Browser',
      body: 'With Dexie.js as the backend, you can use ActiveRecord-like patterns in the browser.\n\nPost.all, Post.find, Post.create - familiar patterns for Rails developers.',
      slug: 'activerecord-browser'
    });

    console.log('Seeded 3 posts');
  }

  return db;
}

export { db };
DATABASE

# ============================================
# Level 2: ISR Cache Utility
# ============================================

cat > src/lib/isr.js << 'ISR'
// In-memory cache with stale-while-revalidate semantics
const cache = new Map();

export async function withRevalidate(key, ttlSeconds, fetcher) {
  const cached = cache.get(key);
  const now = Date.now();

  if (cached && now < cached.staleAt) {
    return cached.data; // Fresh
  }

  if (cached) {
    // Stale - return cached, revalidate in background
    fetcher().then(data => {
      cache.set(key, { data, staleAt: now + ttlSeconds * 1000 });
    });
    return cached.data;
  }

  // Missing - fetch fresh
  const data = await fetcher();
  cache.set(key, { data, staleAt: now + ttlSeconds * 1000 });
  return data;
}

export function invalidate(key) {
  cache.delete(key);
}

export function invalidateAll() {
  cache.clear();
}
ISR

# ============================================
# Level 3: PostList Island (.jsx.rb)
# ============================================

cat > src/islands/PostList.jsx.rb << 'POSTLIST'
import ['useState', 'useEffect'], from: 'preact/hooks'
import ['setupDatabase', 'Post'], from: '../lib/db.js'
import ['withRevalidate', 'invalidate'], from: '../lib/isr.js'

def PostList()
  posts, setPosts = useState([])
  loading, setLoading = useState(true)

  loadPosts = -> {
    # Use ISR cache with 60 second TTL
    withRevalidate('posts:all', 60, -> { Post.all() }).then do |data|
      setPosts(data)
      setLoading(false)
    end
  }

  useEffect -> {
    setupDatabase().then { loadPosts.() }
  }, []

  # Listen for post changes - invalidate cache and reload
  useEffect -> {
    handler = ->(e) {
      invalidate('posts:all')
      loadPosts.()
    }
    window.addEventListener('post-created', handler)
    window.addEventListener('post-updated', handler)
    window.addEventListener('post-deleted', handler)
    -> {
      window.removeEventListener('post-created', handler)
      window.removeEventListener('post-updated', handler)
      window.removeEventListener('post-deleted', handler)
    }
  }, []

  return %x{<div class="loading">Loading posts...</div>} if loading
  return %x{<p>No posts yet. Create one below!</p>} if posts.length == 0

  # Render a single post card - defined separately to avoid arrow function parsing issues in JSX
  renderPost = ->(post) {
    %x{<article key={post.id} class="post-card">
      <h3>
        <a href={"/posts/" + post.slug}>{post.title}</a>
      </h3>
      <time style="color: var(--color-muted); font-size: 0.875rem;">
        {new Date(post.created_at).toLocaleDateString()}
      </time>
      <p style="margin-top: 0.5rem;">
        {post.body.slice(0, 150)}...
      </p>
    </article>}
  }

  %x{<div class="posts">
    {posts.map(renderPost)}
  </div>}
end

export default PostList
POSTLIST

# ============================================
# Level 3: PostForm Island (.jsx.rb)
# ============================================

cat > src/islands/PostForm.jsx.rb << 'POSTFORM'
import ['useState', 'useEffect'], from: 'preact/hooks'
import ['Post'], from: '../lib/db.js'

def PostForm(post: nil, onSave: nil, onCancel: nil)
  postTitle, setPostTitle = useState(post ? post.title : "")
  postBody, setPostBody = useState(post ? post.body : "")
  saving, setSaving = useState(false)

  # Update form when post prop changes
  useEffect -> {
    setPostTitle(post ? post.title : "")
    setPostBody(post ? post.body : "")
  }, [post&.id]

  handleSubmit = ->(e) {
    e.preventDefault()
    return if postTitle.trim() == "" || postBody.trim() == ""

    setSaving(true)

    if post
      # Update existing post
      post.title = postTitle
      post.body = postBody
      post.save().then do
        setSaving(false)
        onSave.(post) if onSave
      end
    else
      # Create new post
      Post.create({ title: postTitle, body: postBody }).then do |newPost|
        setPostTitle("")
        setPostBody("")
        setSaving(false)
        onSave.(newPost) if onSave
        # Notify PostList to refresh
        window.dispatchEvent(new CustomEvent('post-created'))
      end
    end
  }

  isEditing = !!post
  buttonText = saving ? (isEditing ? "Saving..." : "Creating...") : (isEditing ? "Save Changes" : "Create Post")

  %x{<form onSubmit={handleSubmit} class="post-form">
    <input
      type="text"
      value={postTitle}
      onInput={->(e) { setPostTitle(e.target.value) }}
      placeholder="Post title"
      disabled={saving}
    />
    <textarea
      value={postBody}
      onInput={->(e) { setPostBody(e.target.value) }}
      placeholder="Write your post..."
      rows={6}
      disabled={saving}
    />
    <div style="display: flex; gap: 0.5rem;">
      <button type="submit" disabled={saving || postTitle.trim() == "" || postBody.trim() == ""}>
        {buttonText}
      </button>
      {isEditing && onCancel && (
        <button type="button" onClick={onCancel} disabled={saving} style="background: var(--color-muted);">
          Cancel
        </button>
      )}
    </div>
  </form>}
end

export default PostForm
POSTFORM

# ============================================
# Level 3: Counter Island (.erb.rb) - ERB template style
# ============================================
# This demonstrates the alternative ERB template syntax for Preact islands
# The template goes after __END__ and uses ERB-style tags

cat > src/islands/Counter.erb.rb << 'COUNTER'
import ['useState'], from: 'preact/hooks'

def Counter(initial: 0)
  count, setCount = useState(initial)

  increment = -> { setCount(count + 1) }
  decrement = -> { setCount(count - 1) }
  reset = -> { setCount(initial) }

  render
end

export default Counter
__END__
<div class="counter">
  <h3>Counter Demo</h3>
  <p style="font-size: 2rem; font-weight: bold;"><%= count %></p>
  <div style="display: flex; gap: 0.5rem;">
    <button onClick={decrement}>-</button>
    <button onClick={reset}>Reset</button>
    <button onClick={increment}>+</button>
  </div>
  <p style="color: var(--color-muted); font-size: 0.875rem;">
    <% if count > 0 %>
      Count is positive
    <% elsif count < 0 %>
      Count is negative
    <% else %>
      Count is zero
    <% end %>
  </p>
</div>
COUNTER

# ============================================
# Level 3: PostDetail Island (.jsx.rb) - View/Edit/Delete
# ============================================

cat > src/islands/PostDetail.jsx.rb << 'POSTDETAIL_ISLAND'
import ['useState', 'useEffect'], from: 'preact/hooks'
import ['setupDatabase', 'Post'], from: '../lib/db.js'
import PostForm, from: './PostForm.jsx'

def PostDetail(slug:)
  post, setPost = useState(nil)
  loading, setLoading = useState(true)
  editing, setEditing = useState(false)
  deleted, setDeleted = useState(false)

  useEffect -> {
    setupDatabase().then do
      Post.findBy({ slug: slug }).then do |found|
        setPost(found)
        setLoading(false)
      end
    end
  }, [slug]

  handleDelete = -> {
    return unless window.confirm("Are you sure you want to delete this post?")
    post.destroy().then do
      setDeleted(true)
      # Notify PostList to refresh
      window.dispatchEvent(new CustomEvent('post-deleted'))
    end
  }

  handleSave = ->(updated) {
    setPost(updated)
    setEditing(false)
    # Notify PostList to refresh
    window.dispatchEvent(new CustomEvent('post-updated'))
  }

  return %x{<p class="loading">Loading post...</p>} if loading
  return %x{<p>Post not found. <a href="/posts">Back to posts</a></p>} unless post

  if deleted
    return %x{
      <div style="text-align: center; padding: 2rem;">
        <p style="color: var(--color-muted);">Post deleted successfully.</p>
        <a href="/posts" style="margin-top: 1rem; display: inline-block;">&larr; Back to all posts</a>
      </div>
    }
  end

  if editing
    return %x{
      <div>
        <h2>Edit Post</h2>
        <PostForm post={post} onSave={handleSave} onCancel={-> { setEditing(false) }} />
      </div>
    }
  end

  %x{<div>
    <h1>{post.title}</h1>
    <time style="color: var(--color-muted); display: block; margin-bottom: 1rem;">
      {new Date(post.createdAt).toLocaleDateString()}
    </time>
    <div style="white-space: pre-wrap; line-height: 1.6; margin-bottom: 2rem;">
      {post.body}
    </div>
    <div style="display: flex; gap: 0.5rem; padding-top: 1rem; border-top: 1px solid var(--color-border);">
      <button onClick={-> { setEditing(true) }}>
        Edit
      </button>
      <button onClick={handleDelete} style="background: #dc2626;">
        Delete
      </button>
      <a href="/posts" style="margin-left: auto; color: var(--color-muted);">
        &larr; Back to posts
      </a>
    </div>
  </div>}
end

export default PostDetail
POSTDETAIL_ISLAND

# ============================================
# Favicon
# ============================================

cat > public/favicon.svg << 'FAVICON'
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100">
  <text y="0.9em" font-size="80">ðŸ’Ž</text>
</svg>
FAVICON

# ============================================
# Dockerfile
# ============================================

cat > Dockerfile << 'DOCKERFILE'
FROM node:24-slim

WORKDIR /app

# Copy package files and install dependencies
COPY package*.json ./
RUN npm install

# Copy source files
COPY . .

# Build the static site
RUN npm run build

# Serve with a simple static server
RUN npm install -g serve

EXPOSE 4321

CMD ["serve", "-s", "dist", "-l", "4321"]
DOCKERFILE

echo ""
echo "==================================="
echo "Astro blog created: $APP_NAME"
echo "==================================="
echo ""
echo "Features:"
echo "  - Level 1: Static markdown (/about)"
echo "  - Level 2: Astro pages in .astro.rb"
echo "  - Level 3: Preact islands in .jsx.rb or .erb.rb"
echo "  - IndexedDB storage via Dexie.js"
echo "  - View Transitions for smooth navigation"
echo ""
echo "To run locally:"
echo "  cd $APP_NAME"
echo "  npm run dev"
echo ""
echo "To build for production:"
echo "  npm run build"
echo ""
echo "To run with Docker:"
echo "  docker build -t astro-blog ."
echo "  docker run -p 4321:4321 astro-blog"
echo ""
