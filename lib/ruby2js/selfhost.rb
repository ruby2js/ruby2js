#!/usr/bin/env ruby
# frozen_string_literal: true

# Self-hosting script for Ruby2JS
#
# This script transpiles Ruby2JS's converter and handlers to JavaScript,
# enabling Ruby2JS to run in the browser without a Ruby runtime.
#
# Usage:
#   ruby lib/ruby2js/selfhost.rb > output.js
#   ruby lib/ruby2js/selfhost.rb --check  # validate syntax only
#   ruby lib/ruby2js/selfhost.rb --esm    # output ES module with exports

require 'ruby2js'
require 'ruby2js/filter/combiner'
require 'ruby2js/filter/return'
require 'ruby2js/filter/selfhost'
require 'ruby2js/filter/functions'

module Ruby2JS
  module Selfhost
    # Base files that form the core converter
    # serializer.rb uses composition (Token wraps string, Line wraps array)
    # instead of inheritance for JS compatibility
    CORE_FILES = [
      'lib/ruby2js/serializer.rb',
      'lib/ruby2js/converter.rb'
    ].freeze

    # Handler files to include (add more as they're validated)
    HANDLER_FILES = [
      'lib/ruby2js/converter/literal.rb',
      'lib/ruby2js/converter/nil.rb',
      'lib/ruby2js/converter/boolean.rb',
      'lib/ruby2js/converter/self.rb',
      'lib/ruby2js/converter/sym.rb',
      'lib/ruby2js/converter/var.rb',
      'lib/ruby2js/converter/vasgn.rb',
      'lib/ruby2js/converter/ivar.rb',
      'lib/ruby2js/converter/ivasgn.rb',
      'lib/ruby2js/converter/array.rb',
      'lib/ruby2js/converter/hash.rb',
      'lib/ruby2js/converter/args.rb',
      'lib/ruby2js/converter/arg.rb',
      'lib/ruby2js/converter/send.rb',
      'lib/ruby2js/converter/def.rb',
      'lib/ruby2js/converter/begin.rb',
      'lib/ruby2js/converter/if.rb',
      'lib/ruby2js/converter/for.rb',
      'lib/ruby2js/converter/logical.rb',
      'lib/ruby2js/converter/return.rb',
      'lib/ruby2js/converter/masgn.rb',
      'lib/ruby2js/converter/class.rb',
      'lib/ruby2js/converter/block.rb',
      'lib/ruby2js/converter/case.rb',
      'lib/ruby2js/converter/kwbegin.rb',
      'lib/ruby2js/converter/casgn.rb',
      'lib/ruby2js/converter/cvar.rb',
      'lib/ruby2js/converter/cvasgn.rb',
      'lib/ruby2js/converter/opasgn.rb',
      'lib/ruby2js/converter/while.rb',
      'lib/ruby2js/converter/until.rb',
      'lib/ruby2js/converter/regexp.rb',
      'lib/ruby2js/converter/dstr.rb',
      'lib/ruby2js/converter/xstr.rb',
      'lib/ruby2js/converter/const.rb',
      'lib/ruby2js/converter/super.rb',
      'lib/ruby2js/converter/blockpass.rb',
      'lib/ruby2js/converter/next.rb',
      'lib/ruby2js/converter/break.rb',
      'lib/ruby2js/converter/ensure.rb',
      'lib/ruby2js/converter/nthref.rb'
    ].freeze

    # Filters to apply, in order
    FILTERS = [
      Ruby2JS::Filter::Combiner,   # Merge reopened classes/modules
      Ruby2JS::Filter::Return,     # Add return statements
      Ruby2JS::Filter::Selfhost,   # Ruby2JS-specific transforms
      Ruby2JS::Filter::Functions   # Ruby->JS method conversions
    ].freeze

    # JavaScript preamble: stub classes and Node representation
    # Token and Line are stubs (Ruby methods like empty? don't transpile)
    # Serializer is transpiled from serializer.rb
    PREAMBLE = <<~'JS'
      // Auto-generated by Ruby2JS self-hosting
      // This module provides a JavaScript implementation of Ruby2JS

      // AST Node class
      class Node {
        constructor(type, children = []) {
          this.type = type;
          this.children = Object.freeze(children);
          this.loc = null;
        }

        updated(newType, newChildren) {
          const n = new Node(newType || this.type, newChildren || this.children);
          n.loc = this.loc;
          return n;
        }
      }

      // S-expression helper
      function s(type, ...children) {
        return new Node(type, children);
      }

      // Stub base classes
      class NotImplementedError extends Error {
        constructor(message) {
          super(message);
          this.name = 'NotImplementedError';
        }
      }

      // Ruby Hash class stub (used for type checking in parse_all)
      class Hash {}

      // Token - wraps a string with AST location info
      // Hand-written because Ruby's def empty? doesn't transpile to valid JS
      class Token {
        constructor(value, ast) {
          this.value = value != null ? String(value) : '';
          this.ast = ast;
          this.loc = ast?.location || null;
        }
        toString() { return this.value; }
        get length() { return this.value.length; }
        isEmpty() { return this.value.length === 0; }
        startsWith(...args) { return this.value.startsWith(...args); }
        endsWith(...args) { return this.value.endsWith(...args); }
        gsub(pattern, replacement) { return this.value.replace(new RegExp(pattern, 'g'), replacement); }
        charAt(i) { return this.value[i]; }
        plus(other) { return this.value + String(other); }
      }

      // Line - holds tokens for a single output line
      // Hand-written because Ruby's def empty? doesn't transpile to valid JS
      class Line {
        constructor(...args) {
          this.tokens = args;
          this.indent = 0;
        }
        get length() { return this.tokens.length; }
        get(i) { return this.tokens[i]; }
        set(i, v) { this.tokens[i] = v; }
        push(...args) { this.tokens.push(...args); return this; }
        pop() { return this.tokens.pop(); }
        shift() { return this.tokens.shift(); }
        unshift(...args) { this.tokens.unshift(...args); return this; }
        get first() { return this.tokens[0]; }
        get last() { return this.tokens[this.tokens.length - 1]; }
        isEmpty() { return this.tokens.every(t => t.isEmpty()); }
        each(fn) { this.tokens.forEach(fn); }
        eachWithIndex(fn) { this.tokens.forEach((t, i) => fn(t, i)); }
        map(fn) { return this.tokens.map(fn); }
        find(fn) { return this.tokens.find(fn); }
        includes(item) { return this.tokens.includes(item); }
        toArray() { return this.tokens.map(t => t.toString()); }
        join(sep = '') { return this.tokens.map(t => t.toString()).join(sep); }
        insert(i, ...items) { this.tokens.splice(i, 0, ...items); }
        splice(start, count, ...items) {
          const removed = this.tokens.splice(start, count, ...items);
          return removed;
        }
        findLastIndex(fn) {
          for (let i = this.tokens.length - 1; i >= 0; i--) {
            if (fn(this.tokens[i])) return i;
          }
          return null;
        }
        isComment() {
          const first = this.find(t => !t.isEmpty());
          return first && first.startsWith('//');
        }
        toString() {
          if (this.isEmpty()) return '';
          const content = this.join();
          const first = this.tokens[0]?.toString();
          if (first === 'case ' || first === 'default:') {
            return ' '.repeat(Math.max(0, this.indent - 2)) + content;
          }
          if (this.indent > 0) return ' '.repeat(this.indent) + content;
          return content;
        }
      }

      // Serializer - output formatting for the converter
      // Hand-written because the Ruby version has operator overloading (def +)
      // and other patterns that don't transpile cleanly
      class Serializer {
        constructor() {
          this._sep = '; ';
          this._nl = '';
          this._ws = ' ';
          this._width = 80;
          this._indent = 0;
          this._lines = [new Line()];
          this._line = this._lines[this._lines.length - 1];
          this._timestamps = {};
          this._ast = null;
          this.file_name = '';
        }

        enable_vertical_whitespace() {
          this._sep = ";\n";
          this._nl = "\n";
          this._ws = this._nl;
          this._indent = 2;
        }

        // indent multi-line parameter lists, array constants, blocks
        reindent(lines) {
          let indent = 0;
          for (const line of lines) {
            const first = line.find(token => !token.isEmpty());
            if (first) {
              const lastIdx = line.findLastIndex(token => !token.isEmpty());
              const last = line.get(lastIdx);
              if ((first.startsWith('<') && line.includes('>')) ||
                  (last && last.endsWith('>') && line.includes('<'))) {
                const node = line.join('').match(/.*?(<.*)/)?.[1] || '';
                if (node.startsWith('</')) indent -= this._indent;
                line.indent = indent;
                const node2 = line.join('').match(/.*(<.*)/)?.[1] || '';
                if (!node2.includes('</') && !node2.includes('/>')) indent += this._indent;
              } else {
                if (')}]'.includes(first.charAt(0)) && indent >= this._indent) indent -= this._indent;
                line.indent = indent;
                if (last && '({['.includes(last.charAt(last.length - 1))) indent += this._indent;
              }
            } else {
              line.indent = indent;
            }
          }
        }

        // add horizontal (indentation) and vertical (blank lines) whitespace
        respace() {
          if (this._indent === 0) return;
          this.reindent(this._lines);

          for (let i = this._lines.length - 3; i >= 0; i--) {
            if (this._lines[i].length === 0) {
              this._lines.splice(i, 1);
            } else if (
              this._lines[i+1].isComment() && !this._lines[i].isComment() &&
              this._lines[i].indent === this._lines[i+1].indent
            ) {
              this._lines.splice(i+1, 0, new Line());
            } else if (
              this._lines[i].indent === this._lines[i+1].indent &&
              this._lines[i+1].indent < this._lines[i+2]?.indent &&
              !this._lines[i].isComment()
            ) {
              this._lines.splice(i+1, 0, new Line());
            } else if (
              this._lines[i].indent > this._lines[i+1].indent &&
              this._lines[i+1].indent === this._lines[i+2]?.indent &&
              !this._lines[i+2]?.isEmpty()
            ) {
              this._lines.splice(i+2, 0, new Line());
            }
          }
        }

        // add a single token to the current line
        put(string) {
          if (!(typeof string === 'string') || !string.includes('\n')) {
            this._line.push(new Token(string, this._ast));
          } else {
            const parts = string.split('\n');
            const first = parts.shift();
            if (first) this._line.push(new Token(first, this._ast));
            for (const part of parts) {
              this._lines.push(new Line(new Token(part, this._ast)));
            }
            if (string.endsWith('\n')) this._lines.push(new Line());
            this._line = this._lines[this._lines.length - 1];
          }
        }

        // add a single token and advance to next line
        puts(string) {
          if (!(typeof string === 'string') || !string.includes('\n')) {
            this._line.push(new Token(string, this._ast));
          } else {
            this.put(string);
          }
          this._line = new Line();
          this._lines.push(this._line);
        }

        // advance to next line and add a single token
        sput(string) {
          if (!(typeof string === 'string') || !string.includes('\n')) {
            this._line = new Line(new Token(string, this._ast));
            this._lines.push(this._line);
          } else {
            this._line = new Line();
            this._lines.push(this._line);
            this.put(string);
          }
        }

        // current location: [line number, token number]
        output_location() {
          return [this._lines.length - 1, this._line.length];
        }

        // insert a line into the output
        insert(mark, line) {
          if (mark[1] === 0) {
            this._lines.splice(mark[0], 0, new Line(new Token(line.replace(/\n$/, ''), this._ast)));
          } else {
            this._lines[mark[0]].splice(mark[1], 0, new Token(line, this._ast));
          }
        }

        // capture (and remove) tokens from the output stream
        capture(block) {
          const mark = this.output_location();
          block();
          let lines = this._lines.splice(mark[0] + 1);
          this._line = this._lines[this._lines.length - 1];

          if (lines.length === 0) {
            lines = [new Line(...this._line.splice(mark[1]))];
          } else if (this._line.length !== mark[1]) {
            lines.unshift(new Line(...this._line.splice(mark[1])));
          }

          return lines.map(l => l.join()).join(this._ws);
        }

        // wrap long statements in curly braces
        wrap(open = '{', close = '}', block) {
          this.puts(open);
          const mark = this.output_location();
          block();

          if (
            this._lines.length > mark[0] + 1 ||
            this._lines[mark[0] - 1].join().length + this._line.join().length >= this._width
          ) {
            this.sput(close);
          } else {
            this._line = this._lines[mark[0] - 1];
            const lastLine = this._lines.pop();
            this._line.pop();
            lastLine.each(token => this._line.push(token));
          }
        }

        // compact small expressions into a single line
        compact(block) {
          const mark = this.output_location();
          block();
          if (this._lines.length - mark[0] <= 1) return;
          if (this._indent === 0) return;

          let work = [];
          let len = 0;
          let trail = null;
          let split = null;
          const slice = this._lines.slice(mark[0]);
          this.reindent(slice);

          for (let index = 0; index < slice.length; index++) {
            const line = slice[index];
            if (line.length === 0) line.push(new Token('', null));
            if (line.first.startsWith('//')) {
              len += this._width;
            } else {
              if (trail === line.indent && this._indent > 0) { work.push(new Token(' ', null)); len += 1; }
              len += line.map(t => t.length).reduce((a, b) => a + b, 0);
              line.each(token => work.push(token));

              if (trail === this._indent && line.indent === this._indent) {
                split = [len, work.length, index];
                if (len >= this._width - 10) break;
              }
              trail = line.indent;
            }
          }

          if (len < this._width - 10) {
            this._lines.splice(mark[0], this._lines.length - mark[0]);
            this._lines.push(new Line(...work));
            this._line = this._lines[this._lines.length - 1];
          } else if (split && split[0] < this._width - 10) {
            if (slice[split[2]].indent < slice[split[2] + 1]?.indent) {
              const close = slice.pop();
              close.each(token => slice[slice.length - 1].push(token));
              this._lines[mark[0]] = new Line(...work.slice(0, split[1]));
              this._lines.splice(mark[0] + 1, this._lines.length - mark[0] - 1, ...slice.slice(split[2] + 1));
              this._line = this._lines[this._lines.length - 1];
            }
          }
        }

        // return the output as a string
        to_s() {
          if (this._str) return this._str;
          this.respace();
          return this._lines.map(l => l.toString()).join(this._nl);
        }
      }

      // Forward declaration for module (assigned by transpiled code)
      let Ruby2JS;

    JS

    # JavaScript postamble: handler discovery and exports
    POSTAMBLE = <<~'JS'
;
      // Discover and register all on_* handler methods
      // The Ruby code uses handle(:type) { } which calls define_method and registers the type.
      // After transpilation, we have on_* methods but the #$handlers static array is empty.
      // We populate it by scanning for on_* methods on the prototype.
      (function() {
        const proto = Converter.prototype;
        const types = [];
        for (const key of Object.getOwnPropertyNames(proto)) {
          if (key.startsWith('on_') && typeof proto[key] === 'function') {
            types.push(key.slice(3)); // Remove 'on_' prefix
          }
        }
        // Store in a way that the constructor can access
        Converter._discoveredHandlers = types;
      })();

      // Re-export classes for convenience
      // Note: Token, Line, Serializer are defined in preamble (not in Ruby2JS)
      // Converter is transpiled at the top level, not inside Ruby2JS module
      export { Node, s, Token, Line, Serializer, Ruby2JS, Converter };
    JS

    class << self
      def root
        @root ||= File.expand_path('../../..', __FILE__)
      end

      def transpile(esm: false)
        combined_code = (CORE_FILES + HANDLER_FILES).map do |file|
          path = File.join(root, file)
          File.read(path)
        end.join("\n")

        converter_js = Ruby2JS.convert(
          combined_code,
          eslevel: 2022,
          underscored_private: true,  # Required: prototype methods can't access private fields
          filters: FILTERS
        ).to_s

        if esm
          PREAMBLE + converter_js + POSTAMBLE
        else
          converter_js
        end
      end

      def check_syntax(js_code)
        require 'tempfile'
        Tempfile.create(['selfhost', '.mjs']) do |f|
          f.write(js_code)
          f.flush
          system('node', '--check', f.path)
        end
      end

      def transpile_spec(spec_path)
        spec_code = File.read(spec_path)

        # Transpile the spec
        spec_js = Ruby2JS.convert(
          spec_code,
          eslevel: 2022,
          filters: [
            Ruby2JS::Filter::Return,
            Ruby2JS::Filter::Selfhost,
            Ruby2JS::Filter::Functions
          ],
          selfhost_spec: true
        ).to_s

        SPEC_PREAMBLE + spec_js + SPEC_POSTAMBLE
      end
    end

    # JavaScript preamble for spec files
    SPEC_PREAMBLE = <<~'JS'
      // Transpiled spec file - auto-generated by Ruby2JS self-hosting
      // Do not edit directly - regenerate from Ruby source

      import { loadPrism } from "@ruby/prism";
      import { PrismWalker } from "./transpiled_walker.mjs";
      import { Converter } from "./selfhost_converter.mjs";
      import { describe, it, printResults } from "./test_harness.mjs";

      // Load Prism parser
      const parse = await loadPrism();

      // Self-hosted convert function (replaces Ruby2JS.convert)
      function convert(rubyCode, opts = {}) {
        const result = parse(rubyCode);
        if (result.errors && result.errors.length > 0) {
          throw new Error("Parse error: " + result.errors[0].message);
        }
        const walker = new PrismWalker(rubyCode);
        const ast = walker.visit(result.value);
        const converter = new Converter(ast, new Map());
        // Default to ES5 (no let/const) to match Ruby transliteration_spec defaults
        converter.eslevel = opts.eslevel || 5;
        converter.convert();
        return converter.to_s();
      }

      // Ruby2JS namespace for compatibility
      const Ruby2JS = { convert };

      // Stub for Rational (used in ivars test)
      function Rational(n, d) { return Math.floor(n / d); }

      // RUBY_VERSION stub (used in conditional tests)
      const RUBY_VERSION = "3.4.0";

    JS

    # JavaScript postamble for spec files
    SPEC_POSTAMBLE = <<~'JS'

      // Run tests and report results
      const success = printResults();
      process.exit(success ? 0 : 1);
    JS
  end
end

if __FILE__ == $0
  esm = ARGV.include?('--esm')
  spec_file = ARGV.find { |arg| arg.end_with?('_spec.rb') }

  if spec_file
    # Transpile a spec file
    js = Ruby2JS::Selfhost.transpile_spec(spec_file)
  else
    js = Ruby2JS::Selfhost.transpile(esm: esm)
  end

  if ARGV.include?('--check')
    if Ruby2JS::Selfhost.check_syntax(js)
      puts "JavaScript syntax is valid (#{js.lines.count} lines)"
    else
      exit 1
    end
  else
    puts js
  end
end
