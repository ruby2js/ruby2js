module Ruby2JS
  class Converter

    # (import str const) 

    # NOTE: import is a synthetic 

    handle :import do |path, *args|
      if module_type == :cjs
        # only the subset of import syntaxes generated by filters are handled here
        first_arg = args.first
        if ast_node?(first_arg) && first_arg.type == :attr
          return parse s(:casgn, *first_arg.children,
            s(:send, nil, :require, s(:str, Array(path).first))), :statement
        elsif first_arg.is_a?(Array) and first_arg.length == 1
          target = first_arg.first
          if ast_node?(target) && target.type == :attr && target.children.first == nil
            return parse s(:casgn, *target.children,
              s(:attr, s(:send, nil, :require, s(:str, Array(path).first)), target.children.last)),
              :statement
          end
        end
      end

      put 'import '

      if args.length == 0
        # import "file.css"
        put path.inspect
      else
        # import (x) from "file.js"
        default_import = !args.first.is_a?(Array) && %i[const send attr str].include?(args.first.type)

        if default_import and args.length > 1
          parse args.shift
          put ', '
          default_import = false
        end

        args = args.first if args.first.is_a?(Array)

        if args.first.type == :array
          args = args.first.children
        end

        # handle the default name or { ConstA, Const B } portion
        put "{ " unless default_import
        args.each_with_index do |arg, index|
          put ', ' unless index == 0
          if arg.type == :str
            put arg.children.first # useful for '*'
          else
            parse arg
          end
        end
        put " }" unless default_import

        from_kwarg_position = 0

        # should there be an as clause? e.g., import React as *
        if path.is_a?(Array) && !path[0].is_a?(String) && path[0].type == :pair && path[0].children[0].children[0] == :as
          put " as #{path[0].children[1].children.last}"

          # advance to the next kwarg, aka from
          from_kwarg_position = 1
        end

        put ' from '

        if path.is_a?(Array) && !path[from_kwarg_position].is_a?(String) && path[from_kwarg_position].type == :pair
          # from: "str" => from "str"
          if path[from_kwarg_position].children[0].children[0] == :from
            put path[from_kwarg_position].children[1].children[0].inspect
          else
            # from is missing
            put '""'
          end
        else
          # handle a str in either an array element or directly passed in
          put path.is_a?(Array) ? path[0].inspect : path.inspect
        end
      end
    end

    # (export const) 

    # NOTE: export is a synthetic 

    handle :export do |*args|
      # Output comments for export node
      comments(@ast).each { |comment| put comment }
      put 'export '

      # Clear comments from children to prevent duplication
      # (comments were already emitted for the export node itself)
      args.each do |arg|
        next unless arg.respond_to?(:type)
        if @comments.respond_to?(:set)
          @comments.set(arg, [])
        else
          @comments[arg] = []
        end
      end

      node = args.first
      final_export = false

      # export "*", from: "./file.js" => export * from "./file.js"
      if node.respond_to?(:type) && node.type == :str && node.children[0] == '*'
        put '* from '
        # args[1] should be a hash with from: key
        if args[1].respond_to?(:type) && args[1].type == :hash
          from_pair = args[1].children.find { |pair|
            pair.children[0].respond_to?(:children) && pair.children[0].children[0] == :from
          }
          if from_pair
            put from_pair.children[1].children[0].inspect
          end
        end
        return
      elsif node == :default
        put 'default '
        args.shift
      elsif node.respond_to?(:type) && node.children[1] == :default
        put 'default '
        args[0] = node.children[2]
      elsif node.respond_to?(:type) && [:lvasgn, :casgn].include?(node.type)
        if node.children[0] == :default
          put 'default '
          args[0] = node.children[1]
        else
          put 'const '
        end
      elsif node.respond_to?(:type) && node.type == :module
        # IIFE modules will add their own 'let' via lvasgn - don't add extra const here
        # Only modules that don't use IIFE need handling (they go through class_module)
      elsif node.respond_to?(:type) &&
        node.type == :array &&
        node.children[0].respond_to?(:type) &&
        (
          node.children[0].type == :const ||
          node.children[0].type == :send ||
          (node.children[0].type == :hash && node.children[0].children[0].children[0].children[0] == :default )
        )
        final_export = true
        put '{ '
        first = true
        node.children.each do |arg|
          if arg.type == :hash
            # Handle alias exports: four: alias1 => four as alias1
            arg.children.each do |pair|
              put ', ' unless first
              first = false
              key = pair.children[0].children[0]  # :sym node -> symbol
              value = pair.children[1]            # the alias target
              parse value
              put ' as '
              put key.to_s
            end
          else
            put ', ' unless first
            first = false
            parse arg
          end
        end
        put ' }'
      end

      unless final_export
        args.each_with_index do |arg, index|
          put ', ' unless index == 0
          parse arg
        end
      end
    end
  end
end
